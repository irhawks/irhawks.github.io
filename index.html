<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans,en,default">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="80x24" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="GO FORTH now and create masterpieces of the publishing art!">
<meta property="og:type" content="website">
<meta property="og:title" content="80x24">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="80x24">
<meta property="og:description" content="GO FORTH now and create masterpieces of the publishing art!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="80x24">
<meta name="twitter:description" content="GO FORTH now and create masterpieces of the publishing art!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title> 80x24 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?763bee904aa6d81fdf017659d162188f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">80x24</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Keep Stupid, Keep Hungry</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/atom.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/14/hello-world/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/14/hello-world/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-14T16:36:23+08:00">
                2016-12-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:23+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/12/14/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/14/hello-world/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/14/hello-world2/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/12/14/hello-world2/" itemprop="url">
                  Hello World
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-12-14T16:36:23+08:00">
                2016-12-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:23+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/12/14/hello-world2/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/12/14/hello-world2/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<p><span class="citation">(Duan 2012)</span> 使用Pandoc’s Markdown</p>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
<div id="refs" class="references">
<div id="ref-Duan2012A">
<p>Duan, Yucong. 2012. “A Survey on Service Contract.” In <em>Acis International Conference on Software Engineering, Artificial Intelligence, Networking and Parallel/Distributed Computing</em>, 805–10.</p>
</div>
</div>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/06/03/160603-Solr/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/03/160603-Solr/" itemprop="url">
                  Solr搜索介绍（继续）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-03T00:00:00+08:00">
                2016-06-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:22+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/06/03/160603-Solr/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/03/160603-Solr/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="solr继续">Solr继续</h2>
<p>Solr 5.0之后就不再以<code>.war</code>包的格式发布了。而是以一个单独的linux进程发布（daemon）。在其目录下面可以找到<code>init.d</code>目录中的solr，通过该脚本可以启动<code>/opt/solr</code>目录下面的solr工具。但是之后的Solr可能还能够部署到容器当中，但是不是官方所支持的了。</p>
<p>是这样配置的，首先将Solr的tgz后下载之后解压到一个文件夹当中。然后将<code>bin/init.d</code>中的<code>solr</code>文件复制到<code>/etc/init.d</code>目录之下，并需要修改里面的脚本文件。特别是其中的<code>SOLR_INSTALL_DIR</code>变量。然后将<code>solr.in.sh</code>脚本复制到<code>/etc/default</code>目录之下。注意设置<code>RUNAS=&quot;root&quot;</code>变量的值，以及<code>SOLR_ENV</code>的值。设置好之后应该就可以通过<code>service solr start</code>启动服务了。这个时候可以通过<code>netstat</code>命令看到7983端口与8983端口已经被监听了。然后打开<code>localhost:8983</code>也可以进入Solr的管理界面。</p>
<p>快速开始教程参考<a href="http://lucene.apache.org/solr/quickstart.html" class="uri" target="_blank" rel="external">http://lucene.apache.org/solr/quickstart.html</a>。Lucene/Solr的架构见<a href="http://www.solr.cc/blog/?p=167" class="uri" target="_blank" rel="external">http://www.solr.cc/blog/?p=167</a>。</p>
<p>要使用快速开始，就不能够使用linux daemon的方式直接启动Solr，必须能够加载example里面的collection名称（core名称）。启动的时候，命令改成<code>bin/solr start -e cloud -noprompt</code>，其中的<code>-e</code>选项后面跟例子名称，比如<code>cloud</code>。在这种方式之下启动，我们可以看到管理台界面的各个collection了。然后就可以使用post工具提交待索引的文档（XML、JSON等格式了）。<a href="http://blog.csdn.net/near1024/article/details/44105935" class="uri" target="_blank" rel="external">http://blog.csdn.net/near1024/article/details/44105935</a>上面列出了PDF、CSV、XML、JSON、PPT等格式。</p>
<p>之后我们登录控制台，在控制台当中找到getting started的collection，在collection里面选择query，查询一个词，比如<code>2006</code>，在右边就可以返回结果了。<a href="https://lucene.apache.org/solr/quickstart.html" class="uri" target="_blank" rel="external">https://lucene.apache.org/solr/quickstart.html</a>上面的教程我们可以完全参考，以尝试如何进行POST，QUERY等操作。里面还介绍了如何通过HTTP来进行查询与得到查询结果。还可以找到Solr的各种高级搜索的表达式。详细参考<a href="https://cwiki.apache.org/confluence/display/solr/Apache+Solr+Reference+Guide" target="_blank" rel="external">Solr Reference Guide</a>。Solr的集群，则应该参考Admin Guide。</p>
<h2 id="solr的slorconfig.xml">Solr的slorconfig.xml</h2>
<p><code>solrconfig.xml</code>文件用于控制许多影响Solr的行为的参数。配置Solr的时候，许多时候是在同<code>solrconfig.xml</code>文件打交道。或者我们可以通过<code>Config API</code>来间接地修改<code>solrconfig.xml</code>中的值。</p>
<p><code>solrconfig.xml</code>的功能包括但不限于：</p>
<ul>
<li>request handlers，处理API与响应</li>
<li>listeners，监听特定的查询事件，用于触发特定代码的执行</li>
<li>Request Dispatcher，管理HTTP通信</li>
<li>Admin Web Interface</li>
<li>关于复制与副本的问题（详见<code>Legacy Scaling and Distribution</code>）</li>
</ul>
<p><code>solrconfig.xml</code>文件位于每个collection（收藏）的<code>conf/</code>目录之下。典型的例子是<code>server/solr/configsets</code>目录中的配置，它适合于很多的场合。</p>
<p>Solr的官方文档对于solrconfig.xml的介绍见<a href="https://cwiki.apache.org/confluence/display/solr/Configuring+solrconfig.xml" class="uri" target="_blank" rel="external">https://cwiki.apache.org/confluence/display/solr/Configuring+solrconfig.xml</a>。</p>
<p>Solr中的core（核心）指的是一个单独的索引，以及相关的事务日志与配置文件（<code>solrconfig.xml</code>与Schema文件等）构成的整体。一个Solr在工作的时候可以与多个核心相关联。</p>
<p>通过<code>bin/solr</code>脚本可或者一些API可以创建核心。与核心相关的属性，包括索引文件的存储目录、配置文件、核心的名称等，可以在<code>core.properties</code>文件中得到定义。任何<code>core.properties</code>可以在机器当中的任何位置，因为Solr将会在<code>solr_home</code>下面查找相关的文件。在Solr的单机模式（standalone）下，<code>solr.xml</code>文件必须放在<code>solr_home</code>目录之下，在SolrCloud模式下，<code>solr.xml</code>可以从ZooKeeper当中加载。ZooKeeper当中找不到的时候返回<code>solr_home</code>当中。在旧版本的Solr当中，<code>cores</code>必须被定义在<code>solr.xml</code>文件中的<code>&lt;cores&gt;</code>里面，但是现在Solr支持从<code>solr.xml</code>配置文档中自动发现cores。这样可以动态地创建cores与collections。</p>
<p>我们可以参考<code>server/solr/solr.xml</code>文件。</p>
<p>在建立Solr的集群的时候，不同的机器上的核心具有不同的名称，比如所谓的<code>replica1</code>、<code>replica2</code>、<code>replica3</code>核心。有多个核心可以共同组成一个集群。由于访问Solr的时候必须显式指定core的名称，所以，三台机器配置相同域名的时候，不能使用Nginx做负载均衡。这个时候，要通过Solrj提供的SolrCloudClient，通过ZooKeeper地址进行访问。</p>
<p>Solr连接的时候存在许多的问题，比如SolrClient首次连接ZooKeeper的时候会出现超时。另外Solr原生对中文的支持较差，只能单个分词，因此我们可能需要使用其它的分词器比如ICUTokenizer替代Solr默认的Tokenizer。另外，如果Solr的日志量太大的话，可以使用CONSOLE设置日志级别为WARN，或者控制单个日志文件的大小。</p>
<p>Solr的集群恢复，最坏的情况下需要二倍于当前core的存储空间。此外，默认可能Solr在多核的情况下只能使用一个CPU。此外，我们还可以看到GC吞吐量过低（只有85%这样的级别），这个时候可以设置HEAP大小，使之达到98%这样的级别。还有Out of Memory等问题，见<a href="http://www.cnblogs.com/davidwang456/p/5241429.html" class="uri" target="_blank" rel="external">http://www.cnblogs.com/davidwang456/p/5241429.html</a>。详细内容，要学习<a href="http://iamyida.iteye.com/category/338597" class="uri" target="_blank" rel="external">http://iamyida.iteye.com/category/338597</a>。后者也介绍了Jetty、Tomcat等容器的配置。</p>
<!-- 从上面的结果来看，自己好像明白了为什么学习某些问题的时候需要很长的时间。因为要一步一步来做的话，配置Solr就需要有几十篇博客的内容，结果也就是一份书的程度了，这样单一个Solr就要搞定几个星期，这还是比较快的人，如果中间遇到什么意外，可能就需要更长的时间。这个时候自己算是明白为什么效率可以那么低了。 -->
<p><a href="http://iamyida.iteye.com/category/338597" class="uri" target="_blank" rel="external">http://iamyida.iteye.com/category/338597</a>里面介绍，创建collection的方式是这样的，先决条件是我们在<code>server/solr</code>目录下面有一个<code>solr.xml</code>文件，以后我们就把<code>server/solr</code>目录简称为<code>solr</code>目录了。之后我们创建一个<code>collection1</code>这样的文件夹，进一步在文件夹里面创建一个<code>conf</code>文件夹。进一步地，将<code>server/solr/configsets/basic_configs/conf/solrconfig.xml</code>文件复制到<code>server/solr/collection1/conf</code>目录下面。</p>
<p>然后在Solr的管理控制台中选择添加core，里面指定名称，solr的路径，dataDir、config、schema.xml等文件。自己遇到的一个问题是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Error CREATEing SolrCore &apos;collection1&apos;: Unable to create core [collection1] Caused by: Unknown parameters: &#123;enablePositionIncrements=true&#125;</div></pre></td></tr></table></figure>
<p>浏览器的方式创建core，形如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://localhost:8080/solr/admin/cores?action=CREATE&amp;name=core2&amp;instanceDir=/opt/solr/core2&amp;config=solrconfig.xml&amp;schema=schema.xml&amp;dataDir=data</div></pre></td></tr></table></figure>
<ul>
<li>name：就是你的core名称，</li>
<li>instanceDir就是你的core根目录，举个例子，linux下可能是/opt/solr/core2,windows下可能是C:/solr/core2</li>
<li>config,schema即core的两个重要的配置文件的名称，只要你core目录结构按规范创建好了，就会按照你指定的配置文件名称去conf目录下去找，dataDir表示你的core的数据目录，该用户主要用来存放你当前core的索引数据。创建好之后就可以post了。</li>
</ul>
<p>一种不用自己配的方法是利用examples里面的collection1，将其内容复制到solr的目录里面，但是这种方法其实也不好。</p>
<p>注意Java当中很多地方显示的是错误的信息，比如表面上是因为解析不了<code>enablePositionIncrements</code>属性的问题，但是事实上，我们要看ThreadDump里面的详细的错误信息才行（Java的错误的可读性，感觉非常差，Bug也非常多）。</p>
<p>最后，自己决定查看solr的reference manual。<a href="http://mirrors.cnnic.cn/apache/lucene/solr/ref-guide/apache-solr-ref-guide-6.0.pdf" class="uri" target="_blank" rel="external">http://mirrors.cnnic.cn/apache/lucene/solr/ref-guide/apache-solr-ref-guide-6.0.pdf</a>。</p>
<p>为了方便用户往solr中添加索引，Solr为用户提供了一个post.jar工具，用户只需要在命令行下运行post.jar并传入一些参数就可以完成索引的增删改操作，对，它仅仅是一个供用户进行Solr测试的工具而已。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/06/01/160601-Nutch/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/06/01/160601-Nutch/" itemprop="url">
                  Apache Nutch的介绍与基本使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-06-01T00:00:00+08:00">
                2016-06-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:22+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/06/01/160601-Nutch/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/06/01/160601-Nutch/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Nutch本是一个单独的程序，通过程序可以进行全文的挖掘并定制有关的服务。挖掘出来之后还可以使用Solr进行索引。这样就产生了各个页面。但是另外一方面，Java的程序包又都可以通过包的形式调用，因此在Scala当中也可以使用。但是要在Scala当中使用的话，显然是需要读Nutch的API文档及其用法的。</p>
<h2 id="关于nutch">关于Nutch</h2>
<p>2015年1月，Apache Nutch v2.3已经发布了，建议所有使用2.X系列的用户和开发人员升级到这个版本。这个版本提供了一个基于Apache Wicket的Web管理界面，解决了143个问题，提供了Maven依赖，升级到Gora v0.5，支持的底层存储为：</p>
<ol>
<li>Apache Hadoop 1.0.1 &amp; 2.4.0</li>
<li>Apache Cassandra 2.0.2</li>
<li>Apache HBase 0.94.14</li>
<li>Apache Accumulo 1.5.1</li>
<li>MongoDB 2.12.2</li>
<li>Apache Solr 4.8.1</li>
<li>Apache Avro 1.7.6</li>
</ol>
<p>同时请注意，Gora对SQL的支持已经过时了。</p>
<p>Nutch的创始人是Doug Cutting，他同时也是Lucene、Hadoop和Avro开源项目的创始人。</p>
<p>Nutch诞生于2002年8月，是Apache旗下的一个用Java实现的开源搜索引擎项目，自Nutch1.2版本之后，Nutch已经从搜索引擎演化为网络爬虫，接着Nutch进一步演化为两大分支版本：1.X和2.X，这两大分支最大的区别在于2.X对底层的数据存储进行了抽象以支持各种底层存储技术。</p>
<p>在Nutch的进化过程中，产生了Hadoop、Tika、Gora和Crawler Commons四个Java开源项目。如今这四个项目都发展迅速，极其火爆，尤其是Hadoop，其已成为大规模数据处理的事实上的标准。Tika使用多种现有的开源内容解析项目来实现从多种格式的文件中提取元数据和结构化文本，Gora支持把大数据持久化到多种存储实现，Crawler Commons是一个通用的网络爬虫组件。</p>
<p>大数据这个术语最早的引用可追溯到Nutch。当时，大数据用来描述为更新网络搜索索引需要同时进行批量处理或分析的大量数据集。现在，大数据的含义已经被极大地发展了，业界将大数据的特性归纳为4个“V”。Volume数据体量巨大，Variety数据类型繁多，Value价值密度低，商业价值高，Velocity处理速度快。</p>
<p>Hadoop是大数据的核心技术之一，而Nutch集Hadoop之大成，是Hadoop的源头。学习Hadoop，没有数据怎么办？用Nutch抓！学了Hadoop的Map Reduce以及HDFS，没有实用案例怎么办？学习Nutch！Nutch的很多代码是用Map Reduce和HDFS写的，哪里还能找到比Nutch更好的Hadoop应用案例呢？</p>
<h2 id="building-a-search-engine-with-nutch-and-solr-in-10-minutes-编译">Building A Search Engine With Nutch And Solr In 10 Minutes (编译)</h2>
<p>首先下载Solr并安装，然后使用java -jar的方式运行起来Solr，得到Solr的管理台界面（为<a href="https://localhost:8983/solr/admin" class="uri" target="_blank" rel="external">https://localhost:8983/solr/admin</a>）。<a href="http://www.lucidimagination.com/Downloads/Lucidworks-for-Solr/Installer" class="uri" target="_blank" rel="external">http://www.lucidimagination.com/Downloads/Lucidworks-for-Solr/Installer</a>。</p>
<p>然后下载Nutch并安装，设置好<code>JAVA_HOME</code>与<code>NUTCH_JAVA_HOME</code>。<a href="http://zillionics.com/resources/articles/NutchGuideForDummies.htm" class="uri" target="_blank" rel="external">http://zillionics.com/resources/articles/NutchGuideForDummies.htm</a>。</p>
<p>之后找到一个nutch-site.xml文件，配置如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>http.agent.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>nutch-solr-integration<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>generate.max.per.host<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>plugin.includes<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">value</span>&gt;</span>protocol-http|urlfilter-regex|parse-html|index-(basic|anchor)|query-(basic|site|url)|response-(json|xml)|summary-basic|scoring-opic|urlnormalizer-(pass|regex|basic)<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></div></pre></td></tr></table></figure>
<p>配置好之后运行nutch。除此之外，还要包括有URL的seed.txt文件。弄好之后启动，就开始进入到Nutch的挖掘的模式了。最后我们需要将数据推送到Solr，这需要在启动Nutch的时候进行Solr的地址的配置。</p>
<p>HBase的JUJU配置脚本可见<a href="https://10.0.8.119/services/?store=~bigdata-dev/trusty/apache-hbase" class="uri" target="_blank" rel="external">https://10.0.8.119/services/?store=~bigdata-dev/trusty/apache-hbase</a>。</p>
<p>注意在安装Nutch之前要安装无论是单机模式还是集群模式的HBase，而HBase的集群模式又需要单独配ZooKeeper等软件组件。这是比较大的工作了。之后自己可能需要调整一下，或者制作几个镜像文件。</p>
<p>nutch 2.3是其src镜像文件，但是事先不需要我们编译。解压之后，首先配置<code>conf/nutch-site.xml</code>文档。修改为</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>storage.data.store.class<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>org.apache.gora.hbase.store.HBaseStore<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span>Default class for storing data<span class="tag">&lt;/<span class="name">description</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后修改<code>ivy/ivy.xml</code>文档：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">dependency</span> <span class="attr">org</span>=<span class="string">"org.apache.gora"</span> <span class="attr">name</span>=<span class="string">"gora-hbase"</span> <span class="attr">rev</span>=<span class="string">"0.3"</span> <span class="attr">conf</span>=<span class="string">"*-&gt;default"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>之后再修改<code>conf/gora.properties</code>文档，确保HBaseStore是默认的存储</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gora.datastore.default=org.apache.gora.hbase.store.HBaseStore</div></pre></td></tr></table></figure>
<p>之后使用ant编译即可。官方配置教程见<a href="http://wiki.apache.org/nutch/Nutch2Tutorial" class="uri" target="_blank" rel="external">http://wiki.apache.org/nutch/Nutch2Tutorial</a>.</p>
<p>实际上nutch的存储后端未必是需要HBase，但是Apache Nutch2的官方教程中默认就是使用HBase而不是MongoDB的，因此我们还是不得不配置HBase。而且使用HBase作为存储后端的话，必须在Nutch运行之前先启动HBase。注意几个组件Nutch、Solr、Gora、HBase之间的关系。运行中如果出现HBase找不到，应该参考<a href="http://stackoverflow.com/questions/16401667/java-lang-classnotfoundexception-org-apache-gora-hbase-store-hbasestore" class="uri" target="_blank" rel="external">http://stackoverflow.com/questions/16401667/java-lang-classnotfoundexception-org-apache-gora-hbase-store-hbasestore</a>。在<code>ivy/ivy.xml</code>中添加<code>gora-hbase</code>的依赖。</p>
<p><a href="https://gist.github.com/xrstf/b48a970098a8e76943b9" class="uri" target="_blank" rel="external">https://gist.github.com/xrstf/b48a970098a8e76943b9</a>上面介绍了一种ElasticSearch + Nutch + HBase的解决方案。</p>
<!-- 正常工作意味着下面的步骤中的inject等命令都能正常工作。在`hbase shell`中输入`scan 'webpage'`这个命令，可以找到nutch所查询到的网页。这样就OK了。之后就是配置Solr了。 -->
<h2 id="nutch的基本使用short-user-guide">Nutch的基本使用（Short User Guide）</h2>
<p>前面的<code>ant runtime</code>重新编译好之后，在<code>bin</code>目录下就可以找到nutch命令了。</p>
<p>接下来我们首先新建一个seed.txt文件。比如在<code>urls/seed.txt</code>中存储文件的内容。<code>seed.txt</code>中存放初始URL，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">http://nutch.apache.org/</div></pre></td></tr></table></figure>
<p>之后在<code>conf/regex-urlfilter.txt</code>文件中输入如下的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">+^http://([a-z0-9]*\.)*nutch.apache.org/</div></pre></td></tr></table></figure>
<p>之后就可以使用nutch命令进行挖掘了。注意一个nutch往往代表一个爬虫而已，nutch带有它的庞大的运行时。在<code>conf/nutch-site.xml</code>文件中还可以设置此次爬虫的名子</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>http.agent.name<span class="tag">&lt;/<span class="name">name</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">value</span>&gt;</span>My Nutch Spider<span class="tag">&lt;/<span class="name">value</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></div></pre></td></tr></table></figure>
<p>接下来我们就考虑Solr与Nutch的集成吧。基于Solr实现站内搜索。封装及扩展性较好，提供了较为完备的解决方案，因此在门户社区中采用此方案，后期加入Compass方案。</p>
<p>由于搜索引擎功能在门户社区中对提高用户体验有着重在门户社区中涉及大量需要搜索引擎的功能需求，目前在实现搜索引擎的方案上有集中方案可供选择：</p>
<ol style="list-style-type: decimal">
<li>基于Lucene自己进行封装实现站内搜索。工作量及扩展性都较大，不采用。</li>
<li>调用Google、Baidu的API实现站内搜索。同第三方搜索引擎绑定太死，无法满足后期业务扩展需要，暂时不采用。</li>
</ol>
<p>Solr是一个基于Lucene的Java搜索引擎服务器。Solr 提供了层面搜索、命中醒目显示并且支持多种输出格式（包括 XML/XSLT 和 JSON 格式）。它易于安装和配置，而且附带了一个基于 HTTP 的管理界面。Solr已经在众多大型的网站中使用，较为成熟和稳定。Solr 包装并扩展了 Lucene，所以Solr的基本上沿用了Lucene的相关术语。更重要的是，Solr 创建的索引与 Lucene 搜索引擎库完全兼容。通过对Solr 进行适当的配置，某些情况下可能需要进行编码，Solr 可以阅读和使用构建到其他 Lucene 应用程序中的索引。此外，很多 Lucene 工具（如Nutch、 Luke）也可以使用Solr 创建的索引。注意solr是可以以.war的形式注入到tomcat的服务器中接受后者的托管的。（不知道现在还行不行）。</p>
<p>ElasticSearch是与Solr可以相类比的功能，Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能。具体特点见<a href="http://www.cnblogs.com/chowmin/articles/4629220.html" class="uri" target="_blank" rel="external">http://www.cnblogs.com/chowmin/articles/4629220.html</a>。基于Lucene的还有许多产品，包括直接Lucene、Katta、Hadoop contrib/index、Lucanda、HBasene。</p>
<p>Nutch与Solr的集成的教程可见<a href="http://blog.csdn.net/lzjzy520/article/details/41597089" class="uri" target="_blank" rel="external">http://blog.csdn.net/lzjzy520/article/details/41597089</a>。主要在于将Nutch的<code>conf/schema.xml</code>文件拷贝到Solr的<code>server/solr/collection1/conf</code>目录下面，名子保证是<code>schema.xml</code>。然后在其中的<code>field</code>结点里面添加一行</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">field</span> <span class="attr">name</span>=<span class="string">"_version_"</span> <span class="attr">type</span>=<span class="string">"long"</span> <span class="attr">indexed</span>=<span class="string">"true"</span> <span class="attr">stored</span>=<span class="string">"true"</span> <span class="attr">multiValued</span>=<span class="string">"false"</span>/&gt;</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./bin/crawl ~/urls/ TestCrawl http://localhost:8983/solr/ 2</div></pre></td></tr></table></figure>
<pre><code>～/urls 是存放了种子url的目录
TestCrawl 是crawlId，这会在HBase中创建一张以crawlId为前缀的表，例如TestCrawl_Webpage。
http://localhost:8983/solr/ , 这是Solr服务器
2，numberOfRounds，迭代的次数</code></pre>
<p>过了一会儿，屏幕上出现了一大堆url，可以看到爬虫正在抓取！</p>
<p>刚开始的时候可以不指定solr，而是<code>bin/nutch crawl ./urls testcrawlid 2</code>这样的形式。</p>
<p>注：The Nutch-Selenium plugin on Github was made for the Nutch 2.x branch;</p>
<p>注：AFAIK Solr 5.x uses managed-schema in default which will be created on the fly based on the input documents. However you can copy your schema.xml file content to the</p>
<p>注：<a href="http://blog.csdn.net/lzx1104/article/details/42029981" class="uri" target="_blank" rel="external">http://blog.csdn.net/lzx1104/article/details/42029981</a>介绍了Solr 4.9以上的managed-solr的功能。如果使用了ManagedIndexSchemaFactory，Solr会从“managedSchemaResourceName”指定的文件名中加载schema，而不是从schema.xml;如果指定的文件（managed-schema）不存在，将会从schema.xml中加载并创建文件，并将schema.xml重命名为<code>schema.xml.bak</code>. 不要编辑managed schema – 外部的修改会被忽略，并被修改schema 的RestAPI调用所覆盖。</p>
<p><code>mutable = true</code>修改schema 的RestAPI调用被允许，否则会报错。</p>
<p>注：nutch的crawl命令是一个完整的从索引到爬取的过程命令。比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">crawl ./urls/ testcrawl http://10.0.8.68:8983/solr/collection1/ 1</div></pre></td></tr></table></figure>
<h3 id="nutch-1.x-命令介绍httpwww.cnblogs.comxia520pip3663506.html">Nutch 1.x 命令介绍：<a href="http://www.cnblogs.com/xia520pi/p/3663506.html" class="uri" target="_blank" rel="external">http://www.cnblogs.com/xia520pi/p/3663506.html</a></h3>
<ul>
<li>nutch的readdb命令是“org.apache.nutch.crawl.CrawlDbReader”的别称，返回或者导出Crawl数据库（crawldb）中的信息。</li>
<li>readlinkdb是“org.apache.nutch.crawl.LinkDbReader”的别称，导出链接库中信息或者返回其中一个URL信息。</li>
<li>inject是“org.apache.nutch.crawl.Injector”的别称，注入新URL到crawldb中。</li>
<li>generate是“org.apache.nutch.crawl.Generator”，从Crawldb中抓取新的Segment。</li>
<li>fetch是“org.apache.nutch.fetcher.Fetcher”的代称，它负责一个segment的爬取。</li>
<li>parse是“org.apache.nutch.parse.ParseSegment”的代称，它对一个segment运行ParseSegment。</li>
<li>readseg是“org.apache.nutch.segment.SegmentReader”的代称，它读取并导出Segment数据。</li>
<li>updatedb是“org.apache.nutch.crawl.CrawlDb”的代称，用fetch过程中获取的信息更新crawldb。</li>
<li>invertlinks是“org.apache.nutch.crawl.LinkDb”的代称，它用从segment中获取到的信息更新linkdb。</li>
<li>index是“org.apache.nutch.indexer.Indexer”的代称，创建一个segment的索引，利用crawldb和linkdb中的数据对索引中的页面打分。</li>
<li>merge是“org.apache.nutch.indexer.IndexMerger”的代称，它合并多个segment索引。</li>
<li>mergedb是“org.apache.nutch.crawl.CrawlDbMerger”的代称，合并多个CrawlDb，URLFilter可选择性地过滤指定内容。</li>
</ul>
<p>可以合并多个DB到一个中。当你分别运行爬虫并希望最终合并DB时，它会相当有用。可选择地，可以运行当前URLFilter过滤数据库中的URL，以滤去不需要的URL。当只有一个DB时也很有用，它意味着你可以通过这个工作去滤掉那些DB中你不想要的URL。</p>
<ul>
<li>mergelinkdb是“org.apache.nutch.crawl.LinkDbMerger”的代称，用于合并多个linkdb，可以选择性的使用URLFilter来过滤指定内容。</li>
<li>mergesegs是“org.apache.nutch.segment.SegmentMerger”的代称，用于合并多个segment，可以选择性地输出到一个或者多个固定大小的segment中。</li>
<li>dedup是“org.apache.nutch.indexer.DeleteDuplicates”的别名，它segment indexes中去掉重复的页面。</li>
<li>plugin是“org.apache.nutch.plugin.PluginRepository”的代称，用于从插件库中加载一个插件并执行其主方法。</li>
<li>solrindex是“org.apache.nutch.indexer.solr.SolrIndexer”的代称，用于对抓取的内容进行索引建立，前提是要有solr环境。</li>
</ul>
<p>注意我们使用的crawl命令中的testcrawl就是crawlId，该ID可以用于readdb等命令中，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nutch readdb -crawlId testcrawl -stats</div><div class="line">### 如果我们后端使用的HBase，那么就可以从HBase中读到相应crawlId的数据库了。</div></pre></td></tr></table></figure>
<p>解决<code>No IndexWriters activated - check your configuration</code>的问题：见<a href="http://stackoverflow.com/questions/17649567/nutch-message-no-indexwriters-activated-while-loading-to-solr/25945844#25945844" class="uri" target="_blank" rel="external">http://stackoverflow.com/questions/17649567/nutch-message-no-indexwriters-activated-while-loading-to-solr/25945844#25945844</a>。</p>
<p>nutch solrindex -crawlid doubanmovie</p>
<h3 id="nutch-2.x的命令接口">Nutch 2.x的命令接口</h3>
<p>Nutch1与Nutch2的接口发生了很大的变化，许多教程解释都已经不能再用了。参考<a href="http://wiki.apache.org/nutch/bin/nutch%20solrindex" target="_blank" rel="external">http://wiki.apache.org/nutch/bin/nutch%20solrindex</a>，来获得详细一点的针对Nutch2的命令的介绍。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></td><td class="code"><pre><div class="line">### 我们从DMOZ开放式分类目录添加URL。</div><div class="line">### 首先我们必须下载并且解压缩这个DMOZ所有网页的列表</div><div class="line">### 这是一个200多MB的文件，所以这会消耗几分钟</div><div class="line">wget http://rdf.dmoz.org/rdf/content.rdf.u8.gz</div><div class="line">gunzip content.rdf.u8.gz </div><div class="line"></div><div class="line">### 接下来我们选择这些网页当中随机的一些子集</div><div class="line">### 我们使用随机的子集所以所有在跟着这一个教程做的人就不会伤害到同样的网站</div><div class="line">### DMOZ包含了大约三百万个URL。我们从每5000个URL中选择出一个，因此我们就有大约1000个URL</div><div class="line">### 这里我们从50000个URL中选择出一个，因此总共选择大约100个，可以节省很多时间</div><div class="line">nutch org.apache.nutch.tools.DmozParser content.rdf.u8 -subset 5000 &gt; dmoz/seed.txt</div><div class="line"></div><div class="line">###  最后，我们用这些选出的URL来初始化crawlId（在Nutch 2中改成了crawlId而不是db文件，</div><div class="line">### crawlId存在相应的hbase库当中</div><div class="line">nutch inject ./dmoz/ -crawlId dmozcrawl </div><div class="line"></div><div class="line">###  要获取，我们首先要从数据库里产生一个获取的列表，</div><div class="line">### 生成的任务中，-topN表示选择的URL数</div><div class="line">### -batchId表示我们所生成的这些初始网页的任务名，接下来在fetch等操作的时候可以指定任务名</div><div class="line">### topN是每一级所获取的网页数，限制topN可以减少抓取的数目</div><div class="line">nutch generate -crawlId dmozcrawl -topN 100</div><div class="line"></div><div class="line">### 在以下面的命令在这个分段里进行获取</div><div class="line">### 可以改成前面-batchId指定的参数，以代替fetch</div><div class="line">nutch fetch -all -crawlId dmozcrawl -threads 2</div><div class="line"></div><div class="line">### 获取之后parse有关条目</div><div class="line">nutch parse -all -crawlId dmozcrawl</div><div class="line"></div><div class="line">###  当这一切完成以后，我们就以获取回来的结果更新数据库</div><div class="line">nutch updatedb -all -crawlId dmozcrawl</div><div class="line"></div><div class="line">### 进行索引，在新的nutch里面，已经没有invertindex了，只有index了</div><div class="line">nutch index -all -crawlId dmozcrawl</div><div class="line">nutch solrindex http://10.0.8.68:8983/solr/test/ -all -crawlId dmozcrawl</div><div class="line">nutch solrindex http://10.0.8.68:8983/solr/collection1/ sec200 -crawlId dmozcrawl</div><div class="line"></div><div class="line">### 爬完之后，在nutch里面可以进行查询诊断，其中的faq是关键词</div><div class="line">### 该脚本尝试过，不能正常工作</div><div class="line">nutch org.apache.nutch.searcher.NutchBean faq</div><div class="line"></div><div class="line">### 提交之后，我们将可以在solr控制台中看到有关文档的数目。</div><div class="line">### 任何时候都能运行的测试命令</div><div class="line">nutch parse http://www.precastdesign.com/</div><div class="line">nutch indexchecker http://www.precastdesign.com/</div></pre></td></tr></table></figure>
<h2 id="nutch加mongodb加elasticsearch的配置">Nutch加MongoDB加ElasticSearch的配置</h2>
<p>见<a href="http://www.jeepshoe.org/82645084.htm" class="uri" target="_blank" rel="external">http://www.jeepshoe.org/82645084.htm</a>。</p>
<p>一：nutch2.x与nutch1.x的主要区别：数据访问层的抽象 nutch 2.x—-gora-core-0.3—-gora-hbase—-hbase</p>
<p>gora-core-0.3 apache-gora提供了对nosql访问的统一接口。（注解：在上述链接里可以看到对其他数据库的支持） gora-hbase 针对hbase实现了gora的接口</p>
<p>有了这两步nutch2.x就可以运行在Hbase上了。 支持nosql的优势： 当获取了外链要进行url排重的时候，以前基于hdfs的时候是读取之前全部的url用mapreduce实现排重（好沉重的赶脚），支持了nosql只需要一步查找即可。</p>
<p>这里Hadoop与HBase的集成主要是将HBase安装到Hadoop当中，然后HBase的rootdir配置成hdfs的方式（即HBase的数据进一步存储在HDFS文件系统当中）。这里在设置hbase-env.sh与hbase-site.xml的时候进行配置的。另外，注意HBase也完全可以与Hadoop割离开，从而仅仅是使用Hadoop的后端而已。当然，HBase还要进一步与ZooKeeper集成。</p>
<p>在配置的时候特别注意Hadoop的版本与HBase的版本的一致性。</p>
<h3 id="solr的一个错误的处理">Solr的一个错误的处理</h3>
<p>在使用nutch的时候，提交的的时候出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Expected content type application/octet-stream but got text/html;charset=iso-8859-1</div></pre></td></tr></table></figure>
<p><a href="http://stackoverflow.com/questions/24089769/solr-realtime-get-remotesolrexception-expected-mime-type-application-xml-but-go" class="uri" target="_blank" rel="external">http://stackoverflow.com/questions/24089769/solr-realtime-get-remotesolrexception-expected-mime-type-application-xml-but-go</a>上面给出来了一个回答。</p>
<p>在使用Tomcat部署Solr后，Collection1的地址为：<a href="http://182.92.160.44:8080/solr/#/collection1" class="uri" target="_blank" rel="external">http://182.92.160.44:8080/solr/#/collection1</a>，但使用SolrJ进行索引的时候，应该使用<a href="http://182.92.160.44:8080/solr/collection1" class="uri" target="_blank" rel="external">http://182.92.160.44:8080/solr/collection1</a>，即无中间的#号。</p>
<p>一个crawl命令可能封装了太多的过程。接下来我们以dmoz为例，一个命令一个命令地执行，看看是什么样的结果。</p>
<p>首先使用solr命令的<code>solr create -c test</code>来创建一个默认的collection。然后进入nutch的环节。依次执行如下的命令：</p>
<h2 id="scala下面使用nutch">Scala下面使用Nutch</h2>
<p><a href="https://blog.knoldus.com/2012/03/14/intercepting-nutch-crawl-flow-with-a-scala-plugin/" class="uri" target="_blank" rel="external">https://blog.knoldus.com/2012/03/14/intercepting-nutch-crawl-flow-with-a-scala-plugin/</a>。</p>
<p>Nutch 2.0的REST接口，见<a href="https://wiki.apache.org/nutch/NutchRESTAPI" class="uri" target="_blank" rel="external">https://wiki.apache.org/nutch/NutchRESTAPI</a>。Nutch教程，比较华丽的版本<a href="http://www.cnblogs.com/xia520pi/p/3615554.html" class="uri" target="_blank" rel="external">http://www.cnblogs.com/xia520pi/p/3615554.html</a>.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/13/160313-Modelica建模-ModelicaML/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/13/160313-Modelica建模-ModelicaML/" itemprop="url">
                  快速了解Modelica与OpenModelica建模2-ModelicaML与方程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-13T00:00:00+08:00">
                2016-03-13
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:21+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/03/13/160313-Modelica建模-ModelicaML/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/13/160313-Modelica建模-ModelicaML/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="modelicaml">ModelicaML</h2>
<p>ModelicaML同样地用于系统建模。不过不是语言的方式，而是首先以UML类似的模型表示出相应关系，然后这种模型被转换成Modelica的代码。转换代码后就可以执行，模拟出结果。ModelicaML是UML Profile的一个具体的扩展。</p>
<p>ModelicaML的一个开发的方法是在Papyrus UML环境下进行。在此环境之下，通过Acceleo工具生成Modelica的代码，经过M2T工具生成Modelica的.mo文件，之后可以通过任何一个符合Modelica语言要求的模拟工具中运行出来结果。安装Modelica Development Tool的Eclipse插件之后，新建Papyrus工程，在模型语言（Diagram Language）提供的UML、SysML、ModelicaML、Profile中选择ModelicaML，这样就进入了ModelicaML的建模的环境了。之后我们就可以使用ModelicaML来完成建模了（UML本身可以用于元建模，这个时候，UML规范本身就是元元建模工具了）。</p>
<p>Modelica使用类UML的图形表示模型。有结构图、需求图、行为图等描述方法。注意到Modelica本身也是一种元模型规范。Modelica中的元素被看成是prototype，所有的类都是继承自该原型。ModelicaML充分利用了Modelica语言的特性，可以在状态图中使用Modelica的谓词语言与条件判断，同时，也增强了UML建模算法的能力（算法流程以及代数方程）。</p>
<p>另外，运行Modelica Script是使用runScript命令。Script可能不是Modelica语言规范的一部分，因为像System Modeler之类的工具的脚本是基于Wolfram语言的（比如典型的用中括号而非小括号调用函数）。OpenModelica还具有交互式模拟的能力。在运行的图表中，如果有ModelicaML的需求文档，能够对比需求目标与设计目标的差距（是不是比软件工程中的过设计与欠设计在功能方面的东西更直观？），另外，根据需要，可以建立可视化的模拟过程演示，包括3D力学系统的功能演示。</p>
<p>OpenModelica还提供了OMPython这样一个环境，可以整合Python语言工作区以及Modelica模拟语言。Modelica3D则能够实现3D图形模拟同步的演示，模拟流体、力学系能各种模型的结构化展示，而不仅是模拟出来函数图表。</p>
<p>OPENPROD提出了使用Modelica建模Cyber-Physical模型的一些开发方法，与模型驱动方法以及软件生命周期都有结合。里面还使用了业务流程控制、需求捕获、PIM与PSM的转换等概念。注意ModelicaML也是OMG规范的一种建模的格式。此外还有MetaModelica，需要注意的是，OpenModelica的编译器本身也是通过15万行的MetaModelica代码实现。</p>
<p>loadFile、loadModel之类的函数是所谓的CORBA API函数。</p>
<h2 id="通过modelica来理解多领域建模">通过Modelica来理解多领域建模</h2>
<p>自己之前一直想不清楚控制理论与控制工程是怎样运行的。今天看到一个关于Modelica多领域建模的图表自己一下子就明白了。</p>
<p>这个图表是这样的，首先有一个电源驱动，然后进入电机的控制系统，电机系统最后与机械系统相连（电动力控制运行系统）。机械系统之后有一个所谓的角速传感器，这个传感器可以完成反馈。结果，这个传感器的信号就可以经过PID控制系统反馈到电力系统当中，通过调整输入电压、电流等方式间接地影响力学系统的转速等参数。这样的系统中涉及到电力系统、机械系统与控制系统三个领域，但是共同服务于一个现代电机。大概许多现代的系统都是多领域的吧。</p>
<p>Simulink是典型的使用因果关系建模的软件，系统中所有的信号都具有流向。但是Modelica的典型的方式是使用结构建模，通过方程约束完成建模。Simulink的这种建模思路需要人工做更多的处理。和Simulink一样，Modelica也支持子系统的建模。</p>
<p>Modelica可以看成是强类型的语言。在数组与矩阵运算模仿Matlab的同时，也可以进行非常多的强类型检查活动（似乎强类型以及静态类型成为最近程序语言的热点发展方向之一了）。</p>
<p>Modelica作为面向对象的语言，支持继承的概念，似乎因此我们可以扩展PNlib中的一些类，实现多个参数的建模过程（比如增加PetriNet中变迁的能力。<span class="citation">(Fritzson 2011)</span>是一本不错的介绍Modelica的入门书籍，讲解如何建模的。</p>
<p>英文中有simulation与emulation这两个东西。语义上似乎还有一些不同。在Modelica的领域，建模是与数学建模密切相关的。因为建模包括了物理系统、数学系统、语言的、心理的等几个领域。而数学与物理建模在科学与工程中起着重要的作用。Modelica的建模，通常可以从数学建模中分成静态与动态模型、定性与定量模型、连续与离散模型这一分类开始：比如说，Modelica通常是动态模型，能定性也能宣，能描述连续性也能描述离散性质。（甚至大概Verilog也是此类模拟语言吧，不过Verilog似乎只模拟信号系统，而不模拟物理系统的特性–不妨把不同系统的建模与模拟当成是本辑笔记第二卷与第三卷的内容）。</p>
<p>Modelica的特点可以总结如下：声明式为主，也支持过程式；支持多领域综合，使用面向对象的语言并且保留了矩阵运算的方便性。此外，还可以与ModelicaML，以及可视化组件相结合。Modelica具有一些函数式的风格（至于支持方程，应该是属于等式编程语言那一类）。Modelica内在是并行的，其函数有作用域的（不像Matlab），然后其类型系统受到Abadi/Cardelli的影响（其实面向对象语言大部分地方也是声明性的）。</p>
<p>Modelica语言规范可以从其官网上下载。不过其语言规范不是很有意思，因为Modelica提供了ModelicaML作为其抽象语法的另一种描述形式。后者或许看起来更直观一些（应参考Modelica最近的语言规范3.3版）。</p>
<h2 id="modelica的方程描述能力">Modelica的方程描述能力</h2>
<p>Modelica中的方程典型的形式是代数方程与左边为方程导数，右边为导数值的形式。另外的形式就是一个复杂的加减乘除的四则表达式。不知道是否支持隐式方程与复杂的导数方程（比如高阶导数以及导数的平方？）</p>
<p>下面是几种容许的约束形式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">apollo.gravity = moon.g * moon.mass / ( apollo.altitude + moon.radius ) ^ 2;</div><div class="line">apollo.thrust = if (time &lt; thrustDecreaseTime) then force1 else force2;</div><div class="line">red + blue + green = 1;</div></pre></td></tr></table></figure>
<p>和SysML相比，Modelica虽然在描述模型的精确行为上很强大，但是在描述复杂系统中的继承关系、需求等的进候并不像SysML那样强大。为此就有了所谓的ModelicaML。该图表扩展了SysML的许多内容。比如，在基本Diagram概念增加了Simulation Diagram，在Structure Diagram中做了增强，在行为描述中添加了Equation Diagram。其余的大部分则与SysML保持了相同。</p>
<p>比如说，ModelicaModel也被认为是一种特殊的Class。</p>
<div id="refs" class="references">
<div id="ref-book897383">
<p>Fritzson, Peter A. 2011. <em>Introduction to Modeling and Simulation of Technical and Physical Systems with Modelica</em>. Wiley IEEE. <a href="http://gen.lib.rus.ec/book/index.php?md5=acecd4ecbcf6468f282ca96f5e4759b3" class="uri" target="_blank" rel="external">http://gen.lib.rus.ec/book/index.php?md5=acecd4ecbcf6468f282ca96f5e4759b3</a>.</p>
</div>
</div>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/03/11/160311-Modelica建模基础知识/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/03/11/160311-Modelica建模基础知识/" itemprop="url">
                  快速了解Modelica与OpenModelica建模1-基本知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-03-11T00:00:00+08:00">
                2016-03-11
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:21+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/03/11/160311-Modelica建模基础知识/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/03/11/160311-Modelica建模基础知识/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Modelica里面倒是有不少的面向对象的建模的工具，也支持PetriNet的描述。而且最近也有相关的论文的发表<span class="citation">(Proß et al. 2012)</span>。OpenModelica上面的PNlib工具包倒好像是不错的。</p>
<p>OpenModelica是其一个实现。OpenModelica环境由若干个子系统构顶成。包括文本模型与图形模型编辑器、编译器调试器与执行环境、笔记本、优化器以及Eclipse插件。其中的编译子系统用于将Modelica语言编译成C代码。面向Eclipse的插件被称为MDT。最基本的方式自然是安装之后点击OMShell进入文本编辑环境。里面输入Modelica的代码。OMShell命令会打开一个新的窗格，使用OMShell-terminal命令可以直接在Linux终端中进入OpenModelica的环境。这时进入的就是交互式模式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">model A Integer t= 1.5; end A;</div><div class="line">instantiateModel(A);</div><div class="line">model C</div><div class="line">Integer a;</div><div class="line">Real b;</div><div class="line">equation</div><div class="line">    der(a) = b;</div><div class="line">    der(b) = 12.0;</div><div class="line">end C</div></pre></td></tr></table></figure>
<p>模型是Modelica中的基本元素，许多内容也就围绕着模型的定义来。模型可以用文件来定义，一般使用后缀.mo。使用loadFile命令就可以从文件中加载模型。使用system命令则可以执行操作系统的Shell的代码。</p>
<p>比如下面是使用Modelica写的冒泡排序的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">function bubblesort</div><div class="line">input Real[:] x;</div><div class="line">output Real[size(x,1)] y;</div><div class="line">protected</div><div class="line">Real t;</div><div class="line">algorithm</div><div class="line">    y := x;</div><div class="line">    for i in 1:size(x,1) loop</div><div class="line">        for j in 1:size(x,1) loop</div><div class="line">            if y[i] &gt; y[j] then</div><div class="line">                t := y[i];</div><div class="line">                y[i] := y[j];</div><div class="line">                y[j] := t;</div><div class="line">            end if;</div><div class="line">        end for;</div><div class="line">    end for;</div><div class="line">end bubblesort;</div></pre></td></tr></table></figure>
<p>从上面可以看出Modelica的代码风格做得非常“冗余”。每个循环与条件语句必须显式被结束，每个函数体与模块也必须带显式的结尾处理。函数体中的输入、输出、局部变量与算法体必须各自区分开。</p>
<p>实际上Modelica的输出是通过基于CORBA的客户端实现的。更好的方式是通过readFile实现将文件中的函数等对象加载到当前工作区。在OMShell中，使用cd()函数可以返回当前工作路径，添加字符串参数之后可以切换工作路径。</p>
<p>OpenModelica有一些标准模型，它们使用loadModel()函数加载。比如loadModel(Modelica)，加载Modelica的标准库。下面是一个模拟运行的示例文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">loadFile(&quot;/usr/share/doc/omc/testmodels/dcmotor.mo&quot;)</div><div class="line">list(dcmotor)  // 列出模型源代码</div><div class="line">instantiateModel(dcmotor) //对模型进行实例化，得到实例化后的代码</div><div class="line">simulate(dcmotor, startTime=0, stopTime=10.0)</div></pre></td></tr></table></figure>
<p>模拟之后我们可以得到一系列变量，然后用它们来画图。val(variableName, time)函数就是用于得到模拟结果中的变量在特定时间的值的。</p>
<p>比如我们看如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">loadFile(&quot;/usr/share/doc/omc/testmodels/BouncingBall.mo&quot;);</div><div class="line">list(BouncingBall);</div><div class="line">simulate(BouncingBall, stopTime=3.0);</div><div class="line">plot(&#123;h,flying&#125;);</div></pre></td></tr></table></figure>
<p>在OMShell中运行的代码可以保存成.mos格式（Modelica script）。然后通过runScript命令来运行。（使用writeFile可以将字符串写入特定文件）。</p>
<p>接下来我们演示一个开关的模拟的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">model Switch</div><div class="line">    Real v;</div><div class="line">    Real i;</div><div class="line">    Real i1;</div><div class="line">    Real itot;</div><div class="line">    Boolean open;</div><div class="line">equation</div><div class="line">    itot = i+i1;</div><div class="line">    if open then v=0;</div><div class="line">    else i=0;</div><div class="line">    end if</div><div class="line">    1-i1=0;</div><div class="line">    1-v-i=0;</div><div class="line">    open = time &gt;= 0.5;</div><div class="line">end Switch;</div><div class="line">simulate(Switch, startTime=0, stopTime=1);</div><div class="line">val(itot,0);</div></pre></td></tr></table></figure>
<p>类似于Matlab，可以使用clear()清楚当前工作区，使用list()查看加载的模型。在OpenModelica当中，控制结构、函数、变量、类型都是非常正常的概念，还可以使用typeOf()函数查看变量的类型。Modelica实现模拟主要是通过simulate函数。函数既可以输出成特定的模拟结果，也可以只保存特定的变量。也可以使用并行模拟（启动omc的时候指定并行的参数）。</p>
<p>Model的library又称package，使用package来定义，里面可以添加一些注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">package Modelica</div><div class="line">annotation(uses(Complex(version=&quot;1.0&quot;),ModelicaServices(version=&quot;1.1&quot;)));</div><div class="line">end Modelica;</div></pre></td></tr></table></figure>
<p>在加载模块的时候，如果指定了对指定包的依赖关系，那么指定包也会加载上去：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">model M</div><div class="line">annotation(uses(Modelica(version=&quot;3.2.1&quot;)));</div><div class="line">end M;</div><div class="line">instantiateModel(M)</div><div class="line">instantiateModel(Modelica.Electrical.Analog.Basic.Ground) //只加载其中的模块</div><div class="line">list(Modelica) //查询名为Modelica的模块的模型。</div><div class="line">quite() //退出Modelica环境</div></pre></td></tr></table></figure>
<p>Modelica的模型可以转换成Matlab的模型，只需要一个exportDAEtoMatlab()函数就可以完成转换了。</p>
<p>omc命令是modelica的编译器。它可以读取一个.mo文件然后编译模型。另外，omc也可以执行.mos格式的脚本命令，以非交互的方式运行。还可以在运行中执行调试工作。</p>
<p>OMEdit是图形化的编辑模型的界面。里面可以使用预定义的模型、用户定义的模型，组件接口，以及模拟过程，还可以绘制图形。</p>
<p>在Model里面也可以定义algorithm。以调试算法。OpenModelica支持文学编程方法。在交互式Notebookk　就可以实现。</p>
<p>面向Eclipse的MDT支持Modelica与MetaModelica的开发。在相关网站上可以下载到OpenModelica的插件。之后就可以在Eclipse环境下进行工作了。也有高亮，也可以绘制出来图形。还可以进行调试等工作（使用GDB）。也有一些3D库，可以完成3D图形的建模等工作。除此之外，还可以方便地调用外部的C函数，或者调用Python的函数。另外，从Python中也可以调用Modelica的函数，使用OMPython。</p>
<h2 id="关于modelica">关于Modelica</h2>
<p>Modelica当然是一种通用的建模与模拟的软件。但是其建模的方式也有其特殊之处。首先是使用了面向对象的技术，一个模型可以看成是一个对象，并且像编程语言那样使用class关键字来声明。然后变量有相应的类型。模型中的恒等式可以使用DAE（微分代数方程，连续情形）或者Event triggerg来表示（离散时间）。比如如下的VanDerPol的方程模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class VanDerPol &quot;Van Der Pol振子模型&quot;</div><div class="line">Real x(start=1) &quot;描述变量x&quot;;</div><div class="line">Real x(start=1) &quot;y变量&quot;;</div><div class="line">parameter Real lambda = 0.3;</div><div class="line">equation</div><div class="line">der(x) = y;</div><div class="line">der(y) = -x + lambda*(1-x*x)*y;    // 微分方程约束</div><div class="line">end VanDerPol;</div></pre></td></tr></table></figure>
<p>另外，Modelica还可以处理连续与离散情形混合的情况，进行混合的建模。另外则是Modelica语言显著缩短了在建模的时候进行系统定义、系统分解、子系统建模、因果关系推测、实现以及模拟所花费的时间。</p>
<p>Simulink是基于信号流进行建模的语言。但是Modelica语言则是完全按照物理模型的结构来的，中间不需要刻意去写成信号流图的形式。因此，我们可以直观地画出电路图就可以模拟，而不用转换成Matlab那种信号流的模式。另外，Modelica也可以进行图形可视化的建模，通过拖动实现模块的组合。</p>
<p>比如如下的直流电机的建模：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">model DCMotor</div><div class="line">    Resistor R(R=100);</div><div class="line">    Inductor L(L=100);</div><div class="line">    VsourceDC DC(f=10);</div><div class="line">    Ground G;</div><div class="line">    ElectroMechanicalElement EM(k=10,J=10,b=2);</div><div class="line">    Inertia load;  //器件与器件的性能参数</div><div class="line">equation </div><div class="line">    //连接方程，Modelica会根据连接方程自动推导函数关系，转化成ODE与DAE的形式</div><div class="line">    connect(DC.p, R.n);</div><div class="line">    connect(R.p, L.n);</div><div class="line">    connect(L.p, EM.n);</div><div class="line">    connect(Em.p, DC.n);</div><div class="line">    connect(DC.n, G.p);</div><div class="line">    connect(EM.flange, load.flange);</div><div class="line">end DCMotor</div></pre></td></tr></table></figure>
<p>中间的执行流程是图形或者文本模型经过处理变成Modelica的源代码。变成Modelica的模型。然后通过Translator变成混合DAE所描述的方程。然后使用分析器进行分析，再用优化器优化成C代码。最后编译并执行。模拟的时候，OpenModelica中也可以选择交互式模拟的方式。</p>
<p>Modelica在生物、机械、化学、工业中都有比较成功的应用。练习OpenModelica的时候，刚开始可以从图形化的OMedit开始，建立一个RLC电路的模拟。网上有相关教程：</p>
<ol>
<li>打开OMEdit，文件菜单中选择新建模型，输入模型名RLCircuit（也就是新建Class，在OMEdit中也可以新建Modelica的元模型）。</li>
<li>在左侧的库中选择Modelica下面的电路元件，将它们按标准连接起来。</li>
<li>点击模拟即可。</li>
</ol>
<p>Modelica与SysML、ModelicaML、UML也有合作。其中的ModelicaML就是为了支持软件与硬件建模而设计的UML Profile。还可以将UML/SysML映射到Modelica。</p>
<p>在Modelica语言中，类型有Boolean等。而变量可以加上constant或者parameter，表示不变的量或者变化的量（后者允许模拟的时候交互式调整）。class声明与model声明类似，但是class声明的可以被实例化，还有protected、public等修饰的变量。Modelica中函数也可以看成是特别的类。但是多了input/output、algorithm等块体。函数中也有protected的成员。record可以表示记录体结构、定义参数形式。Modelica也支持所谓的多继承。</p>
<p>最好可能还是从OMNotebook开始。因为里面有许多可视化。如果是离散的，那么可以在变量前面加上discrete修饰词。比如如下的离散模型：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">model SamplingClock</div><div class="line">    Integer i;</div><div class="line">    discrete Real r;</div><div class="line">equation</div><div class="line">    when sample(2,0.5) then</div><div class="line">        i = pre(i) + 1;</div><div class="line">        r = pre(r) + 0.3;</div><div class="line">    end when;</div><div class="line">end SamplingClock;</div></pre></td></tr></table></figure>
<p>图形建模的时候有自己的规则。比如特别规定了connector为一种连接器类别。Modelica中定义了许多物理系统的连接器。使用connnect函数可以连接许多内容。连接器需指定连接方程，默认的方程是两端信号值相等。如果是flow函数，则表示流量相等，方向也是相同的。</p>
<p>在Modelica中不能被实例化的类称为partial class。DrControl是专门用于讲控制理论的一个建模的手册，可以方便地写出控制的方程来。</p>
<div id="refs" class="references">
<div id="ref-DBLP:conf/wsc/ProssBJH12">
<p>Proß, Sabrina, Bernhard Bachmann, Sebastian Janowski, and Ralf Hofestädt. 2012. “A New Object-Oriented Petri Net Simulation Environment Based on Modelica.” In <em>Winter Simulation Conference, WSC ’12, Berlin, Germany, December 9-12, 2012</em>, edited by Oliver Rose and Adelinde M. Uhrmacher, 300:1–300:13. WSC. doi:<a href="https://doi.org/10.1109/WSC.2012.6465287" target="_blank" rel="external">10.1109/WSC.2012.6465287</a>.</p>
</div>
</div>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/15/160115-数据类型抽象/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/15/160115-数据类型抽象/" itemprop="url">
                  常见的数据结构的抽象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-01-15T00:00:00+08:00">
                2016-01-15
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:52:21+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机科学/" itemprop="url" rel="index">
                    <span itemprop="name">计算机科学</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/01/15/160115-数据类型抽象/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/15/160115-数据类型抽象/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>为了编程的顺利进行，自然有一种控制复杂性的措施。而且复杂性的控制从编程语言一开始的时候就有了，成为所谓的内部模式：内建的数据结构，甚至是语言机制里面的内容。现在我们看一些常见的数据类型。</p>
<h3 id="数组">数组</h3>
<p>按照Wiki的要求，应该按照数据结构和数据类型两个不同的角度讲数组array。作为数据结构的数组是由一系列元素（值或者变量）构成的，每个元素数数组由键或者索引来标识。按照要求，数组里的元素的存储应该可以按照数学公式来计算，也就是说，数组的标识不能是简单的字符串，而要使用一个域，特别是使用整数来标识。</p>
<p>数组在历史上出现得是非常早的，经常作为列表list以及字符串string的实现。在现代计算机当中，内存通常都是按照一维数组的方式来计算的。而现代计算机中的优化，特别是向量处理机，都是针对数组的操作而优化的。（数据结构就是数据结构，跟它们使用硬件或者软件实现并没有关系）。</p>
<p>数组的一个大优势在于所使用的下标可以在运行时候被计算出来。但是需要注意的是，在底层数据结构也可能非常复杂。数组可能用哈希表、链表、查找树等结构实现。总而言之，底层数据结构与顶层数据结构有很大的不同。1945年John von Neumann写了第一个数组排序的算法。</p>
<p>作为抽象数据类型的列表，包含的操作有：</p>
<ol style="list-style-type: decimal">
<li>创建一个空表；</li>
<li>测试当前列表是否为空；</li>
<li>添加一个元素到列表的第一个位置；</li>
<li>添加一个元素到列表的最后位置；</li>
<li>得到列表的第一个元素；</li>
<li>引用列表中除了第一个元素之外的其它元素。</li>
</ol>
<p>对于特定类型的列表，具有如下的操作规范：</p>
<ul>
<li>nil: () <span class="math inline">\(\to\)</span> L</li>
<li>cons: E <span class="math inline">\(\times\)</span> L <span class="math inline">\(\to\)</span> L</li>
<li>first: L <span class="math inline">\(\to\)</span> E</li>
<li>rest: L <span class="math inline">\(\to\)</span> L</li>
</ul>
<p>with the axioms</p>
<ul>
<li>first (cons (e, l)) = e</li>
<li>rest (cons (e, l)) = l</li>
</ul>
<p>for any element e and any list l. It is implicit that</p>
<ul>
<li>cons (e, l) <span class="math inline">\(\neg\)</span> l</li>
<li>cons (e, l) <span class="math inline">\(\neg\)</span> e</li>
<li>cons (e1, l1) = cons (e2, l2) if e1 = e2 and l1 = l2</li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/06/160106-信息几何/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/06/160106-信息几何/" itemprop="url">
                  信息几何简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-01-06T00:00:00+08:00">
                2016-01-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:44:06+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/01/06/160106-信息几何/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/06/160106-信息几何/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="认识信息几何">认识信息几何</h2>
<p>信息几何的方法其实是将统计理论中的参数问题变成额外的一个空间，在这个空间上建立统计函数之间的距离，相当于仍然是使用测度的理论研究问题。这种方法自然对于参数的生成有重要的启示。启示我们为什么要选择这样的参数，这什么参数有这些形态。在扩大的空间当中，自然而然地可以非常方便地研究统计系统的重多的要素。在机器学习中也有更多的应用。</p>
<p>然而单纯起来看，并非信息是几何的，而是因为分布函数之间的距离就是可以度量的。这样的话，未必形成微分流形，甚至是更一般的内容也可以，比如离散分布与离散参数的问题。总而言之，关键在于考察“所有可能的参数所形成的空间”，而不是“某个参数下的分布”所起的作用吧。</p>
<p>信息几何有几种经典的方法。第一是基于流形上的Riemann度量的方法，第二种是基于<span class="math inline">\(\alpha\)</span>联络与对偶几何的方法。还可以是基于曲率度量的方法，或者基于信息散度(divergence)的方法。散度在信息什么几何中充当距离函数，用来度量两个点之间的分离度或者差异，但散度不是严格意义上的距离函数。</p>
<p>信息几何的数学形式可以按照如下的思路构造。首先，给出参数分布族<span class="math inline">\(p(x,\theta)\)</span>，其中<span class="math inline">\(\theta \in \Theta\)</span>是参数，<span class="math inline">\(x\)</span>是样本空间<span class="math inline">\(X\)</span>中的随机变量，<span class="math inline">\(p(x;\theta)\)</span>是<span class="math inline">\(x\)</span>的概率密度函数。<span class="math inline">\(\theta\)</span>是一个<span class="math inline">\(n\)</span>维向量而<span class="math inline">\(\Theta\)</span>是<span class="math inline">\(\RR^n\)</span>的开集，<span class="math inline">\(\theta\)</span>可以看成是流形<span class="math inline">\(S\)</span>上面的坐标系，每点关联一个概率密度函数。然后定义　</p>
<p><span class="math display">\[ g_{ij} = E[\partial_i \log p(x;\theta) \partial_j \log p(x;\theta)],
i,j=1,2,\cdots,n \]</span> 其中<span class="math inline">\(E\)</span>表示概率密度<span class="math inline">\(p(x;\theta)\)</span>的期望，<span class="math inline">\(\partial_i = \frac{\partial}{\partial \theta_i}\)</span>。用Fisher信息矩阵<span class="math inline">\(g_{ij}\)</span>表示黎曼度量。然后定义流形<span class="math inline">\(S\)</span>上的一族联络<span class="math inline">\(\Delta^{(\alpha)}\)</span>，称之为<span class="math inline">\(\alpha\)</span>-联络，定义为： <span class="math display">\[ \langle \Delta_A^{(\alpha)}B, C \rangle = E[(ABl)(Cl)] + 
    \frac{1-\alpha}{2} E[(Al)(Bl)(Cl)],\]</span></p>
<p>其中<span class="math inline">\(A\)</span>，<span class="math inline">\(B\)</span>，<span class="math inline">\(C\)</span>为流形<span class="math inline">\(S\)</span>的三个向量场，<span class="math inline">\(ABl=A(Bl)\)</span>，<span class="math inline">\(l=l(x;\theta)=\log p(x;\theta)\)</span>，<span class="math inline">\(\alpha\)</span>为实参数。<span class="math inline">\(\alpha\)</span>-联络相比于黎曼联络有更广泛的适用条件。不过<span class="math inline">\(\alpha\)</span>-联络不满足度量性。</p>
<p>在统计推断中，指数分布族占有极其重要的地位。从流形的观点看，指数分布族具有对偶平坦的何结构。特别地，正态分布族的函数的流形的高斯曲率是<span class="math inline">\(-1/2\)</span>，因此是一个双曲面。</p>
<p>在信息几何中，两个非常重要的概念是散度和投量。信息几何在神经网络学习、热力学的流形、以及控制系统、Birkhoff系统、都有应用。</p>
<h2 id="信息几何与统计学派">信息几何与统计学派</h2>
<p>典型的信息几何是针对于参数分布族的。而统计推断的两大学派（频率学派与贝叶斯学派）的统计推断都常都是针对特定的参数的。信息几何只依赖于参数分布族的特点，使得信息几何不会受到两个学派关于概率的哲学本质的争论的问题。两种学派在具体怎样推断参数上面有一些区别。</p>
<p>经典统计只利用总体与样本的信息，而Bayesian统计还利用先验信息（集中在参数<span class="math inline">\(\theta\)</span>的先验分布上）。经典学派的观点上，概率是大量独立重复实验下事件发生频率的稳定值，离开重复实验，概率就无从谈起。但是贝叶斯学派认为在无重复实验的条件下概率可以凭主观认识及以经验确定。</p>
<p>注：不过，度量不确定性有几种不同的方式，可以是概率，也可以是模糊。这样的话，关于不确定性的信息处理其实就有许多个不同的哲学出发点。</p>
<p>我们来看数学上的不同。在参数统计模型中通常含有未知参数<span class="math inline">\(\theta \in \Theta\)</span>，其中<span class="math inline">\(\Theta\)</span>是参数空间。在经典统计中，样本分布族通常以<span class="math inline">\(f(x;\theta)\)</span>出发，对<span class="math inline">\(\theta\)</span>进行统计推断（参数估计与假设检验等）。在经典统计中<span class="math inline">\(f(x;\theta)\)</span>称为是似然函数。Bayesian统计保存了样本分布<span class="math inline">\(f(x;\theta)\)</span>，但是解释有所不同。Bayesian统计认为<span class="math inline">\(\theta\)</span>是取值于<span class="math inline">\(\Theta\)</span>的随机变量，样本分布<span class="math inline">\(f(x;\theta)\)</span>是给定某<span class="math inline">\(\theta\)</span>的时候<span class="math inline">\(X\)</span>的条件分布，因此可以记为<span class="math inline">\(f(x \vert \theta)\)</span>。从数学上看，<span class="math inline">\(f(x \vert \theta)\)</span>与<span class="math inline">\(f(x;\theta)\)</span>都可以看成是<span class="math inline">\(x\)</span>与<span class="math inline">\(\theta\)</span>都在变化的时候的分布函数，也就是多元函数的形态，但是多元函数所满足的条件有所不同。这一点在概率论定义条件分布时候有所体现。</p>
<p>参数估计通常是点估计或者区间估计。两种不同的统计方法都有点估计和区间估计。从信息几何的观点来看，Bayes网络是一种特殊的概率分布族；因为引入了条件独立性而降低了流形的统合度，从而简化了统计流形上的Riemann度量矩阵。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/01/01/160101-Hexo说明/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2016/01/01/160101-Hexo说明/" itemprop="url">
                  Hello World from the Hexo
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2016-01-01T00:00:00+08:00">
                2016-01-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:20+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2016/01/01/160101-Hexo说明/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/01/160101-Hexo说明/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          A short description of the blog
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2016/01/01/160101-Hexo说明/">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/12/09/151209-Daemon-Programming/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/12/09/151209-Daemon-Programming/" itemprop="url">
                  守护进程的编写思路（C与Python）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-12-09T00:00:00+08:00">
                2015-12-09
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:19+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/12/09/151209-Daemon-Programming/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/09/151209-Daemon-Programming/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考<a href="http://www.netzmafia.de/skripten/unix/linux-daemon-howto.html" class="uri" target="_blank" rel="external">http://www.netzmafia.de/skripten/unix/linux-daemon-howto.html</a>。上面提到Linux守护进程应该做的基本的事情，守护进程主要包括了</p>
<ul>
<li>从主程序中创建子进程</li>
<li>改变文件的umask任务</li>
<li>打开日志文件以记录日志</li>
<li>创建会话ID</li>
<li>将工作目录移动到一个安全的位置</li>
<li>关闭标准的文件描述符（守护进程不存在标准输入与输出的问题）</li>
</ul>
<p>显然这是针对具体情况的需求建模的一部分。因为守护进程总是从系统中由一个脚本调用或者用户手动启动的。在启动的时候，守护进程和系统中其它的进程一样被对待。但是守护进程的目标要使得它能够独立于会话而存在。具体代码的执行还是由子进程完成的。在Linux当中，这是通过fork函数完成的。在守护进程的编写中，很大一部分代码全部是处理控制流的，特别是异常处理，这没有什么可问的：事实就是如此，我们也不得不面对。当然要接受这样的现实并写出大量异常处理的代码。编程的最本质的困难可能还是在于对于控制流的掌握把，至于具体的算法则是理论上的另外一方面的问题了。</p>
<p>进程成功创建子进程之后，父进程应该及时终止退出，然后由子进程执行任务。显然，这个时候子进程是沿着父进程的当前控制流继续执行的。接下来就是子进程的任务。</p>
<h2 id="改变文件的掩码">改变文件的掩码</h2>
<p>为了能够写入由daemon所创建的文件，必须保持daemon在创建这些文件的时候有写入的权限。该权限是由umask来控制的，可以保证它们可以正确地读取或写入文件。umask可以在命令行当中运行，但是保险的方法还是通过编程接口。在linux系统中完成切换umask任务的是umask函数。设置umask为0可以对文件有完全的访问权限。</p>
<p>第三步是打开日志。但是该步骤是可选的。该可选的步骤可以导出许多有用的信息。</p>
<p>第四步是创建SID结构。目的是让这个进程的父进程去掉，成为一个orphan进程，以便不受到用户会话的影响。方法是创建一个SID。使用setsid函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">pid_t</span> pid, sid;</div><div class="line"><span class="comment">/* Fork off the parent process */</span></div><div class="line">pid = fork()</div><div class="line"><span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123; <span class="built_in">exit</span>(EXIT_FAILURE); &#125;  <span class="comment">// fork process failed</span></div><div class="line"><span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123; <span class="built_in">exit</span>(EXIT_SUCCESS); &#125;  <span class="comment">// succeed and exit parent process</span></div><div class="line"></div><div class="line"><span class="comment">/* Change the file mode mask */</span></div><div class="line">umask(<span class="number">0</span>)</div><div class="line"></div><div class="line"><span class="comment">/* Open any logs here */</span></div><div class="line"></div><div class="line"><span class="comment">/* Create a new SID for the child process */</span></div><div class="line">sid = setsid();</div><div class="line"><span class="keyword">if</span> (sid &lt; <span class="number">0</span>) &#123; <span class="built_in">exit</span>(FAILURE); &#125;  <span class="comment">// don't forget to enable your log</span></div></pre></td></tr></table></figure>
<p>再一步是改变工作的目录。我们必须保证该目录存在。在按照FHS标准的系统中可以是/tmp的目录，但是保险的方法还是使用根目录作为当前的工作目录。使用chdir函数可以完成这样的任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> ( (chdir(<span class="string">"/"</span>)) &lt; <span class="number">0</span> ) &#123; <span class="built_in">exit</span>(EXIT_FAILURE); &#125; <span class="comment">// 失败返回-1</span></div></pre></td></tr></table></figure>
<p>关闭标准文件描述符是最后的一步。这是因为守护进程根本就没有标准输入输出可以使用。使用的是close函数。如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">close(STDIN_FILENO);</div><div class="line">close(STDOUT_FILENO);</div><div class="line">close(STDERR_FILENO);</div></pre></td></tr></table></figure>
<h3 id="守护进程的执行逻辑">守护进程的执行逻辑</h3>
<p>经过之上的步骤，终于算是符合了daemon的行为规范。接下来就需要写一系列的具体完成daemon的代码了。初始化守护进程中其中的第一步。常见的逻辑是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* Daemon-specific initialization goes here */</span></div><div class="line"></div><div class="line"><span class="comment">/* The big loop */</span></div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123; </div><div class="line">    <span class="comment">/* Do your task here */</span></div><div class="line">    sleep(<span class="number">30</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>也就是说，这个时候守护进程是一个循环的程序。</p>
<p>注意，日志一般应使用syslog的系统，使用syslog提供的机制。</p>
<h2 id="使用python写linux的守护进程">使用Python写Linux的守护进程</h2>
<p>现在更多地是使用脚本语言和面向对象的技术来完成基本任务的编写。所以接下来我们选择一个使用Python来写守护进程的一个脚本。参考<a href="http://blog.csdn.net/LikeHighTime/article/details/4602456%7D。原贴%3Chttp://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/" class="uri" target="_blank" rel="external">http://blog.csdn.net/LikeHighTime/article/details/4602456}。原贴&lt;http://www.jejik.com/articles/2007/02/a_simple_unix_linux_daemon_in_python/</a>。</p>
<p>其头部的关键是使用signal的库导入一些信号，并使用一些系统的头文件。之后则是创建一个Daemon的类。在该类中的初始化函数，daemonize化函数支撑函数的运行。</p>
<p>我们先来看Daemon的原型，用户的守护进程是从这个类继承过来的。</p>
<p>守护进程类原型有如下的几个重要的例子：</p>
<p>init函数：该函数表示的是进入守护进程的时候的初始的设置。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, pidfile, stdin=<span class="string">'/dev/null'</span>, stdout=<span class="string">'/dev/null'</span>, stderr=<span class="string">'/dev/null'</span>)</span>:</span>  </div><div class="line">      self.stdin = stdin  </div><div class="line">      self.stdout = stdout  </div><div class="line">      self.stderr = stderr  </div><div class="line">      self.pidfile = pidfile</div></pre></td></tr></table></figure>
<p>daemonize函数，该函数用于执行UNIX的所谓的double-fork方法。该方法可见Stevens’ “Advanced Programming in the UNIX Environment” for details (ISBN 0201563177) <a href="http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16" class="uri" target="_blank" rel="external">http://www.erlenstar.demon.co.uk/unix/faq_2.html#SEC16</a>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">daemonize</span><span class="params">(self)</span>:</span></div><div class="line">    <span class="keyword">try</span>:   </div><div class="line">        pid = os.fork()   </div><div class="line">        <span class="keyword">if</span> pid &gt; <span class="number">0</span>:  </div><div class="line">            <span class="comment"># exit first parent  </span></div><div class="line">            sys.exit(<span class="number">0</span>)   </div><div class="line">    <span class="keyword">except</span> OSError, e:   </div><div class="line">        sys.stderr.write(<span class="string">"fork #1 failed: %d (%s)/n"</span> % (e.errno, e.strerror))  </div><div class="line">        sys.exit(<span class="number">1</span>)  </div><div class="line">  </div><div class="line">    <span class="comment"># decouple from parent environment  </span></div><div class="line">    os.chdir(<span class="string">"/"</span>)   </div><div class="line">    os.setsid()   </div><div class="line">    os.umask(<span class="number">0</span>)   </div><div class="line"></div><div class="line">    <span class="comment"># do second fork  </span></div><div class="line">    <span class="keyword">try</span>:   </div><div class="line">        pid = os.fork()   </div><div class="line">        <span class="keyword">if</span> pid &gt; <span class="number">0</span>:  </div><div class="line">            <span class="comment"># exit from second parent  </span></div><div class="line">            sys.exit(<span class="number">0</span>)   </div><div class="line">    <span class="keyword">except</span> OSError, e:   </div><div class="line">        sys.stderr.write(<span class="string">"fork #2 failed: %d (%s)/n"</span> % (e.errno, e.strerror))  </div><div class="line">        sys.exit(<span class="number">1</span>)   </div><div class="line">  </div><div class="line">    <span class="comment"># redirect standard file descriptors  </span></div><div class="line">    sys.stdout.flush()  </div><div class="line">    sys.stderr.flush()  </div><div class="line">    si = file(self.stdin, <span class="string">'r'</span>)  </div><div class="line">    so = file(self.stdout, <span class="string">'a+'</span>)  </div><div class="line">    se = file(self.stderr, <span class="string">'a+'</span>, <span class="number">0</span>)  </div><div class="line">    os.dup2(si.fileno(), sys.stdin.fileno())  </div><div class="line">    os.dup2(so.fileno(), sys.stdout.fileno())  </div><div class="line">    os.dup2(se.fileno(), sys.stderr.fileno())  </div><div class="line">  </div><div class="line">    <span class="comment"># write pidfile  </span></div><div class="line">    atexit.register(self.delpid)  </div><div class="line">    pid = str(os.getpid())  </div><div class="line">    file(self.pidfile,<span class="string">'w+'</span>).write(<span class="string">"%s/n"</span> % pid)</div></pre></td></tr></table></figure>
<p>该方法完成的就是之前的C语言的大部分的内容了。</p>
<p>之后是管理PID文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">delpid</span><span class="params">(self)</span>:</span>  </div><div class="line">    os.remove(self.pidfile)</div></pre></td></tr></table></figure>
<p>开始进程函数start完成开启进程，让进程运行的任务。该函数检查相应的PID文件是否存在，存在表示进程已经在运行，所以就退出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">start</span><span class="params">(self)</span>:</span>  </div><div class="line">    <span class="string">""" </span></div><div class="line">    Start the daemon </div><div class="line">    """  </div><div class="line">    <span class="comment"># Check for a pidfile to see if the daemon already runs  </span></div><div class="line">    <span class="keyword">try</span>:  </div><div class="line">        pf = file(self.pidfile,<span class="string">'r'</span>)  </div><div class="line">        pid = int(pf.read().strip())  </div><div class="line">        pf.close()  </div><div class="line">    <span class="keyword">except</span> IOError:  </div><div class="line">        pid = <span class="keyword">None</span>  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> pid:  </div><div class="line">        message = <span class="string">"pidfile %s already exist. Daemon already running?/n"</span>  </div><div class="line">        sys.stderr.write(message % self.pidfile)  </div><div class="line">        sys.exit(<span class="number">1</span>)  </div><div class="line">      </div><div class="line">    <span class="comment"># Start the daemon  </span></div><div class="line">    self.daemonize()  </div><div class="line">    self.run()</div></pre></td></tr></table></figure>
<p>停止函数是这样的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop</span><span class="params">(self)</span>:</span>  </div><div class="line">    <span class="string">""" </span></div><div class="line">    Stop the daemon </div><div class="line">    """  </div><div class="line">    <span class="comment"># Get the pid from the pidfile  </span></div><div class="line">    <span class="keyword">try</span>:  </div><div class="line">        pf = file(self.pidfile,<span class="string">'r'</span>)  </div><div class="line">        pid = int(pf.read().strip())  </div><div class="line">        pf.close()  </div><div class="line">    <span class="keyword">except</span> IOError:  </div><div class="line">        pid = <span class="keyword">None</span>  </div><div class="line">  </div><div class="line">    <span class="keyword">if</span> <span class="keyword">not</span> pid:  </div><div class="line">        message = <span class="string">"pidfile %s does not exist. Daemon not running?/n"</span>  </div><div class="line">        sys.stderr.write(message % self.pidfile)  </div><div class="line">        <span class="keyword">return</span> <span class="comment"># not an error in a restart  </span></div><div class="line">    <span class="comment"># Try killing the daemon process      </span></div><div class="line">    <span class="keyword">try</span>:  </div><div class="line">        <span class="keyword">while</span> <span class="number">1</span>:  </div><div class="line">            os.kill(pid, SIGTERM)  </div><div class="line">            time.sleep(<span class="number">0.1</span>)  </div><div class="line">    <span class="keyword">except</span> OSError, err:  </div><div class="line">        err = str(err)  </div><div class="line">        <span class="keyword">if</span> err.find(<span class="string">"No such process"</span>) &gt; <span class="number">0</span>:  </div><div class="line">            <span class="keyword">if</span> os.path.exists(self.pidfile):  </div><div class="line">                os.remove(self.pidfile)  </div><div class="line">        <span class="keyword">else</span>:  </div><div class="line">            <span class="keyword">print</span> str(err)  </div><div class="line">            sys.exit(<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>接下来可以类似地定义restart与run函数。在写用户自己的进程的时候，用户需要手动写自己的run函数。重载之后就可以了。注意守护进程是有自己的特定的PID文件的。一般是放在/tmp目录。但是也有一些系统进程。至于在运行的时候切换到其它的进程，则可以通过一些库来完成。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/08/31/150831-Scheme语言概要/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/08/31/150831-Scheme语言概要/" itemprop="url">
                  Scheme语言概要
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-08-31T00:00:00+08:00">
                2015-08-31
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:19+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/08/31/150831-Scheme语言概要/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/08/31/150831-Scheme语言概要/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在人工智能语言中我们应该接触过Scheme。根据介绍，Scheme和CommonLisp是两种主要的Lisp方言之一，也就是说，在讲Lisp语言的时候，我们也包括了讲Lisp或者CommonLisp语言。Scheme语言的地位是由一系列的Lambda论文决定的。见<a href="https://en.wikipedia.org/wiki/History_of_the_Scheme_programming_language#The_Lambda_Papers" class="uri" target="_blank" rel="external">https://en.wikipedia.org/wiki/History_of_the_Scheme_programming_language#The_Lambda_Papers</a>。Scheme的后缀扩展名是.scm或者.ss。Scheme是动态强类型的语言，具有词法作用域，当然是函数式语言。此外，Scheme的特点是它是第一个实现了头等延续的语言（这里的延续指的是计算机程序的控制状态，头等延续指的是可以创建，保存、赋值程序的状态给一个变量，并根据需要恢复程序的运行上下文）。对于延续的介绍可见<a href="https://en.wikipedia.org/wiki/Continuation" class="uri" target="_blank" rel="external">https://en.wikipedia.org/wiki/Continuation</a>。</p>
<p>Scheme对于CommonLisp的设计产生了重要的影响。Scheme的开发其实是基于实现当时的Actor并发模型的思想。Scheme的最新标准是R7RS，制定于2013年。</p>
<p>描述Scheme的最佳的方式或许是这样的。首先，Scheme的语法风格来自于简洁的S-表达式。然后数据结构是基于表处理的，刚开始的时候我们会看到很多的表处理的模式（如果有可能的话，我们也可以在其它的编程语言中模仿它），这种表处理的模式导致了我们很容易在运行的时候动态地创建Scheme代码。另外就是，它支持头等函数。虽然声称Lisp是函数式语言，但是其实Lisp的基本思想其实并不是高阶函数，而是所谓的抽象重写系统。另外的特点，就是对于<span class="math inline">\(\lambda\)</span>-演算和词法作用域的支持了。</p>
<p>语言核心中比较强大的应该是Scheme与Lisp语言中的Hygienic macro，也就是所谓的干净的宏了。这里的干净是指宏的名词不会引起词法作用域的冲突。最早的关于干净的宏的文章见于Kohlbecker在1986年的文章《Hygienic Macro Expansion》。现在看来，TeX系统中用的宏与Lisp语言中的差不多。它们都是词法意义上的，虽然行为上与惰性求值类似，但是其实不是一回事。使用宏的系统更像是基于规则的系统。Perl6与Julia语言也实现了像Lisp那样的宏。Elixir与Dylan语言中也可以。看来，我们得认真地对待Lisp的宏了。</p>
<h2 id="对gnu-guiler的介绍09-01-2015-095938-cst">对GNU Guiler的介绍[09-01-2015 09:59:38 CST]</h2>
<p>GNU Guile是GNU的一个Scheme语言的实现。我们知道，一个程序设计语言可以使用不同的后端。比如JBC(Java Bytecode)可以由Scheme、Python等语言的前端来生成。Guile最早的版本是在1993年发布的。相对于Scheme规范添加了许多的模块化扩展。</p>
<p>guile提供了libguile，用于支持将语言嵌入到其它的语言中（通过C API）。另外，使用C语言开发的许多的程序同时也可以移植到guile中。因为语言本身就是与后端的实现没有关系的。而在前端中嵌入代码又是十分正常的。guile语言的全名是GNU Ubiquitous Intelligent Language for Extensions。也就是说，本来的设计就是为了扩展的。实际上，该语言也被嵌入在GnuCash与Lilypond等语言中。</p>
<p>Guile系统实现的是所谓的R5RS，同时具有大部分的R6RS中的功能特性。SRFI的功能特性也具有一些。更多的是自己的扩充。目前有种将Emacs的脚本语言换成Scheme的计划。也许之后我们就可以比较自如地进行Scheme上面的Emacs编程了。</p>
<p>目前的几个Scheme实现，大多也是实现了R6RS，对于R7RS的支持都比较有限。所以我们目前还是以R6RS的标准为根据。下面我们打算介绍一下这个标准。R6RS有几个相关的标准，不只是核心语言，也包括一些库。但是Scheme的标准是出了名的精简。即使我们花时间全部读完成是值得的。</p>
<h2 id="scheme规范r6rs">Scheme规范R6RS</h2>
<p>导引的部分是这样的，首先Scheme实现了一等过程。也就是说，过程就像一个真正的值一样。注意，Scheme不是纯函数式的语言，所以它的函数解释为过程也非常自然。说是一等过程而不是一等函数还是比较自然一些。Scheme was one of the first programming language to incorporate first-class procedures as in the lambda calculusd, there by proving the usefulness of static scope rules and block structure in a dynamically typed language.</p>
<p>接下来我们要解释一下宏的概念。其实在函数的定义中，就是惰性的。求值发生在函数调用的时候。但是对于宏而言，其实是按名求值。在调用宏的时候，是把宏体做一个展开。TeX语言也是这样的一种模式。其实宏大概只是一种符号计算的方式而已。使用宏带来的一个明显的好处是我们可以方便地操纵程序语言的代码。</p>
<h2 id="对scheme语言的基本的描述">对Scheme语言的基本的描述</h2>
<p>R6RS的第一节介绍的是其语义。也就是说，把词法与语法甚至放到无关紧要的位置。首先是按照Algol的语言特征，Scheme实现的是静态作用域。使用变量的时候，变量关联到的时在词法上与该变量相绑定的位置。</p>
<p>Scheme的类型是属于“manifest types”。也就是说，类型是与对象（或者称为值）绑定的，而不是变量。具有类型的是特定的值而不说变量属于某个类型。所以经常有人说Scheme是弱类型的语言甚至说它是无类型的语言。其实Python、Ruby、Smalltalk也是属于manifest types。与Scheme不同的是Haskell、Java、ML等强类型的语言。</p>
<pre><code>所以这给我们提了一个醒，最好不要单纯地使用无类型与有类型来描述编程语言，也不使用强类型与弱类型来描述程序设计语言。最清晰的方法是使用宣告式类型或者隐式类型。其实类型化有一些专门的术语的，参考&lt;https://en.wikipedia.org/wiki/Manifest_typing&gt;我们可以知道manifest typing、latent typing、implicit typing、dynamic typing、subtyping等。</code></pre>
<p>Scheme有自己的废料收集机制，所以所涉及的对象也不用在语言中显式地销毁。看过《编程原本》之后我们应当知道对象、实体、类型、值的区别。这里的Object的含义应该是跟C++中的是一样的。也就是说，对象是对占据特定存储的那种事物的抽象。在这一点上，Scheme与Python、Haskell、Java都是相同的。</p>
<p>另一个特点是过程作为一等对象。过程可以动态地创建，并且保存在特定的数据结构中。这一点与Haskell、ML、Ruby、Smalltalk都是相同的。也就是说动态创建过程的能力与它们是相同的。</p>
<p>Scheme特有的概念是所谓的一等延续。也就是特定的程序上下文可以保存下来。在执行过程调用之前，过程的参数会被积极求值。也就是说如果我们把一个表达式作为参数传递给了一个过程，那么是把这个表达式的结果传递给这个过程。C、Python、Ruby在内的多种语言都使用这种求值机制。Haskell与R语言是按需调用。也就是说是否对传入的表达式求值由子过程来决定。</p>
<h3 id="scheme的对象与值">Scheme的对象与值</h3>
<p>Scheme的对象与值被组织成类型（而变量没有类型）。基本的类型有布尔型、数值、字符串、字符、符号、列表、数对等。使用<code>#f</code>和<code>#t</code>分别表示True和False。</p>
<p>之前我们读到过Scheme的设计原理。在数据类型中，Pair是最基本的元素。甚至List都是由Pair构成的。知道<span class="math inline">\(\lambda\)</span>-演算的人都知道组合子，也就知道如何用组合子来表示真与假。</p>
<h3 id="scheme的表达式">Scheme的表达式</h3>
<p>表达式是Scheme的最重要的组成元素了。表达式求值之后得到一个value。其实表达式可以建模成一种抽象数据类型的。比如，表示值的那些字符串是一个表达式，对它们求值得到一个值；表达式可以有子表达式等。Scheme的表达式采用前缀记法。</p>
<p>在语法上，换行符并不会影响表达式的解析。这主要是为了编程的考虑。</p>
<h3 id="变量绑定定义过程">变量、绑定、定义、过程</h3>
<p>let用于声明一个局部的变量的过程。如</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">let</span></span> ( (<span class="name">x</span> <span class="number">23</span>) (<span class="name">y</span> <span class="number">42</span>) ) (<span class="name"><span class="builtin-name">+</span></span> x y))</div></pre></td></tr></table></figure>
<p>上面的表达式中，let的第一个参数是对于符号的定义的列表，第二项是相应的表达式。结果是按照赋的值求解第二个表达式。注意这里的变量是局部定义的。</p>
<p>如果要让变量的定义超过当前的作用域，需要使用define。define是一个定义而不是一个表达式，因为它不返回任何的值，并且只能在程序的顶层出现。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> x <span class="number">23</span>)</div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> y <span class="number">42</span>)</div><div class="line">(<span class="name"><span class="builtin-name">+</span></span> x y)</div></pre></td></tr></table></figure>
<p>在一个嵌套的环境中内层的符号与哪个值绑定当然是按照最邻近的原则。另外，按照词法作用域的准则。求值的结果是依赖于定义的环境而不是被调用的环境。</p>
<p>过程也使用define来定义。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> x)</div><div class="line">    (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">42</span>))</div><div class="line">(<span class="name">f</span> <span class="number">23</span>)</div></pre></td></tr></table></figure>
<p>在定义的时候，函数及其参数作为第二个参数，而后面定义的是函数的体。过程是与特定的对象有关的表达式的抽象。由于后面的体可以看成是一个宏体，所以我们可以非常方便地定义高阶函数：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">apply_binop</span> binop first second)</div><div class="line">    (<span class="name">binop</span> first second))</div></pre></td></tr></table></figure>
<p>Scheme中虽然广泛采用了模式匹配。但是有些情况下的模式匹配仍然是会失败的，比如如下的代码：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">*</span></span> 失败的代码*)</div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> (<span class="name">apply_binop</span> binop (<span class="name">first</span> second))</div><div class="line">    (<span class="name">binop</span> first second))</div></pre></td></tr></table></figure>
<p>lambda表达式用于创建新的过程，过程中还可以包含闭包</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">((<span class="name"><span class="builtin-name">lambda</span></span> (x) (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">42</span>)) <span class="number">23</span>)</div></pre></td></tr></table></figure>
<p>上面的表达式都是过程调用，但是let与lambda开头的却不是过程调用。这是因为let与lambda并不是函数名称，而是Scheme语言的关键字。define也同样是如此。关键字后面跟的参数遵守怎样的规则是Scheme语言定义的。</p>
<h3 id="宏与模式匹配">宏与模式匹配</h3>
<p>在Scheme中，宏是声明具有特定的模式的参数的方法。借助于宏我们可以实现与lambda、define一样的效果。定义宏使用的是define-syntax语句。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define-syntax</span></span> def</div><div class="line">    (<span class="name"><span class="builtin-name">syntax-rules</span></span> ()</div><div class="line">        ((<span class="name">def</span> f (<span class="name">p</span> ...) body)</div><div class="line">            (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">f</span> p ...)</div><div class="line">                body))))</div><div class="line"></div><div class="line">(<span class="name">def</span> f (<span class="name">x</span>) (<span class="name"><span class="builtin-name">+</span></span> x <span class="number">42</span>))</div></pre></td></tr></table></figure>
<p>上面的语法将使def成为一个具有和define相同的效果的关键字。上面的语句的理解方式是，define-syntex定义了一个语法糖def，这个语法糖的使用规则由syntax-rules语句来声明。syntex-rules指出，这个语法糖模式匹配<code>(def f (p ...) body)</code>。匹配到这个语法的时候，执行的动作是上面的define。</p>
<h3 id="引用与阻止求值">1.10引用与阻止求值</h3>
<p>在介绍这一节的时候，感觉使用<code>'</code>表示阻止求值这种理解方式非常怪异。显得没有必要。但是其实把Scheme当成是一种自然语言就好了。这里的阻止求值其实就相当于自然语言中的引号。我们参考Quasi-quotation就知道了。既然它们是引号，自然里面的东西就不会再发生改变了。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">'23</span></div><div class="line">(<span class="name"><span class="builtin-name">quote</span></span> <span class="number">23</span>)</div></pre></td></tr></table></figure>
<p>在通常语言里，括号里面的东西就是字符串。但是在Scheme中，括号里面的东西仍然是保持Scheme语言里面的结构的。所以虽然说是一种引用，但是括号里面的东西不是一堆字符串，而是Scheme中的语法结构。</p>
<h3 id="库机制与顶层调用">1.12库机制与顶层调用</h3>
<p>Scheme中的库使用library关键字。库里面的内容可以主动导出与主动导入。</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name">library</span> (<span class="name">hello</span>)</div><div class="line">    (<span class="name">export</span> hello-world)</div><div class="line">    (<span class="name"><span class="builtin-name">import</span></span> (<span class="name">rnrs</span> base) (<span class="name">rnrs</span> io simple))</div><div class="line">    (<span class="name"><span class="builtin-name">define</span></span> (<span class="name">hello-world</span>)</div><div class="line">        (<span class="name"><span class="builtin-name">display</span></span> <span class="string">"Hello World"</span>)</div><div class="line">        (<span class="name"><span class="builtin-name">newline</span></span>)))</div></pre></td></tr></table></figure>
<p>Scheme的顶层程序第一行可以加一个Shell命令。以<code>#!</code>开头。</p>
<h2 id="scheme中的词法">Scheme中的词法</h2>
<p>在Scheme中语法定义是非常简单的。大约只有一页多。如</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">(<span class="name"><span class="builtin-name">define</span></span> 加 +)</div><div class="line">(<span class="name">加</span> <span class="number">1</span> <span class="number">2</span>)</div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> 真 <span class="literal">#t</span>)</div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> 假 <span class="literal">#f</span>)</div><div class="line">(<span class="name"><span class="builtin-name">define</span></span> 非 not)</div><div class="line">(<span class="name">非</span> 真)</div></pre></td></tr></table></figure>
<p>这样可以把scheme真接改造成一个中文编程环境。我们需要注意的，是Scheme中的quote与quasi-quote的机制。因为这一机制在其它的语言中很少见（或者说不常见）。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/02/150702-Scala编程理论视角/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/02/150702-Scala编程理论视角/" itemprop="url">
                  Scala编程概要（四）：控制抽象, 集合, 模式匹配, 编译器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-07-02T00:00:00+08:00">
                2015-07-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:18+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/07/02/150702-Scala编程理论视角/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/02/150702-Scala编程理论视角/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="scala的控制抽象">Scala的控制抽象</h3>
<p>Haskell有自己的抽制抽象。使用的是单体。但是在Scala中，没有必要做得那么纯函数式。所以为了调用控制流，Scala使用了<code>() =&gt; Unit</code>类型。比如说，我们要在某个线程当中创建一个过程：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">runInThread() &#123; () =&gt; println(<span class="string">"Hi"</span>); <span class="type">Thread</span>.sleep(<span class="number">1000</span>); println(<span class="string">"Bye"</span>) &#125;</div></pre></td></tr></table></figure>
<p>其中定义的runInThead函数是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">runInThread</span></span>( block : () =&gt; <span class="type">Unit</span>) &#123;</div><div class="line">	<span class="keyword">new</span> <span class="type">Thread</span> &#123;</div><div class="line">		<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123; block() &#125;</div><div class="line">	&#125;.start()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，由于可以使用大括号代替小括号，所以我们能够看到，调用runInThread，就好像是在过程体中写出一系列的函数一样。</p>
<p>实现runInThread的更简洁的形式，应该是这样的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">runInThread &#123;</div><div class="line">	println(<span class="string">"Hi"</span>)</div><div class="line">	<span class="type">Thread</span>.sleep(<span class="number">10000</span>)</div><div class="line">	println(<span class="string">"Bye"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>相对于上面的带有明显的高阶函数构造过程的实现，只有一点困难，就是我们如何省略掉<code>() =&gt;</code>。Scala实际上鼓励后者的这种方式，称为是换名调用。为了实现上述调用代码，对runInThread的定义变成：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">runInThread</span></span>(block : =&gt; <span class="type">Unit</span>) &#123;</div><div class="line">	<span class="keyword">new</span> <span class="type">Thread</span> &#123;</div><div class="line">		<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123; block &#125;</div><div class="line">	&#125;.start()</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>显然，定义的时候省略了参数<code>()</code>就可以做到。这样的话，可以构造出很多类似于控制流的语句。这样以来，看起来我们可以定义很多自己的控制流，比如<code>do..until</code>，<code>runInAnotherMachine {}</code>这样的控制语句。带参数的控制流当然也是可以定义的，因为我们可以与柯里化的函数结合使用。实际上，scala的if语句就是通过这里实现的。</p>
<p>until的实现见如下的代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">until</span></span>(condition : =&gt; <span class="type">Boolean</span>) (block: =&gt; <span class="type">Unit</span>) &#123;</div><div class="line">	<span class="keyword">if</span> (!condition) &#123;</div><div class="line">		block</div><div class="line">		until(condition) (block)</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中，除了柯里化函数定义外，我们尤其应当注意，为了使每次until的时候都能对condition求值一次，我们必须使condition惰性化。所以，condition是<code>() =&gt; Boolean</code>这样的形式。调用的时候，使用</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> x = <span class="number">10</span></div><div class="line">until (x=<span class="number">10</span>) &#123;</div><div class="line">	x -= <span class="number">1</span></div><div class="line">	println(x)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过，上面的语句中，仍然没有做到在until的第一个体里面声明变量<code>x</code>，而是得在until的外面声明变量，这种用法也不是完全的漂亮。</p>
<p>最后是Scala函数中return的使用。return确实是显式地终止函数。但是为了使用return，就相当于破坏了Scala的类型返回推导。因此，我们在定义有return的函数的时候，必须指定返回的类型。（其实应该还是能推导出来，但是可能没有通用的方案）。编程语言如果实现太高级，那么程序员的习惯可能难以适应（除了Haskell这样的语言）。</p>
<h2 id="scala的集合操作">Scala的集合操作</h2>
<p>相当一部分语言处理的任务是在列表、元组、字典这样的数据结构中实现的。它们就是一组数。在数学上看来自然是没有不同的。但是在编程中，似乎不同的方法需要单独处理一下。而且面对复杂的操作可能，也需要合适的抽象。</p>
<p>Scala的任何一种集合（列表、元组、字典）要么是可变的，要么是不可变的。而且所有类型的集合，都可以不用使用new方法来创建。因为它们都有apply方法。不可变的集合是非常理想的，因为在多线程的应用程序中使用他们也不会造成问题（不可变数据结构在单线程中的优势可能不明显，但是在多线程中，这种设计的优势是显而易见的）。</p>
<p>Scala优先采用不可变的集合类型。内置的List、Set、Map也都是不可变的。为了使用可变的数据结构，必须导入<code>scala.collection.mutable</code>包，以便使用<code>mutable.Map</code>得到可变的映射。（以及使用Map得到不可变的映射）。</p>
<p>不可变的序列Seq被定义为一个trait，而这个特质被许多类进一步采用。比如Vector、Range、List、Stream、Stack、Queue。Vector的优点是支持随机的访问。向量是树形的结构实现，向量中的元素每个节点可以有不超过32个子节点。这样访问100万的元素的向量，只需要跳转四下。但是在链表中访问某个元素却比较复杂（线性访问）。</p>
<p>试想象如下的代码</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="type">Range</span>(<span class="number">0</span>,<span class="number">1000000000</span>)(<span class="number">100000000</span>)</div></pre></td></tr></table></figure>
<p>在这样的代码中，我们要首先生成一个序列（当然，Range其实是惰性的，只在有需要的时候才生成）。但是我们要想取得某个位置的元素的值，如果是Iterable的话，还是需要迭代到相应的值。这样，我们定义Range当然没有问题，但是要访问后面的值的时候，就得逐个向前走。特别是，如果Iterable的对象是一个File流，那么原则上，访问第<span class="math inline">\(n\)</span>个元素的时候，也访问了之间的元素。因此Seq的朴素的实现，效率并不高。</p>
<p>Scala的可变序列也继承自Seq这个trait。具体的成员有IndexedSeq、ArrayBuffer、Stack、Queue、PriorityQueue、LinkedList、DoubleLinkedList。（回忆之前我们讲过，Scala对于递归函数、默认参数、带名参数、变长参数都有支持）。</p>
<p>集合的操作类型有很多。而且Scala也引入了对它们的模式匹配。所以是一个比较大的课题（大概Python中的集合类型也可以作为编程实践中的一大部分）。</p>
<p>在可变类型结构中，有时候我们会使用<code>list(3)=5</code>这样的方法。注意，Scala没有为集合类型重新定义一个<code>[]</code>的操作符，而且也没有必要。在Scala当中，这样的元素具有apply方法，所以可以直接应用它来进行赋值的操作。</p>
<p>Java与Scala的集合类型的相互转换，以及互操作这里也不介绍了。目前是没有什么收益的。</p>
<p>另外，即使有不可变的集合，大多数的并发编程的任务还是要求比较高级的线程安全特性。在Scal中，引入了相应的集合的Synchronized版本，比如SynchronizedSet。在并发库中，提供了<code>ConcurrentHashMap</code>等类。而且，相应的也有并行的版本。比如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (i &lt;- (<span class="number">0</span> until <span class="number">100</span>).par) print(i+<span class="string">" "</span>)</div></pre></td></tr></table></figure>
<p>这里，通过一个par方法把循环变成并行的版本。</p>
<p>注：七周七并发中提到了多种并发的模型，而《程序设计语言实践之路》中提到了创建线程的多种语法（比如，有的使用begin块来实现并行的代码，有的是通过并行循环，有的是加工时启动Ada。fork/join，隐含接收与早回复的模式也是实现并行常见的）。基本上这六种包含了在语言设计中实现并发或并行的所有的使用模式。不同的编程语言支持的模式也不相同。</p>
<h2 id="scala的模式匹配与样例类">Scala的模式匹配与样例类</h2>
<p>Scala的模式匹配的机制是比较强大的。具体地说，模式匹配可以用于match、类型检查，获取变量，匹配表达式类型。可以在模式匹配中添加守卫，使用通配符等。</p>
<p>模式匹配可以匹配变量的值，是也是最基本的方式。也可以用于匹配一个类型。</p>
<p>给模式添加守卫的方法示例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">ch <span class="keyword">match</span> &#123;</div><div class="line">	<span class="keyword">case</span> '+' =&gt; sign = <span class="number">1</span></div><div class="line">	<span class="keyword">case</span> '-' =&gt; sign = <span class="number">-1</span></div><div class="line">	<span class="keyword">case</span> _ <span class="keyword">if</span> <span class="type">Character</span>.isDigit(ch) =&gt; digit = <span class="type">Character</span>.digit(ch,<span class="number">10</span>)</div><div class="line">	<span class="keyword">case</span> _   =&gt; sign = <span class="number">0</span></div></pre></td></tr></table></figure>
<p>第三句就是加入了一个守卫。注意，守卫出现在动作的前面。另外，模式匹配是从上到下执行的，遇到成功的匹配就跳出余下的匹配。</p>
<p>注意Scala的命名模式。Scala的变量以小字字母开始。大写字母开头的符号表示的是一个常量。如果一个常量以小写字母开头，那么必须在使用的时候前后加上左单引号。</p>
<p>表达式的类型也可以参与匹配：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">obj <span class="keyword">match</span> &#123;</div><div class="line">	<span class="keyword">case</span> x : <span class="type">Int</span> =&gt; x</div><div class="line">	<span class="keyword">case</span> s : <span class="type">String</span> =&gt; <span class="type">Integer</span>.parseInt(s)</div><div class="line">	<span class="keyword">case</span> _ : <span class="type">BigInt</span> =&gt; <span class="type">Int</span>.<span class="type">MaxValue</span></div><div class="line">	<span class="keyword">case</span> _ =&gt; <span class="number">0</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里相当于添加了类型限定符。模式匹配在语法上是比较一致的。但是因为匹配的变量、常量、类型、实例类的不同，有些语句可能在编译器就决定了，有些可能被推迟到生成运行期的匹配的代码。</p>
<p>模式匹配与apply/unapply的用法之间已经介绍过了。但是模式匹配还可以用于变量的声明，以及用在for循环当中。所有这些，都应当视为学习模式匹配的重点。</p>
<h3 id="偏函数">偏函数</h3>
<p>在模式匹配语句没有在所有的情况下有定义的时候，很容易导致偏函数。在Scala中，任何一个偏函数，类型是<code>PartialFunction[A,B]</code>。偏函数就是不在所有的位置都有定义的函数。使用偏函数的时候，如果使用得不恰当，会自动抛出异常。</p>
<h2 id="scala的注解特性">Scala的注解特性</h2>
<p>目前了解到，注解可以以不同的方法实现就可以了。而且在Scala中，注解可以为类、方法、字段、局部变量、参数、表达式、类型参数以及各种类型定义添加注解。这样的多种多样的注解，可能导致我们无法简单地使用高阶函数来统一理解注解。</p>
<p>Scala不同的一点在于，Scala的注解可以影响编译的过程。通过注解，可能往类里面自动地添加一些方法。在Scala中，注解是<code>annotation.Annotation</code>的扩展。而注解可以有不同的类型，如<code>StaticAnnotation</code>、<code>ClassfileAnnotation</code>等。</p>
<p>Scala的注解广泛用于和Java的互操作、优化执行。以及添加额外的检查，实现条件编译等。</p>
<h2 id="scala的泛型类型参数">Scala的泛型，类型参数</h2>
<p>Scala的类、特质、方法、函数都可以有类型参数。类型参数放在名称的后面，用中括号括起来。可以使用类型界定<code>&lt;:</code>等。</p>
<p>类型界定的重点集中在隐式类型转换与自动类型推导上。</p>
<p>Scala的类型系统还是比较复杂的。包括类与特质、元组类型、函数类型、带注解的类型、参数化类型、单例类型、类型投影、复合类型、中置类型、存在类型等。但是一般而言，这么多类型强调的是对于不同情况的适应，而非建立类型系统的一般的框架。所以我们先跳过对于Scala的类型系统、类型运算关系的介绍。但是实现依赖注入、抽象类型等的时候，我们可能必须返过来仔细阅读有关Scala类型系统的介绍。</p>
<p>与面向对象中的继承、多态（特别是多态）混合的时候，类型系统变得更复杂。</p>
<p>学过Haskell我们就知道类型构造器与数据构造器。实际上，Scala语言也有这样的概念。不过，相关的概念放在编译器特性当中了。这使得我们在学习Scala编译器系统的时候才能比较全面地看待Scala的类型系统。</p>
<h2 id="scala的解析器库">Scala的解析器库</h2>
<p>Scala的解析器库是编写内部DSL的一个非常好的应用（注意，内部DSL虽然是离不开宿主环境的，但是仍然是从字符串中读取内容，否则就不是DSL了）。</p>
<p>Scala的DSL的实现非常优雅，得益于它的操作符系统，以及正则表达式匹配。原则上我们也可以用操作符机制来自己写解析器库，但是Scala的解析器库提供了一个高级的选择。</p>
<p>学习解析器生成自然是每个编程者的目标，但是目前自己的困境是没有理解DSL领域的一般的实践的规则。也就是说，写DSL有哪些实践，又有哪些应用，哪些应用是常见的。我们不是任意地写一个解析器，然后生成一个不成熟的实践。</p>
<h2 id="scala的编译器09-11-2015-230738-cst">Scala的编译器[09-11-2015 23:07:38 CST]</h2>
<p>现在Scala的编译器是github上面的一个项目。在Scala项目中，Scala语言本身占了很多。其实是5.9%的Java语言和少部分的Python与Shell语言。</p>
<p>另外，安装sbt请参考<a href="http://www.scala-sbt.org/0.13/tutorial/Installing-sbt-on-Linux.html" class="uri" target="_blank" rel="external">http://www.scala-sbt.org/0.13/tutorial/Installing-sbt-on-Linux.html</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/02/150702-进程控制/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/02/150702-进程控制/" itemprop="url">
                  Scala编程概要（三）：进程控制与shell，函数式特性
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-07-02T00:00:00+08:00">
                2015-07-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:19+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/07/02/150702-进程控制/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/02/150702-进程控制/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>应该说，这种特性是可以让人大吼大叫的。简单的示例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys.process._</div><div class="line"><span class="string">"ls -al .."</span> !</div></pre></td></tr></table></figure>
<p>之所以可以这样做，是因为sys.process包含一个从字符串到ProcessBuild对象的隐式类型转换。注意后面的<code>!</code>号操作符，以ProcessBuild类型为参数类型，返回的是被执行程序的返回值。如果需要返回的是程序的输出的字符串，可以使用<code>!!</code>代替<code>!</code>号。</p>
<p>如果需要把程序通过管道，scala支持使用<code>#|</code>运算符。比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="string">"ls -al .."</span> #| <span class="string">"grep sec"</span> !</div></pre></td></tr></table></figure>
<p>这样显然具有优势，因为让scala可以编译检查程序的结构。除此之外，scala的运算符还有重定向<code>#&gt;</code>、<code>#&gt;&gt;</code>，<code>#&lt;</code>等。如下面的示例：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys.process._</div><div class="line"><span class="string">"ls -al .."</span> #&gt;&gt; <span class="keyword">new</span> <span class="type">File</span>(<span class="string">"output.txt"</span>) !</div><div class="line"><span class="string">"grep Scala"</span> #&lt; <span class="keyword">new</span> <span class="type">URL</span>(<span class="string">"http://horstmann.com/index.html"</span>)</div></pre></td></tr></table></figure>
<p>这种特性确实是不错，貌似比Shell还要更强大一些。</p>
<p>注意<code>!</code>表示返回的结果，是一个整型的值而已。另外，Scala中的流程控制语句有<code>p #&amp;&amp; q</code>表示p成功则执行q，<code>p #|| q</code>表示p不成功则执行q。（一个规则是，相对于原来的shell操作符，我们只需要在前面加上一个<code>#</code>号就是scala脚本的操作符，而且与原来的shell操作符具有相同的优先级。</p>
<p>至于正规的方法，则是构造相应的Process对象，然后使用<code>!</code>操作符执行它。比如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> p = <span class="type">Process</span>(cmd, <span class="keyword">new</span> <span class="type">File</span>(dirName), (<span class="string">"LANG"</span>, <span class="string">"en_US"</span>))</div><div class="line"><span class="string">"echo 41"</span> #| p !</div></pre></td></tr></table></figure>
<p>有兴趣的话，可以参考一下。因为scala提供了一个快速构建器<code>fsc</code>，所以shell的执行的速度也不是问题。</p>
<h2 id="scala中的正则表达式">Scala中的正则表达式</h2>
<p>正则表达式分析使用<code>scala.util.matching.Regex</code>类。在scala中，可以使用<code>&quot;&quot;&quot;...&quot;&quot;&quot;</code>作为原始的字符串，里面的符号不进行转义（与Python还有一些不同）。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> numPattern = <span class="string">"[0-9]+"</span>.r</div><div class="line"><span class="comment">/* 构造正则表达式对象，使用字符串的.r方法</span></div><div class="line"> * 该方法是在scala.util.matching.Regex中定义</div><div class="line">*/</div><div class="line"><span class="keyword">val</span> wsnumwsPattern = <span class="string">""</span><span class="string">"\s+[0-9]+\s+"</span><span class="string">""</span>.r</div><div class="line"></div><div class="line"><span class="comment">//然后使用findAllIn, findFirstIn等方法来匹配字符串</span></div><div class="line"><span class="keyword">val</span> m1 = wsnumwsPattern.findFirstIn(<span class="string">"99 bottles, 98 bottles"</span>)</div><div class="line"></div><div class="line"><span class="comment">//或者使用replace来替换字符串</span></div><div class="line"><span class="keyword">val</span> m2 = num.replaceFirstIn(<span class="string">"99 bottles, 98 bottles"</span>, <span class="string">"xx"</span>)</div></pre></td></tr></table></figure>
<p>为了使正则表达式有提取的功能，可以使用PCRE中的字符串分组。比如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> numitemPattern = <span class="string">"([0-9]+) ([a-z]+)"</span>.r</div><div class="line"><span class="keyword">val</span> numitemPattern(num, item) = <span class="string">"99 bottles"</span></div><div class="line">num == <span class="string">"99"</span></div><div class="line">item == <span class="string">"bottles"</span></div></pre></td></tr></table></figure>
<p>这样，编程实践中的系统调用接口、正则表达式，文件IO、XML我们就都已经提到了。</p>
<h2 id="scala中的特质">Scala中的特质</h2>
<p>相当于java中的interface，但是进行了一些哲学的修正。比如使用<code>with</code>，表示的含义是“一个类与其它的特质运算，得到新的类，然后由某个类来继承它”。</p>
<p>但是在scala中，特质可以包含具体的实现的方法。java的接口是不能做到这一点的。但是求是地看，让特质具有具体的行为之后，如果特质发生了改变，所有的混入了该特质的类都必须重新编译。</p>
<p>特质在处理日志、异常处理的时候也占有一席之地，甚至还是一种不错的解决办法。另外一种解决日志与异常处理的任务的方法是使用高阶函数。虽然直观上，显然高阶方法与注解器更为高级（其中高阶函数更高级）。由此我们大概可以抽象出异常处理的几种编程的模式，或者甚至是理论。</p>
<p>如果想要使用特质来处理日志与异常处理，那么就需要仔细阅读Scala中有关特质、特质扩展类、自身类型（self type）的一些知识点。</p>
<h2 id="scal中的操作符07-02-2015-102653">Scal中的操作符[07-02-2015 10:26:53]</h2>
<p>摘自《快学Scala》中的教程。对于Haskell之类的操作语言，理解操作符的使用是很自然的事情。因为在这样的语言中，计算被移到语言的更后端的层次，而在C语言一类的命令式语言中，操作符被当成是编译器语法的一部分，直接写在语言里。显然是后者更好。但是这两种方式的不同，也给学习新的语言造成了一些障碍。</p>
<p>Scala中的操作符的使用与语法的解析是没有关系的。我们参考Scala的语法的手册就可以知道。所以操作符的使用带来了比较大的灵活性。</p>
<p>Scala中的标识符与操作符的重载是实现内置领域特定语言的一个重要的方式。前面我们提到了<code>sys.process._</code>也可以看成是DSL的一类。</p>
<p>在Scala中，命名采取统一的规则，变量，函数、类的名称都统称为标识符。编译器不再对标识符作进一步的语法使用上的区分。在Scala中，选择标识符是比较自由的。还可以使用unicode，或者其它的非空白符。</p>
<p>在Scala中，可以作为操作符的字符是相当多了，除了一些语法上的禁忌之外。比如三种括号已经有特定的含义了，我们不能重载为操作符。但是苦寒经的ASCII字符与Unicode的数学符号都可以作为操作符（注意不是所有的Unicode符号，只有Unicode的数学符号这一类）。</p>
<p>另外，Scala使用左单引号括起来的部分作为一个单独的标识符（就像latex的<code>\csname ... \endcsname</code>一样。这使得在单引号里面，几乎所有的字符都可以当成是标识符。</p>
<p>在Scala中，任何一个带有两个参数的方法都可以写成是<code>a 标识符 b</code>的形式。Scala也知道这是一个二元方法调用。要注意的是，中间的方法必须以<code>a.method(b)</code>的形式声明。所以<code>a op b</code>表示op是a的一个方法，这个方法的参数是b。</p>
<p>另外，由于操作符也可以使用<code>-&gt;</code>这样的名子，所以就实现了操作符的方法调用。</p>
<p>类似于二元操作符的是后置的操作符，后置的操作符实际上是一个类的无类的方法。比如<code>1 toString</code>。这两种约定是自然的语法糖特性，没有什么特殊的。</p>
<p>值得注意的是对于前置一元操作符的处理。前置的一元的操作符实际上调用的是相应的<code>unary_op</code>方法。比如<code>-a</code>实际上调用的是<code>a.unary_-</code>方法。在操作符中，有些以<code>=</code>号结尾的操作符具有特定的赋值的含义，所以我们不应该在操作符中使用<code>=</code>号，除非我们在语义上有赋值区需求。当然，我们实际上可以自定义具有<code>=</code>号的操作符，scala也会认识相应的方法。但是一般而言，还是尽可能保持等号的特殊的含义。</p>
<p>在Scala当中，操作符的优先级是预定义好的，由操作符的首字母来决定，有些语言，如OCaml当中，操作符的优先级的次序是我们可以自己指定的。但是这种方法在Scala中不适用。除了赋值操作符之外，Scala的优先级由操作符的首字母来决定。也就是按照各个字符的列表来确定操作符。操作符有三类，中置操作符、后置操作符，前置操作符。统一的规定是，中置操作符优先级高于后置的。</p>
<p>在具有相同的优先级的时候，操作符的结合性才发挥作用。在Scala中，用户定义的所有的操作符都是左结合的操作符（大多数代数运算均如此）。而在内置语言中，以冒号结尾的操作符以及赋值操作符是右结合的。这样，自然而然地，构造列表的<code>::</code>操作符是右结合的。</p>
<p>对于右结合的二元操作符<code>a rop b</code>，调用的方法是<code>b.rop(a)</code>。即方法属于后一个类，不是属于前一个类。</p>
<h3 id="函数调用方法扩展">函数调用方法扩展</h3>
<p>语法特性<code>f(arg1, arg2, ...)</code>不只是用于直接定义的函数的调用与语法。它们也可以用于函数之外的值。除了函数与方法调用之外，这种形式的语法还被当成是<code>f.apply(arg1,arg2)</code>的语法糖。而<code>f(arg1, arg2, ...) = value</code>这种形式，还对应于如下调用<code>f.update(arg1, arg2, ..., value)</code>。即这种语法是一个语法糖。Scala在遇到这样的符号的时候会自动查询函数调用、方法调用，以及apply方法。</p>
<p>为什么需要使用apply方法？答案是，在Java当中，创建新的对象都要使用new方法。但是这种方法对于不变对象而言是非常不好的。所以，一般而言，都在类的伴生对象中定义一个apply方法，这个apply方法的实现是<code>new ClassName(args)</code>这样的形式。（这样可以直接使用<code>ClassName(args)</code>来构造一个类的对象。（另外，实例类也具有类似的效果）。使用apply方法来构造一个对象，可以看成是Scala的一个设计模式。</p>
<p>unapply方法，看起来很违背常识。但是在编程语言的世界中，尤其是函数式语言的世界中，一个apply方法就是一个把参数变成对象的一个映射（其实是附带算子的），所以，自然而然地，我们考虑参数的逆映射，也就是把一个对象分解成构造它的时候的参数。unapply方法在模式匹配的时候特别有用。比如，我们要匹配对象<code>Fraction(a,b)</code>的时候，必然需要从对象中找到<code>a</code>和<code>b</code>的值。这个时候就需要<code>unapply</code>方法（从而我们知道，模式匹配并不是什么神奇的东西，本质上就是一个方法调用，这个方法调用把一个类变成相应的值）。当然，模式匹配不仅要从对象中解出来值，还要检查对象的类型。但是至少从对象中提取出来值这部分，是通过<code>unapply</code>方法完成的。</p>
<p>注：这里我们对模式匹配要做的工作有了进一步的认识。但是同时要指出，模式匹配的时候，还是要处理额外的一些问题，比如模式匹配如果失败了怎么办？一般而言，这需要一种处理不确定性的方法。比如，返回的值可能是<code>Maybe(3,4)</code>这样的形式（在Scala中，是Some((3,4))这样的形式）。</p>
<p>注：Scala的实例类case class自动地生成apply与unapply方法。实际上，Scala的unapply还被用于实现其它的许多的功能。比如说，赋值语句的模式匹配，如<code>val Number(n) = &quot;1729&quot;</code>，可以把整数<code>1729</code>的值赋给<code>n</code>。等等。详细可以参考《快学Scala》当中的第十一章操作符的最后一节。</p>
<p>注：使用提取符实际上已经可以构造一个表格的DSL，就像LaTeX那样。所以也许我们该来试验一下。比如在表格里面通过运算符重新构造出HTML或者LaTeX格式的表格。</p>
<p>下面是自己写的一个测试用例，允许用户使用<code>Table() | &quot;abc&quot;</code>这样的形式构造表格。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span>(<span class="params">var elem : <span class="type">String</span></span>) </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">|</span></span>(element : <span class="type">String</span>) = <span class="keyword">new</span> <span class="type">Table</span>(elem + <span class="string">"&amp;"</span> + element)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">||</span></span>(element: <span class="type">String</span>) = <span class="keyword">new</span> <span class="type">Table</span>(elem + <span class="string">"\n"</span>+element)</div><div class="line">&#125;</div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Table</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(e:<span class="type">String</span>) = <span class="keyword">new</span> <span class="type">Table</span>(e)</div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">unapply</span></span>(input: <span class="type">Table</span>): <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">Some</span>(input.elem)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> t = <span class="type">Table</span>(<span class="string">"abc"</span>) | <span class="string">"String"</span> </div><div class="line">println(t.elem)</div><div class="line"></div><div class="line">t <span class="keyword">match</span> &#123;</div><div class="line">    <span class="keyword">case</span> <span class="type">Table</span>(e) =&gt; println(<span class="string">"Succeed: "</span> +e) </div><div class="line">    <span class="keyword">case</span> _ =&gt; println(<span class="string">"failed"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意，第一点是把伴生对象中定义apply与unapply方法。第二是unapply的返回类型是<code>Option[TYPE]</code>，而且返回的值要用<code>Some(VALUE)</code>代替。这样才能得到正确的值。自己是尝试写这样的代码，肯定还有一些缺陷。等以后再来写一个完整的表格分析工具。</p>
<p>总结：本小节尝试的是操作符与模式匹配的构建。</p>
<h2 id="高阶函数的使用">高阶函数的使用</h2>
<p>其实是这一种思维方式的训练。函数式语言编程中广泛使用这些方法。具体来说的模式有：把函数作为值来返回；需要的时候直接定义一个表达式作为函数；以及使用通配符来实行柯里化；函数式语言的控制抽象等。其中有一些课题明显是所有的高级语言的共性，比如说控制抽象。</p>
<p>Scala的高阶函数的机制引入了类型推导的概念。不然我们在构造高阶函数的时候，将写出大量的类型声明代码。</p>
<p>匿名函数的语法是<code>(x : Doube) =&gt; 3 * x</code>。注意使用<code>=&gt;</code>来表示计算（因为不同的语言实现<span class="math inline">\(\lambda\)</span>-函数的方式都有所不同。可以把这个函数赋给一个变量。变量自然是有类型的。如果有可能，我们还可以让一个变量指向不同的函数。</p>
<p>高阶函数在编程语言中，往往被看成是轻量级的函数。第一个是作用域可以非常局部，比如说，直接在map的参数当中生成，第二是其意义往往只有一次，比如说，让一个数组增加三倍，并不值得先单独写一个乘以3的函数，然后慢慢传过去。</p>
<p>注意在语法上<code>Array(3,4).map((x:Double) =&gt; 3 * x)</code>的效果，可以用<code>Array(3,4).map{ (x: Double) =&gt; 3 * x}</code>以及<code>Array(3,4) map { (x:Double) =&gt; 3 * x}</code>来代替。至少使用大括号使得层次更加明显。另外，其实这里的<code>(x:Double) =&gt; 3 * x</code>可以换成更简单的<code>3*_</code>这个匿名函数。</p>
<p>在数值计算中，高阶函数的使用也有一些意义。比如我们有一组函数，需要求出一组函数在某个点处的值。这个时候使用map当然是最直观的。但是使用</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> valueAt = (f: (<span class="type">Double</span>) =&gt; <span class="type">Double</span>, x : <span class="type">Double</span>) =&gt; f(x)</div><div class="line">valueAt(<span class="number">3.0</span>+_, <span class="number">1.0</span>)</div></pre></td></tr></table></figure>
<p>这样的形式显然更为简单。</p>
<p>注：上式中我们还了解了多参数的匿名函数的语法，以及把函数作为参数的用法。如果有可能，我们还可以写出<code>f at 1.0</code>这样的中缀的形式。是否是很吸引人呢？</p>
<h3 id="常见的高阶函数">常见的高阶函数</h3>
<p>很多的高阶函数都应用的集合类型上面。常见的有map、foreach、filter、reduceLeft等。这里在处理数据的时候我们再来了解。</p>
<p>《快学Scala》的作者还提到了闭包。不过，闭包是任何的编程语言的结构体的共同的特性。本质是如果变量没有在这个过程体中定义，或者是在调用的上下文中并没有原来的变量的值的时候，在过程体中的变量的值该如何绑定。比如说，定义函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">scale</span><span class="params">(x)</span> :</span> x*factor</div></pre></td></tr></table></figure>
<p>当中，实际上factor没有出现在函数体中。那么factor一般是一个外部变量。但是关键的是，如果编译器遇到它的时候，在要执行scale的时候，factor该怎样取得值呢？这种问题就是所谓的闭包。</p>
<p>当然，在scala的匿名函数完成是可以使用闭包的。调用的时候，闭包内的变量被绑定到调用的时候的作用域所确定的同名子的变量。这也是闭包的标准的使用策略。基本上任何语言都是这样。</p>
<p>闭包应该属于编程理论中的“名子，作用域”中讨论的一个概念。它并非是函数式语言所特有的。但是在函数式语言中，闭包的使用更加重要。</p>
<h3 id="沟通函数式语言与命令式语言的编程任务">沟通函数式语言与命令式语言的编程任务</h3>
<p>我们在函数式语言中，知道函数可以像变量一样赋值，这样可以完成非常强大的任务。但是对于那些函数式不是一等公民的语言中，怎么样才能完成同样的任务呢？</p>
<p>非面向对象的语言有自己的方法。比如C语言可以通过指针把函数传递过去。但是考虑到封装的要求，这样也许不是一个好的办法（虽然C语言也支持源文件级别的封装等。</p>
<p>面向对象的语言的通行的做法，根据《快学Scala》中的介绍，是这样的，为了把一个函数参数传给另外一个函数或者对象，我们得把相关的动作方法放在一个实现某个接口的类当中，然后将该类的一个实例传递给另一个方法。当然，这种方法与函数式语言通用性相比还存在一些缺陷。比如在Java中，类是由编译期确定的，所以我们不能在运行期创建新的函数。仅仅为了封装单个方法而设计的接口我们称为是SAM（single abstract method）类型。（这也是Java程序员的叫法）。</p>
<p>在事件驱动与GUI上面，比如为了使按钮在被点击的时候递增一个计数器，我们使用：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> counter = <span class="number">0</span></div><div class="line"><span class="keyword">val</span> button = <span class="keyword">new</span> <span class="type">JButton</span>(<span class="string">"Increment"</span>)</div><div class="line">button.addActionListener(<span class="keyword">new</span> <span class="type">ActionListener</span> &#123;</div><div class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">actionPerformed</span></span>(event: <span class="type">ActionEvent</span>)&#123;</div><div class="line">		counter += <span class="number">1</span></div><div class="line">	&#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这当然是一段比较长的代码。而且非常冗余。因为我们只是要让计数器加一这个函数传递过去而已。一个比较合理的做法是这样的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.addActionListener((event : <span class="type">ActionEvent</span>) =&gt; counter +=<span class="number">1</span>)</div></pre></td></tr></table></figure>
<p>我们注意到，面向对象的语言中，很少提到动态创建那些有新的方法的未知的类。动态类型的语言中能够做到这一点，自编译的语言也可以。但是似乎面向对象的实践中从来没有认真考虑过在运行的时候创建具有新的方法与成员的类。</p>
<p>在上面的转换代码中还应当注意，在函数式语言中添加一个函数是完全没有问题的。但是Scala有自己的情况：要使得代码能够与Java代码互操作。所以，在Scala中，为了启用上面的语法，还是需要提供一个隐式类型转换函数。示例如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">makeAction</span></span>(action: (<span class="type">ActionEvent</span>)=&gt; <span class="type">Unit</span>) = </div><div class="line">	<span class="keyword">new</span> <span class="type">ActionListener</span> &#123;</div><div class="line">		<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">actionPerformed</span></span>(event: <span class="type">ActionEvent</span>) &#123; action(event)</div><div class="line">&#125;</div><div class="line">`</div></pre></td></tr></table></figure>
<p>这样做的实际结果，还是使得在函数式的代码在编译的时候，被转换成一个新的类。（不过，这个类似乎是在可以运行的时候动态创建的）。</p>
<h3 id="柯里化函数">柯里化函数</h3>
<p>在Haskell语言中，所有的函数都是自动柯里化的。Scala是函数式的语言，自然应当提供对于柯里化支持。在Scala中，柯里化的函数有自己的定义的语法，比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul</span></span>(x: <span class="type">Int</span>)(y:<span class="type">Int</span>) = x*y</div></pre></td></tr></table></figure>
<p>柯里化函数式多个参量的函数的互换也经常使用（柯里化与反柯里化）。在一些需要传递高阶函数的地方，经常需要从已有的函数构造柯里化函数。如前所说，我们已经使用<code>_</code>来构造柯里化函数了。</p>
<p>至于Scala中有没有反柯里化，自己现在不太清楚。但是原则上，Scala应该禀承函数式语言的一贯的思维，认为多参数的函数根本不是编程语言中什么根本性的特质。我们完全可以把多参数的函数看成是一个单参数的函数的多次应用，正如我们在数学当中看到的那样。只提供多参数的函数的参数的一部分，是非常自然的数学思维，也应该成为编程的一种思维。</p>
<p>《快学Scala》中给出了一个常见的编程的实践：我们想测试两个序列在给定的某个对比的条件下是否是相同的。这里使用的是corresponds函数。使用示例是一个判断字符串序列在忽略大小写的意义下是否是等同的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a = <span class="type">Array</span>(<span class="string">"hello"</span>, <span class="string">"world"</span>)</div><div class="line"><span class="keyword">val</span> b = <span class="type">Array</span>(<span class="string">"Hello"</span>, <span class="string">"World"</span>)</div><div class="line">a.corresponds(b)(_.equalsIgnoreCase(_))</div></pre></td></tr></table></figure>
<p>分析这个编程任务，我们知道，本质上还是两个对象之间的比较，所以应该有一个二元的函数。但是我们又需要在某个标准下面才能得到结果。因此，二元运算不是得到true或者false，而是还得接受一个提供判别标准的函数。所以，corresonds的类型是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">corresponds</span></span>[<span class="type">B</span>] (that: <span class="type">Seq</span>[<span class="type">B</span>]) (p:(<span class="type">A</span>,<span class="type">B</span>) =&gt; <span class="type">Boolean</span>) : <span class="type">Boolean</span></div></pre></td></tr></table></figure>
<p>定义了这样的一个柯里化的函数，这种设计既保持了语义的自然，实现起来也比较简洁。但是注意，这里的corresponds是<code>Array[B]</code>类别中预定义的函数，所以使用<code>a op b</code>这样的形式是没有问题的。但是，如果我们想使两个Double型的变量具有<code>a add b</code>这样的调用形式，那么原则上我们要为Double类添加一个<code>add</code>方法，但是这可能又要修改Scala的库，所以可能是不能实现的。（因为要保持这个类，同时又能为类单独添加新的方法，似乎是一种矛盾）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/01/150701-Scala基本语句/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/01/150701-Scala基本语句/" itemprop="url">
                  Scala编程概要（二）：基本结构，常用模式
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-07-01T00:00:00+08:00">
                2015-07-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:18+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/07/01/150701-Scala基本语句/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/01/150701-Scala基本语句/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>设计模式在软件编程的各个方面都有应用。MVC与分布式一般算成是架构模式，而写文档注释也有一定的模式可以遵守。另外，我们也可以设计出一些使用的模式，以便在开发软件之后，可以让用户按照指定的模式使用软件。</p>
<h2 id="scala的for语句">Scala的for语句</h2>
<p>在scala当中，for并不是经典的控制流语句而已。在for里面可以加一些过滤器，同时，也可使用yield来生成一个集合。这种控制语句应该是与Map-Reduce相互配合的。而且为了支持新的范式，也需要修改for语句的行为。</p>
<p>对于非递归的函数，scala不需要指定返回的类型。这是因为，虽然hindley-Milner算法能够推断出递归函数的返回的类型，但是在面向对象的语言中却并不是总是可以行得通的。所以，在处理递归函数的返回类型上，Scala并没有使用Hindley-Milner类型推断算法。</p>
<p>另外，Scala的函数参数也可以使用默认参数，或者使用变长的参数（变长的参数的处理与Java是类似的）。</p>
<p>不返回值的函数，一般都是使用Unit作为返回类型。</p>
<p>Scala中捕获异常可以采用模式匹配的方法。这比Java精简了不少。</p>
<p>另外，在数据流编程当中，一种方法是使用if守卫加上yield和for产生序列，比如<code>for (elem &lt;- a if elem % 2 == 0) yield 2 * elem</code>。但是对于函数式语言实践而言，最经常使用的是filter-map-reduce的方法，比如<code>a.filter( _ % 2 == 0).map(2*_)</code>或者甚至是<code>a.filter { _ % 2 == 0 } map { 2 * _ }</code>这样的序列化的形式。另外，很大一部分时间编程语言都是在做查找和排序的操作。这种情况下，Scala对数组采用了很多的方法。比如整型数组的<code>Array(1,2,3,4,5).sum</code>方法，以及<code>ArrayBuffer(1,7,2,9).sorted(_&lt;_)</code>方法。</p>
<p>在类型系统比较丰富的语言中，不熟悉类型系统的编程者可能觉得语法很奇怪。不过，其实也没有什么好奇怪的。学完类型系统就会觉得是自然而然的。</p>
<h2 id="scala中的映射">Scala中的映射</h2>
<p>Scala中，其实又被称为字典，在Scala中称为哈希表。哈希表是应用非常广泛的数据结构。Scala用Map来记其名子。比如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> scores = <span class="type">Map</span>(<span class="string">"Alice"</span> -&gt; <span class="number">10</span>, <span class="string">"Bob"</span> -&gt; <span class="number">3</span>, <span class="string">"Cindy"</span> -&gt; <span class="number">8</span>)</div></pre></td></tr></table></figure>
<p>在Scala中，哈希表具有<code>Map(T1, T2)</code>这样的数据类型，而且这里的哈希表是不可变元素。要使用可变的映射，数据结构应该变成<code>scala.collection.mutable.Map</code>。或者要从头开始建立哈希表的时候，使用<code>scala.collection.mutable.HashMap[String, Int]</code>这样的形式。</p>
<p>在Scala中，函数与映射在语法上类似。比如<code>scores(&quot;Bob&quot;)</code>可以取到相应键的值。如果相应的键不存在，则抛出异常就可以了。另外，可以使用<code>score.contains</code>之类的方法检查映射中是否包含指定的键。另外，使用<code>getOrElse()</code>方法，可以执行，如果包含相应键就返回值，否则就返回一个指定的值的方法。</p>
<p>如果映射是可变的，可以使用<code>score(&quot;Bob&quot;) = 10</code>或者<code>scores(&quot;Fred&quot;) = 7</code>这样的语法来更新已有的键的值，或者创建一个新的键值对。或者使用<code>+=</code>方法来把新的关系加上去，如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">scores += (<span class="string">"Bob"</span> -&gt; <span class="number">10</span>, <span class="string">"Fred"</span> -&gt; <span class="number">7</span>)</div><div class="line">socres -= <span class="string">"Alice"</span></div></pre></td></tr></table></figure>
<p>对于不可变映射而言，不能重新赋值，但是可以通过<code>+</code>与<code>-</code>方法生成与原来映射相关的一个新的映射。假如不可变映射与一个<code>var</code>相关联，还可以重新给var赋值。虽然表面上看起来，创建新的映射效率比较低，但是实际上，函数式语言中正好相反。在函数式语言中，递归与不可变元素的使用反而是效率比较高的。取遍映射中的所有的键值对可以使用for方法，比如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> ((k,v) &lt;- 映射) 处理k与v</div></pre></td></tr></table></figure>
<p>之所以能够在for语句中实现这一点，主要是因为for语句里面能够模式匹配。另外，也可以使用<code>score.keys</code>与<code>score.values</code>之类的返回相应的键与值。总而言之，这是映射这种数据结构的通用的方法。</p>
<p>另外，要想混用Java与Scala中的映射，必须要经过一个类型转换。比如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.collection.<span class="type">JavaConversions</span>.mapAsScalaMap</div><div class="line"><span class="keyword">val</span> scores : scala.collection.mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Int</span>] =</div><div class="line">	<span class="keyword">new</span> java.util.<span class="type">TreeMap</span>[<span class="type">String</span>, <span class="type">Int</span>]</div><div class="line"></div><div class="line"><span class="keyword">import</span> scala.collection.<span class="type">JavaConversions</span>.propertiesAsScalaMap</div><div class="line"><span class="keyword">val</span> props : scala.collection.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">String</span>] = <span class="type">System</span>.getProperties()</div></pre></td></tr></table></figure>
<p>反过来的类型转换，提供的是相反的隐式类型转换的值。这时候导入的是</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> scala.collection.<span class="type">JavaConversions</span>.mapAsJavaMap</div></pre></td></tr></table></figure>
<p>另外一种常见的数据结构是元组。Scala的元组是一个多类型的参数类。另外，可以使用模式匹配来将元组中相应位置的值赋给相应的变量。元组的一个作用是通过具体的元组的部长乘积，构造出对偶的数组。比如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> symbols = <span class="type">Array</span>(<span class="string">"&lt;"</span>, <span class="string">"-"</span>, <span class="string">"&gt;"</span>)</div><div class="line"><span class="keyword">val</span> counts  = <span class="type">Array</span>(<span class="number">2</span>, <span class="number">10</span> ,<span class="number">2</span>)</div><div class="line"><span class="keyword">val</span> pairs = symbols.zip(counts)</div><div class="line"><span class="keyword">for</span> ((s, n) &lt;- pairs) <span class="type">Console</span>.print(s*n)</div></pre></td></tr></table></figure>
<p>在上面的式子中，pairs是如<code>Array((&quot;&lt;&quot;, 2), (&quot;-&quot;,10), (&quot;&gt;&quot;,2))</code>之类的有序组。对于二元序组来说，可以通过toMap方法将其转换成相应的映射。</p>
<p>注，在scala中，无参函数调用也不必带()，其实也许是因为本来函数与变量以及类的名子空间都是在同一个当中，所以，实际上，根据名子就知道它是函数，是变量还是方法，根本没有必要区分。而且，一个函数中实际上也可以带有相关的参数（惰性求值）。编译器如有可能，总是应该完成大部分的工作，应该具有常识，应该具有智能。</p>
<h2 id="scala中的类的使用">Scala中的类的使用</h2>
<p>Scala中的类的风格大部分是与Java相通的。但是Scala作为一种更高级的语言，应该使用那些支持的高级的特性来完成类的声明与定义。</p>
<p>对于getter/setter(取值器与改值器），有时候需要特别的处理，比如不允许改值。这种方式下，还是要使用private关键字来修饰变量，并且自己手动写getter/setter方法。注意，可以使用this来引用类的成员。在默认情况下，Scala为其每一个字段都提供getter/setter方法，除非成员被声明为private。要想查看Scalac到底生成了哪些代码，可以使用javap来查看生成的class文件。另外，其实getter/setter方法默认是与变量同名的一个无参函数。因此可以手工地使用<code>def age</code>来定义取到成员变量的一个值。</p>
<p>如果不允许类中的名子被修改，那么更好的办法是使用val代替var。</p>
<p>按照JavaBeans中的要求，所有的属性都要有<code>getFoo</code>与<code>setFoo</code>这样的方法。为此，可以使用scala中的<code>scala.reflect.BeanProperty</code>包提供的<code>@BeanProperty</code>修饰器，来完成相应的操作。具体用法是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">person</span> </span>&#123;</div><div class="line">	<span class="meta">@BeanProperty</span> <span class="keyword">var</span> name : <span class="type">String</span> = _</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样除了生成一般的方法之外，还生成getName与setName方法。此外，注解也可以以</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> (<span class="params">@<span class="type">BeanProperty</span> var name : <span class="type">String</span></span>)</span></div></pre></td></tr></table></figure>
<p>这样的方式被使用。</p>
<p>与Java一样，Scala中的类的构造器也可以有多个。不过，在Scala中，构造器的名子为<code>this</code>（在Java中就是类的同名的函数）。构造器有主构造器与辅构造器之分。我们可以通过某些方法指定。默认Scala会生成一个无参的主构造器。</p>
<p>Scala的设计者认为每敲一个键都是珍贵的，所以可以把主构造器与类定义结合在一起。也就是说，在定义类的时候，就可以定义传入类的相关的参数。如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> (<span class="params">val name : <span class="type">String</span></span>)</span>&#123;&#125;</div></pre></td></tr></table></figure>
<p>这样的紧凑形式。</p>
<p>另外，Scala也支持嵌套类的使用，使用的方式与java不太一样。</p>
<p>注：java中，#运算符代表的是一个类型投影，比如说，Network#Member，会得到Network中的嵌套类Member。</p>
<h2 id="scala中的对象">Scala中的对象</h2>
<p>scala中的对象直接实现了单件的模式。因为既然被定义为一个对象，那么所有的该对象的变量都是共同的操作。与类相比，对象只是没有有参构造函数，以及对象的构造器在该对象第一次被使用的时候调用。为了使类具有类似于静态方法的效果，可以给类定义一个伴生的对象。这个时候，类可以调用伴生对象的方法。不过，访问的时候必须显式地指明伴生对象。而且Scala中强制要求伴生对象的定义必须与类的定义放在一起。</p>
<p>对象的常用的方法是继承一个抽象类，并且实例化方法。比如，绿色是一种取特殊的值的颜色，那么绿色就成为一个对象。扩展了抽象类的方法。</p>
<h2 id="scala应用程序">Scala应用程序</h2>
<p>与Java一样，scala程序的运行是从一个对象的main方法开始。main方法的类型是<code>Array[String] =&gt; Unit</code>。除了直接写main方法之外，我们也可以自己扩展App特质，然后把程序代码放在构造器方法体内。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Hello</span> <span class="keyword">extends</span> <span class="title">App</span> </span>&#123;</div><div class="line">	println(<span class="string">"hello, World!"</span>)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还可以在App构造器内使用args.length得到参数的长度，以及得到相关的参数。应当注意，程序的体是放在App特定的构造器里面，所以println函数不用放在方法中，就好像是直接使用类的成员传递一样。</p>
<p>包管理是构造大型应用程序的一部分，属于封装。在Java中，包总是以绝对路径的方式被访问，但是在Scala中可以是相对路径。此外，包名可以放在不同的文件中。由于Java虚拟机的局限，包可以包含类、对象与特质，但是不能直接包含函数或者变量定义。为了解决这种困难，可以使用“包对象”的概念，也就是使用</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.horstmann.impatient</div><div class="line"></div><div class="line">pacakge <span class="class"><span class="keyword">object</span> <span class="title">people</span> </span>&#123;</div><div class="line">	<span class="keyword">val</span> defaultName = <span class="string">"John Q. Public"</span></div><div class="line">&#125;</div><div class="line"><span class="keyword">package</span> people &#123;</div><div class="line">	<span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">		<span class="keyword">var</span> name = defaultName </div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样的方式来定义一个包对象。由于Person类既在com.horstmann.impatient.people包的作用域中，而该作用域下定义了defaultName成员，所以可以在Person类中访问defaultName。</p>
<p>包以象是Scala的一个小把戏。在内部，包对象被编译成带有静态方法和字段的JVM类，名为package.class，位于相应的包下面。</p>
<p>另外，引入包的时候可以引入包中的所有的名称（使用下划线），也可以引入单独的名称（比如引用包中的一个类）。在Scala中，包引入可以放在任何作用域里面，不必放在文件的顶部。这样可以只在运行的时候才引用相应的包。Java程序员的实践比较依赖于IDE。因为他们不喜欢把包中的所有的对象都引入文件，而IDE正好可以让它们选择引用哪些包，并且为相应的引入生成长长的<code>import</code>语句。</p>
<p>如果要引入包中的几个对象，可以使用选取器，如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.awt.&#123;<span class="type">Color</span>, <span class="type">Font</span>&#125;</div></pre></td></tr></table></figure>
<p>或者重命名要导入的成员以解决可能的冲突</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.util.&#123;<span class="type">HashMap</span> =&gt; <span class="type">JavaHashMap</span>&#125;</div><div class="line"><span class="keyword">import</span> scala.collection.mutable._</div></pre></td></tr></table></figure>
<p>总而言之，在scala程序员中，把包中的所有的对象都导入进来是很普遍的。</p>
<h2 id="scala的面向对象的机制">Scala的面向对象的机制</h2>
<p>首先，scala的类的机制与java类似，另外，scala中重写一个非抽象的方法的时候必须使用override修饰符。</p>
<p>与java中一样，调用超类的方法也使用super关键字。</p>
<p>如果需要类型检查，可以按照如下的方式：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (p.isInstanceOf[<span class="type">Employee</span>]) &#123;</div><div class="line">	<span class="keyword">val</span> s = p.asInstanceOf[<span class="type">Employee</span>]</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意scala是静态的语言，所以运行期中的<code class="sourceCode python"><span class="bu">type</span>(a) <span class="op">==</span> <span class="bu">int</span></code>这样的代码显然是不容许的（即使容许，求值也会发生在编译期）。因此，使用了isInstanceOf作为一个有参数的构造器。与其直接使用类型运算符，在scala中，不如使用模式匹配这种轻量级的类型运算符。比如在检查变量的类型的时候，使用</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">p <span class="keyword">match</span> &#123;</div><div class="line">	<span class="keyword">case</span> s : <span class="type">Employee</span> =&gt; ...</div><div class="line">	<span class="keyword">case</span> _ =&gt; <span class="comment">//otherwise</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们或许可以把模式匹配看成轻量级的类型运算。另外，可能令人感到困惑的是，因为是静态类型，难道程序员不是知道所有的变量的类型了么？为什么还需要做检查变量的类型这样看起来无意义的工作呢？</p>
<h2 id="剩下的编程实践">剩下的编程实践</h2>
<p>一种编程语言有理论的部分和实践的部分两个大类。在理论的部分，几乎只能是执行某些计算。然而一个有实际意义的语言，通常的编程主题有文件Io、进程控制等。访问操作系统接口往往也是必要的。</p>
<p>文件的本质，在Haskell中显示的比较紧。但是在通常的编程语言中，理解的层次往往只是文件当成是一个可以随时读取的对象。随着读取的进行，每次都往前移动。现在我们知道，我们完全可以把文件当成是一个惰性数据结构。</p>
<p>随着软件产业的发展，有一些主题在编程语言中也变得流行起来。除了文件IO，访问操作系统函数接口之外，还有的普遍的操作有XML、序列化，异常处理等。</p>
<p>Scala的序列化来自于java.io.Serializable。但是在scala中，要声明一个类是可以序列化的，使用的方法是注解。比如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@SerialVersionUID</span>(<span class="number">42</span>L) <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Serializable</span></span></div></pre></td></tr></table></figure>
<p>注意，由于scala包直接包含了Serializable，所以不需要引入额外的序列化的包。另外，scala的所有的集合类都是可以序列化的。</p>
<p>注：自己在Python中曾看到“注解”或者装饰器其实就是一个高阶函数。并且，使用了注解后，每次调用这个类，这个类都与这个高阶函数相绑定。也许序列化函数也应该这样。虽然注解可能在语言习惯上不是太好，但是确实是非常有效。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/07/01/150701-Scala有关教程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/07/01/150701-Scala有关教程/" itemprop="url">
                  Scala编程概要（一）：文档，注释，面向对象
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-07-01T00:00:00+08:00">
                2015-07-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:18+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/07/01/150701-Scala有关教程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/07/01/150701-Scala有关教程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>虽然每次都是从头开始看Java与Scala的初级的教程，但是每次看的时候重点不一样，对于语言的理解也不一样。这一次的时候，强调的是，我们如何从初学者成为能够熟练运用一门语言的开发者？为了做到这一点，我们需要付出哪些努力？</p>
<p>现在的看法是这样的。第一，我们应该按照写书的方式写Scala的程序。所以，如何从应用程序中生成文档，以及介绍这个文档是最基本的。所以，在初学者的第一章的时候就应该学习使用scaladoc来写文档，以便能够注释出来自己所写的东西，表达出来自己所写的东西是什么样的意思。第二，或许是对于某些语言，使用REPL环境。但是学习一个语言可能更关键的是学习它适应的设计模式，与常见的实践，就像写学术文档一样写程序。</p>
<h2 id="scala的一些灵活的约定">Scala的一些灵活的约定</h2>
<p>Scala的语法是高度自动化的。第一是，方法与成员的用法看起来没有什么区别。尤其是，如果方法没有区别，那么方法可以不用带圆括号。这种情况下，与编程语言的文法本质更接近了一步：所有的出现的都是一个token，只是不同的token有不同的含义。比如<code>res2.toUpperCase</code>虽然看起来调用的是成员，但是实际上是一个方法。</p>
<p>第二是变量与常量的自动的声明。比如使用<code>val</code>与<code>var</code>，而不用带有复杂的类型声明，甚至不用知道类型是什么。不过，Scala与Python之类的还有区别。因为在Python中，运行期间可以得到一个成员的类型，并且把类型当成是一个变量。在命令式的语言中，使用变量自然是很正常的，因为使用常量，看起来也做不了什么有意义的事情（其实这种观念很可能是不正常的，因为在一定作用域的限制下，不使用变量也能够做很多的事情，特别是很多的数学计算，其实根本不需要使用变量）。不过，其实不使用变量而使用常量<code>val</code>也能完成很多的编程任务，而且似乎是更优雅。具体我们可以参考Scott的《程序设计语言实践之路》中对于名子、变量、作用域的介绍。</p>
<p>在Scala中，当然也可以强制变量类型声明。比如说，我们显然可以在变量后使用<code>val a : Int</code>的形式限定一个整型参数。另外，Scala中一行中存在多条语句的时候才需要使用分号隔开。</p>
<p>现在看来，学习Scala之前，确实是需要学习一些基础的知识。比如数据类型中的基本类型与引用类型。通过Scott的《程序设计语言实践之路》我们看到Java的数据类型的世界中，基本类型与其它类型的区别是明显的，因为基本类型返回的都是值方式，而用户自定义的类型，默认返回的都是一个引用。（这种规定不那么直观，但是在Java编程中却有着举足轻重的地位，决定了我们如何使用Java中的不同的数据类型）。此外，数组在Java中比较麻烦。但是Scala就不用考虑这一点。</p>
<p>总结：总而言之，学习一门编程语言的基础的时候，大概在学习一门语言的设计模式之外，第一步是了解编程风格。比如Scala，既然支持无参的方法不用括号，那么在Scala中，最好就不使用括号。这种风格更为简洁。在数据类型中，既然没有值类型与引用类型的复杂的区分，那么就不用考虑复制的问题，以一种更为函数式的风格思考问题。除此之外，还有一些复杂的问题，比如使用map-reduce风格。</p>
<p>总结：评价与了解一个编程语言，可能不再只是使用简单的类型的静态与动态、函数式编程或者其它的风格。其实，一般而言，评价一个东西，我们可以说一句话，可以说十句话，可以说一百句，可以说成一本书，也可以说成一套全集。关键是看我们描述的细的程度，仅一句话当然可以那么描写。但是要达到比较理想的层次，可能还需要一套详细的评价的方法。更进一步地，我们需要了解一门编程语言的特性可能包括以下的几个方面：最基础的方面，无论是函数式语言还是其它的语言，都要考虑抽象的问题，因为抽象是高级编程语言的共同的特性。这里面的主题就有名子，作用域，数据抽象，控制抽象等。第二步是所谓的编程语言的类型的系统。第三步是编程范式。然后是设计模式。经过这四个步骤，对于一个编程语言的理解或许就比较深了。至于前端的语法的知识，其实是比较形而下学的。</p>
<h2 id="scala文档风格07-01-2015-084018">Scala文档风格[07-01-2015 08:40:18]</h2>
<p>在没有考虑编程语言的任何特点的情况下写代码并不好，这个时候我们可以写注释。Scala的第一种的注释风格是这样的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** This is a brief description of what's being documented.</span></div><div class="line">  *</div><div class="line">  * This is further documentation of what we're documenting.  It should</div><div class="line">  * provide more details as to how this works and what it does. </div><div class="line">  */</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">myMethod</span> </span>= &#123;&#125;</div></pre></td></tr></table></figure>
<p>明显地，这种方法下，注释的整体就是一段文字，编程语言只知道注释是由几个段落构成的，而没有感知到其它的成份，所以生成的文档也很笨拙。虽然学术级别的写作要求非常高，以致于不可能单独在编程语言中讲到，但是其实注释是一种更深的艺术。只有明确地表达了自己的思维，所做的编程的工作才有意义。</p>
<p>如果是比较简单的类型，可以使用单行注释，示例如下</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Does something very simple */</span></div></pre></td></tr></table></figure>
<p>Scaladoc本身是一个完善的标记的语言。由于注释本身就是介绍文档的。所以，一方面，注释介绍了相应的数据结构的接口特性，另一方面是实现的特性。而且一般在文档当中，要把相应的编程结构的接口特性描述的更清楚一点。特别是把接口列出来。在Scala中，可以使用<code>@return</code>这样的标记来处理返回的值。doc文档的编写规范，可以参考<a href="http://docs.scala-lang.org/style/scaladoc.html" class="uri" target="_blank" rel="external">http://docs.scala-lang.org/style/scaladoc.html</a>。</p>
<h3 id="使用package的注释">使用package的注释</h3>
<p>在绝大多数的编程语言中，模块或者包或者库都是比面向对象更为高级的抽象。所以对模块的注释也显得格外地重要。在Scala中，包往往需要比较长的注释。一种方式是放在package的后面。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> parent.<span class="keyword">package</span>.name</div><div class="line"><span class="comment">/** This is the ScalaDoc for the package. */</span></div><div class="line"><span class="keyword">package</span> <span class="class"><span class="keyword">object</span> <span class="title">mypackage</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>另外一种方式是放在package当中。大块的注释，好像演化的趋势正是文学编程，以及使用markdown或者latex的风格。特别是在一些定理证明语言与Haskell这样的新的语言中，出现的在注释中插入代码的情况更加普遍。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> my.<span class="keyword">package</span></div><div class="line"><span class="comment">/** Provides classes for dealing with complex numbers.  Also provides</span></div><div class="line">  * implicits for converting to and from `Int`.</div><div class="line">  *</div><div class="line">  * ==Overview==</div><div class="line">  * The main class to use is [[my.package.complex.Complex]], as so</div><div class="line">  * &#123; &#123; &#123;</div><div class="line">  * scala&gt; val complex = Complex(4,3)</div><div class="line">  * complex: my.package.complex.Complex = 4 + 3i</div><div class="line">  * &#125; &#125; &#125;</div><div class="line">  *</div><div class="line">  * If you include [[my.package.complex.ComplexConversions]], you can </div><div class="line">  * convert numbers more directly</div><div class="line">  * &#123; &#123; &#123;</div><div class="line">  * scala&gt; import my.package.complex.ComplexConversions._</div><div class="line">  * scala&gt; val complex = 4 + 3.i</div><div class="line">  * complex: my.package.complex.Complex = 4 + 3i</div><div class="line">  * &#125; &#125; &#125; </div><div class="line">  */</div><div class="line"><span class="keyword">package</span> complex &#123;&#125;</div></pre></td></tr></table></figure>
<p>类的注释可以参考</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** A person who uses our application.</span></div><div class="line">  *</div><div class="line">  * @constructor create a new person with a name and age.</div><div class="line">  * @param name the person's name</div><div class="line">  * @param age the person's age in years </div><div class="line">  */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">name: <span class="type">String</span>, age: <span class="type">Int</span></span>) </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>不过，类的注释的内容与类的构造器的内容的注释如何安排其实也不是那么容易的。对象可以参考</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Factory for [[mypackage.Person]] instances. */</span></div><div class="line"><span class="class"><span class="keyword">object</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="comment">/** Creates a person with a given name and age.</span></div><div class="line">    *</div><div class="line">    * @param name their name</div><div class="line">    * @param age the age of the person to create </div><div class="line">    */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) = &#123;&#125;</div><div class="line">  <span class="comment">/** Creates a person with a given name and birthdate</span></div><div class="line">    *</div><div class="line">    * @param name their name</div><div class="line">    * @param birthDate the person's birthdate</div><div class="line">    * @return a new Person instance with the age determined by the </div><div class="line">    *         birthdate and current date. </div><div class="line">    */</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">apply</span></span>(name: <span class="type">String</span>, birthDate: java.util.<span class="type">Date</span>) = &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Scaladoc的注释规范，可以参考<a href="https://wiki.scala-lang.org/display/SW/Writing+Documentation" target="_blank" rel="external">Scala lang的维基</a>。</p>
<h2 id="scala的优势在哪里">Scala的优势在哪里</h2>
<p>首先，创建一个Person类，在Java中，代码是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String firstName;</div><div class="line">	<span class="keyword">private</span> String lastName;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span>    age;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String firstName, String lastName, <span class="keyword">int</span> age)</span> </span>&#123;</div><div class="line">	    <span class="keyword">this</span>.firstName = firstName;</div><div class="line">	    <span class="keyword">this</span>.lastName  = lastName;</div><div class="line">	    <span class="keyword">this</span>.age  = age; &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstName</span><span class="params">(String firstName)</span> </span>&#123; </div><div class="line">		<span class="keyword">this</span>.firstName = firstName; &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> String <span class="title">getFirstName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.firstName; &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastName</span><span class="params">(String lastName)</span> </span>&#123; <span class="keyword">this</span>.lastName = lastName; &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> String <span class="title">getLastName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.lastName; &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>但是在Scala中对于简单的getter与setter的支持下，简单的形式就是：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">var firstName: <span class="type">String</span>, var lastName: <span class="type">String</span>, var age: <span class="type">Int</span></span>)</span></div></pre></td></tr></table></figure>
<p>当然，这种方法添加的构造函数可以通过直接访问<code>Person.lastName</code>得到，看起来是直接访问了成员，但是其实是访问的构造器。不过，要想在构造器中添加一些日志的功能，还是得另外的配置。</p>
<p>要注意的是，Scala的类的实现中，不使用静态方法，取而代之的是可以直接定义一个相关的对象，通过这个对象直接产生一个相当于静态成员的东西。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/29/150629-人工智能与自举/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/29/150629-人工智能与自举/" itemprop="url">
                  用自举理解人工智能与学术研究
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-06-29T00:00:00+08:00">
                2015-06-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:17+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/06/29/150629-人工智能与自举/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/29/150629-人工智能与自举/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近人工智能在公众世界中变得很热。在各种技术应用铺天盖地的时候，肯定也有不少人在思考人工智能与人的思维的关系。在这里，我们首先关注的可能是这个很自然的问题：人工智能，或者干脆说智能机器，机器人，会不会取代人类。这里的取代，并不是说能够取代人的平常的工作，而是机器具有自主学习、自主决策的能力。完全不再需要人的干预。</p>
<p>本文的标题的前一半，就来尝试这个问题。至于后一半“理解学术研究”，比较具体。因为一直以来，科学研究活动都被视为是具有极高智力挑战的活动。同时，实际中的学术研究还是比较累的。单单做理论的工作，似乎很难合“学术共同体”的口味；而实践的工作，又上不了科学理论的台面。然而，科学活动的量级似乎越来越重。除了少数学科，如纯粹数学，研究方式变化没有那么大之外，几乎所有的科学都面临着数据处理的新的问题。“数据科学”，是否会成为所有的科学研究的基础？花费的代价越来越高的数值计算与模拟，是否越来越占据更大的份量？计算机在科学研究中的地位究竟是怎样的？</p>
<p>虽然<a href="http://en.wikipedia.org/wiki/Scientific_workflow_system" target="_blank" rel="external">科学工作流系统</a>、<a href="http://en.wikipedia.org/wiki/High-level_architecture" target="_blank" rel="external">高级体系结构</a>、科学数据可视化等对于提高相关活动的效率有极大的帮助，但是在自动化的层面似乎做的还不够好。我们肯定希望，如果有可能的话，编写数据处理的小脚本、可视化数据、甚至是选择计算环境等工作都能够分离出来，让我们有时间专心去思考某些问题，而不是花在没有什么含量的技术操作上。进一步地，许多活动该由计算机来做，比如计算机发现新的物质结构，由计算机来总结科学数据集中的结构，甚至是能够发现复杂的方程与约束的条件。最明显地，我们研究生是否能够花更多的时间在学术研究上，而不是花大量时间在做项目，做产品，或者是为理论找到一个合适的验证的平台上？</p>
<p>本文这里尝试概要地理解问题的实质。受到计算机知识中的“自举”的启发，个人觉得，其实这两个问题在逻辑上的困境才是当前阻挡理解这个问题的关键。“自举”一个是指一个人在不借助于任何外力的情况下把自己提离地面。在机器是否超越人类，以及更具体的，让机器代替人进行科研活动创新的时候，类似的逻辑阴影似乎总是存在。“世界是满的”，个人相信肯定早就有人思考过这个问题。不过，其实花了一个下午来克服自己认识的局限效率还是要高一些。如果有类似的读物，可以<a href="kailto:irhawks@163.com" target="_blank" rel="external">发送邮件到这里</a>。</p>
<h2 id="问题抽象">问题抽象</h2>
<p>直接面对两个问题中的任何一个，都会使人产生思维上的困惑。很多时候，我们不知道在这样的语境下该如何走。这种情况可能是由于问题与我们自身的生活体验、生活环境、生存利益等太过相关，以至于不可能单独出来看问题。没有足够的证据，但是我们也可以合乎逻辑地说，从神经质一直到经历了许多社会变迁的老人，都不可能对任何事情都有完全客观的看法，在这种看法中，不掺杂任何主观的成份。很明显，因为我们都相信，人无完人。</p>
<p>所以人类就有意或者无意地避开冲突领域。以一种抽象的、甚至与直接问题完全不相干的方式间接地解决问题的策略就被广泛使用了。大概哲学在解决问题的时候有一种抽象，甚至在任何创造性的活动中，都必须避开问题中某些特殊的语义，把问题中具有实际意义的概念变成只是一个符号。</p>
<p>所以，“机器能否取代人”之类的问题，我们可以改写成几种抽象的场景：</p>
<p>1.对象<span class="math inline">\(A\)</span>创造了对象<span class="math inline">\(B\)</span>（很有可能是让对象<span class="math inline">\(B\)</span>从虚空之中产生出来），然后对象<span class="math inline">\(B\)</span>能够取代对象<span class="math inline">\(A\)</span>，在某些属性上超越了<span class="math inline">\(A\)</span>，并且<span class="math inline">\(B\)</span>同样具有“创造比对象<span class="math inline">\(B\)</span>更强的对象”的能力。</p>
<p>2.整体<span class="math inline">\(A\)</span>把<span class="math inline">\(B\)</span>作为它的一个部分，然后<span class="math inline">\(B\)</span>可以“整体作用”于<span class="math inline">\(A\)</span>，从而引起<span class="math inline">\(A\)</span>和<span class="math inline">\(B\)</span>的共同的变化。结果，就相当于<span class="math inline">\(B\)</span>间接地作用于自已。</p>
<p>把<span class="math inline">\(A\)</span>看成是人类，把<span class="math inline">\(B\)</span>看成是机器，那么其实很自然地，我们如果不怀疑<span class="math inline">\(A\)</span>，那么自然“机器取代人类”是可能的一个命题；对于学术来说，学术研究是一个整体，数据处理是其中的一个部分，而数据处理的方式的变化，自然引起整个科学研究方式的变革。如果数据处理实现了自动化，那么科学研究自然也会引起一些变化。</p>
<p>自然地，自举的模式也是类似的，因为有如下的场景：</p>
<p>1.计算机系统刚开始只有一段BIOS程序来引导应用程序，这段BIOS把引导程序，如<code>grub</code>或者<code>syslinux</code>加载到内存当中。<code>grub</code>是可以执行lua脚本的，相当于一个微型的操作系统。不过，这个系统仅仅对文件系统访问提供有限的支持，唯一做的，经常是把操作系统内核如Linux加载到指定的位置，然后使它运行。而后Linux成为了一个“更强大的”操作系统。再加载一些桌面后，成为更完善的操作系统。在整个过程期间，BIOS、grub都相当于把自己从内存中“杀死”了。</p>
<p>2.编译器的构建。<code>Ada编译器是用Ada写成的，C编译器是使用C写成的</code>。那么这种循环的情况该如何理解呢？自然而然地，刚开始没有Ada或者C这种东西，只能是其它的某种语言产生的。便使用低级语言构造一个基础的编译器。之后的过程是，高版本的编译器只使用低版本的编译器所支持的语法特性来编写，用低版本编译器编译，生成高版本的编译器，然后高版本的编译器在保持特性相容的条件下，重新编译自己的源代码。更复杂一点的GCC，源代码编译需要三次构建。</p>
<p>在社会中也许我们可以看到更自然的形式，比如达尔文的《物种起源》被广泛接受之后，逐代进化的观念就保留了下来。与此同时，现代社会也认为社会是在不断向高级的形式进化的。从来没有人对这些提出疑问，那么为什么我们会对于机器取代人没法淡定了呢？</p>
<h2 id="问题精化">问题精化</h2>
<p>粗糙地看，提出的场景都是相似的。我们也就可以找到各自的特殊情况，以便相互借鉴解决问题的方法。比如说想象如下的问题：</p>
<p>1.在场景中，居于中心地位的，明显是一对对象而已，比如人与机器、数据处理与科学研究、整体与部分、对象<span class="math inline">\(A\)</span>与对象<span class="math inline">\(B\)</span>、编译器与新版本的编译器。但是真的就只有这两个对象的参与么？其实也许还有环境的作用。比如，执行代码的主机。那么，在人与智能的关系中，其实人的进化也是有原因的，机器的进化也是有原因的。这种原因是什么呢？</p>
<p>2.在编译器的构造中，我们知道，每个语言虽然是不完全的，但是在计算能力上面，往往图灵等价。这似乎在告诉我们，不管每个时间<span class="math inline">\(t\)</span>事物存在的情况如何，事物的轨迹构成成一个称为“全体”或者“空间”之类的东西。虽然我们在某一时刻或者短时间内只能看到其中的一部分，但是我们知道其中存在更多的可能。在智能上，是否人只是“智能的一种表现形式”，从而“人的智能”是“智能”的一个子空间呢？</p>
<p>3.第三个问题，有些场景中，明显地涉及到“产生”这个概念。那么“从虚空中产生”究竟意味着什么呢？我们高中的物理知识告诉我们质量守恒与能量的守恒，后来是质能关系守恒，最近或许因为Higgs粒子的验证，或许又要修改另一种说法了。但是在能量之上，熵的增加却又成为了不争的事实。那么，世界是否任何对象都是“守恒”的，还是说，这些量仅仅是我们观测的量而已，它们并不无条件等同于世界？</p>
<h2 id="问题类比">问题类比</h2>
<p>一些共同的想法使我想到可能动力系统来比喻当前的问题。动力系统可以抽象人造的系统，也可以抽象现实世界中存在的一些运动机制；可以是小范围、少变量的，也可以是大范围的、复杂的系统；可以是离散的，连续的或者是混合的。既然“动力系统”只是一种数学的抽象，那么把人工智能与人的思维的关系建模成动力系统也是一种可能。</p>
<p>大概我们可以把这类双因素相互作用的系统看成是普遍的模式。那么，如果一个变量的变化，受到两个变量的影响，那么长期情况下会出现什么行为呢？是否总会是趋于无穷呢？数学方程告诉我们未必。那么，其实人工智能的问题就更不用担心了：在简单的二元变量的情况下，系统的行为尚且可以如此复杂，那么，对于人与机器的相互作用，这样复杂的东西，是否仅仅考虑到长时间以后，人类就被机器取代了呢？第一，这得附加上一些边界条件。第二，即使取代人类，那么也是方程指定的结果。</p>
<p>我想，在现实世界中，社会问题可能存在多种可能。每一种都有其存在的方式，存在的原因。要想了解具体的行为，还是得分析一些具体的量是怎样的。</p>
<h2 id="初步结论">初步结论</h2>
<p>讨论机器是否取代人，或者科学研究过程中数据与理论哪个更为复杂，可能没有太多的实际的意义。不管怎样说，在目前如果我们不去推动人工智能的发展，那么人工智能成了什么样子还是不好预测的。至少我们得参与其中，才有一些发言权。</p>
<p>还有，目前机器能够的工作还是非常少。要相信人工智能可以取代人类，除非有人做出来机器代替目前研究生能够做的烦杂的劳动。否则我们怎样才能相信机器可以取代人？</p>
<p>更根本的问题，或许是哪些事情应该由人来做，哪些事情应该由机器来做。人与机器的关系该是怎样的。目前，在机器取代人的工作的方面已经有一些进展了。在已有的经验的基础上，或许该发现“机器取代人工作的一些模式”，或者“人与机器共生的几个场景”一些例子。适当地总结下来，或许关键在于所谓的“能够把人与机器融合在一起的工作流”应该是怎样的。假如能够有这样一套系统的工作方法论，或许类似人与机器的可替代性的问题就太过基础和肤浅了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/21/150621-个人主页项目/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/21/150621-个人主页项目/" itemprop="url">
                  个人主页项目的设计与管理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-06-21T00:00:00+08:00">
                2015-06-21
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:52:56+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/06/21/150621-个人主页项目/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/21/150621-个人主页项目/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>参考<a href="http://web.engr.oregonstate.edu/~walkiner" target="_blank" rel="external">Eric Walkingshaw的主页</a>、<a href="http://www.skybluetrades.net" target="_blank" rel="external">Ian Ross的主页</a>以及<a href="http://yannesposito.com/" target="_blank" rel="external">yogsototh的支持多语言的主页</a>的设计以决定该怎样布局个人的主页。</p>
<p>Hakyll下面的个人主页项目，似乎有把个人主页分成程序和资源两个部分的倾向。进一步地，site.hs，以及编译器属于程序，CSS、Markdown与HTML模板属于“资源”。那么我们会问，制作一个个人主页必须学会编程，特别是Haskell编程么？似乎前台的工作就已经足够让人烦了：个人主页中的CSS、HTML页面布局的设计就变得非常麻烦。鉴于所使用的后台对于个人主页没有任何直接的影响，我们不妨把构建网站的程序从网站代码当中分离出来。</p>
<p>理想中的工作流的情况应该是这样的：先由用户组织好自己的网站的目录（特别是Markdown目录、CSS、HTML模块这些主要的页面的文件。由于这些文件需要编译，所以应该由一个项目发布程序，功能类似于site.hs。但是项目发布程序原则上是一个DSL，而不应该是Haskell代码。即使是Haskell代码，因为发布之前的网站相当于“源代码”，所以也可以像Makefile那样使用本地的应用程序生成。</p>
<p>注：写到这里，已经不能把握最佳实践。恐怕自己的重点该放在理解Pandoc格式并写出几个过滤器来了。有足够的知识基础后再来整Hakyll网站。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/20/150620-个人主页开通/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/20/150620-个人主页开通/" itemprop="url">
                  Github主页修整记
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-06-20T00:00:00+08:00">
                2015-06-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:17+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/06/20/150620-个人主页开通/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/20/150620-个人主页开通/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>建主页有许多种选择。这些方案可以分成静态主页方案与动态主页方案两大类。动态主页的托管的方式可能复杂一些，需要维护的代价似乎比较高。此外，动态主页里面的内容在转成可打印的版本的时候质量也会缩水。最理想的情况自然是一边能够生成HTML文档，另一方面，不经重新修改，可以转成其它的格式，特别是LaTeX的格式。</p>
<p>但是实际中能像LaTeX那样有表现力，又有丰富宏包支持的格式还真不多。Markdown等都过于简单了。之前的实践中，LaTeX格式与HTML对比中，主要的不一致有：</p>
<p>1.LaTeX中有wrapfigure、caption宏包可以调整图片，但是在HTML中的调整就得手工编码了。因为实在是没有学习HTML的排版细节问题；此外，LaTeX的表格转成HTML的表格也不太容易，特别是有对齐、指定宽度的表格，换到HTML页面上往往不好看。</p>
<p>2.数学公式中，使用MathJax中也只能使用预定义的公式集。但是在编程语言中所用的符号，与在逻辑中所用的符号不同，范畴论的符号，跟在线性代数中也非常不同。在MathJax中能够自定义数学公式命令是必须的，但是又是比较麻烦的。高级的框架，如交换图、amssymb、eulervm宏包提供的符号，似乎也得重新配置。单配置来说并不困难，可是有时候需要变更宏包，这个时候又得手工同步。</p>
<p>3.LaTeX中有一些宏包来支持其高级的特性，比如算法宏包algorithmicx、语法高亮的宏包listings或者minted、排版化学公式的chemfig、排版UML图形的umlcd、排版音乐的abc宏包（其它的还有lilypond、musixtex，后面两者的可用性没有abc好）。但是这些特性在markdown或者reStructuredText中不那么自然。</p>
<p>4.本人一直在用Sphinx来写编程语言教程，效果还不错。但是博客是一种新的格式，展示的内容可能也比较杂。</p>
<p>5.还有一点，LaTeX与XeLaTeX中可以自由使用各种字体，间距也会调整得很好。但是像审阅打印稿一样阅读网页中的文章是不可行的。用于网页中增强可读性的方法有自己的一套逻辑。</p>
<p>后来发现，Pandoc远胜于其它的方式，至少在原则上，Pandoc可以以一种既简洁又一致的方法扩展自己的功能，虽然Sphinx也支持各种插件。但是在Pandoc中写filter更容易。</p>
<h2 id="期望中的个人主页的结构">期望中的个人主页的结构</h2>
<p>遇到这么多问题，首先需要明确对于个人主页抱有的期望有哪些。现在自己推荐的是Hakyll工具，相应地，在<a href="http://jaspervdj.be/hakyll/examples.html" class="uri" target="_blank" rel="external">http://jaspervdj.be/hakyll/examples.html</a>上有一些建好的网站的样式。其中，<a href="http://web.engr.oregonstate.edu/~walkiner" target="_blank" rel="external">Eric Walkingshaw的主页</a>、<a href="http://www.skybluetrades.net" target="_blank" rel="external">Ian Ross的主页</a>以及 <a href="http://yannesposito.com/" target="_blank" rel="external">yogsototh的支持多语言的主页</a>里面的几个特性吸引了我。</p>
<p>根据这几个网站，总结出个人期望的个人主页应当具有如下几个特点：</p>
<p>1.首页应当加强作者的介绍。可以添加上作者的感兴趣的编程语言、感兴趣的研究方面，以及目前的研究的动向。不能只是每天都是列表的重复。如果有可能，可以添加上Disqus评论、标签云、文章检索、改变外观的功能。</p>
<p>2.对多语言的支持。我们现在在英文与中文方面都各自有一些要表达的东西。为了国际化，得使用英文，但同时也想用中文表达一些意思。在同一页面中各种语言混杂起来显得非常奇怪，可读性也非常差。所以，一个网站，准备有中文的、英文的、混合的版本，并且可以按照不同的语言切换。</p>
<p>3.对文章预览的支持。文章内容的可读性比较因人而异，但是整体页面的风格对于找到合适的文章亦非常关键。展示文章列表的时候，是否文字应该醒目？是否有关键词？是否放置一些摘要？是否将日期与网页右侧对齐？个人希望这些功能能够组合在一起。必要的时候，也可以附加一些搜索功能。</p>
<h2 id="pandoc与hakyll没有直接支持的功能">Pandoc与Hakyll没有直接支持的功能</h2>
<p>Pandoc的设计确实令人印象深刻。但是目前要实现一个功能，还存在不足。Pandoc在机制方面可能足够好了，但是在“工作流”的处理上可能还不够好。比如说，出版的过程可能是首先确定题目，然后把封面设计与内容设计分开，在写各章的内容的时候，一般还要确定使用LaTeX的哪些Feature。如果Pandoc能够更好地支持“希望支持切角”，希望“把ACM SIG的论文格式改成IEEE Computer的论文格式”这样的语句，也许更好一些。或者，Pandoc最终能够做到“指定纸张大小”，“指定一个文类”，然后作者就可以只关心要写的内容了。</p>
<p>考虑到实际情况，个人希望在Pandoc与Hakyll里能够解决如下的问题：</p>
<p>1.处理LaTeX的更多的块。比如说，处理abc、theorem、definition等环境。</p>
<p>2.能够方便地定义LaTeX命令。</p>
<p>3.排版图片与表格的时候可以更简单一些。</p>
<p>4.能够更方便地绘制各种图表、示意图。</p>
<p>当然，这些问题有些并不是单独用Pandoc或者Hakyll来解决的。但是至少以后期望这些功能可以以一种更完整的方式集成在pandoc的markdown格式中。</p>
<h2 id="已完成的事情未完成的事件与展望">已完成的事情、未完成的事件与展望</h2>
<p>最近的作业特别多，时间也比较紧张。所以就先把个人主页弄到这里。有时间再添加内容、编写文档处理程序。</p>
<p>目前完成的事情是使用ssh就把主页上传过去，主页有master和source两个分支，分别用来保存网站和源代码。然后把文档和Travis相连接。</p>
<p>如果继续的话，可能需要加强以下几个方面的能力：</p>
<ol style="list-style-type: decimal">
<li><p>熟悉在Github上面的开发流程。了解在多个人员参与的情况下，代码该怎样提交；出现突之后怎样解决；以及更好地使用Travis CI或者Trello等工具实现软件测试、质量评审</p></li>
<li><p>了解一些HTML+CSS+JavaScript的知识，这是能够建立稍复杂一点的个人主页的基础知识</p></li>
<li><p>了解Pandoc的语法格式，能够熟练地写出Filter；能够熟练改变Pandoc的LaTeX模板、HTML模板</p></li>
<li><p>把Hakyll看成是Pandoc的构建工具。能够写出自己定制的文档编译器的cabal包。能够将其安装到系统当中，能够生成多页的HTML、生成一个LaTeX工程（多文件），比latexmk更方便地编译latex代码</p></li>
<li><p>在文档编译器自己定义的基础上，能够在Pandoc中把TikZ图形、abc音乐、minted代码，定理、参考文献等在HTML格式与LaTeX格式中同时排版出来。</p></li>
</ol>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/08/150608-Agda语言介绍/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/08/150608-Agda语言介绍/" itemprop="url">
                  Agda语言介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-06-08T00:00:00+08:00">
                2015-06-08
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:17+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/06/08/150608-Agda语言介绍/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/08/150608-Agda语言介绍/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Agda语言是使用了依存类型的函数式编程语言。最初发表于2007年，是在Ulf Norell的博士论文里面。目前实践当中，函数式语言中使用依存类型还不多。但是依存类型在可以预见的未来内会继续发展。目前发展依存类型的函数式语言的动力在于形式证明。目前的版本是Agda2，基本上是重写了。Agda2不像Coq的地方在于，Agda没有对于tactics与函数式proofs的支持。Agda 2语言有对于数据类型、模式匹配、记录、模块、Haskell语法的支持。Agda 2是基于Zhaohui Luo的UTT类型理论，与Martin-L&quot;of类型理论（也就是直觉类型论）有一点的不同。</p>
<p>Agda的值得提及的特性有归纳类型定义（这在Coq中也存在）、依存类型的模式匹配机制（允许在依存类型系统下使用模式匹配）、元变量（允许变量在运行的时候被细化和修改，因此支持程序在运行的时候增量构造，部分代替了tactics在Coq中的作用）、证明自动化（通过反射实现，以及允许程序在5s内枚举可能的证明），以及终止检查（因为Agda是一个完全的语言，能够保证每个程序都必然终止，以此保证语言的一致性，借助于Foetus termination checker实现终止检查）。</p>
<p>Agda和Coq等“后现代的编程语言”一样，对Unicode的变量支持很好。（相比之下，我们认为Haskell、Scala是属于所谓的现代编程语言）。Agda支持三种编译器后端：MAlonzo（输出Haskell）、JavaScript后端，以及Epic后端。关于Agda的论文与理论研究在这里自己就不总结了。</p>
<p>Agda语言的安装是比较简单的。可以直接在ubuntu下面使用apt-get安装。但是建议的安装方式是使用hackage的cabal install agda，因为它是用Haskell写成的。</p>
<p>自己学习Agda目前主要是根据《Dependently Typed Programming in Agda》<a href="http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf" class="uri" target="_blank" rel="external">http://www.cse.chalmers.se/~ulfn/papers/afp08/tutorial.pdf</a>。里面强调的是其依存类型的风格。Hindley-Milner风格的编程语言如Haskell与ML中，类型与值之间存在明显的分割。两者是互不相关的。但是在依存类型当中，值与类型是相互关联的。函数可以根据值返回不同的类型，但是又不同于动态类型的语言。</p>
<p>在Agda的理解中，典型的依存类型是<span class="math inline">\(n\)</span>-维向量。若把不同的<span class="math inline">\(n\)</span>-维向量看成是不同的，那么向理的类型必然依赖于参数<span class="math inline">\(n\)</span>。C++的模块编程支持这种<span class="math inline">\(n\)</span>维向量的风格，但是在Hindley-Milner的类型系统中，区别似乎是有些困难。通过这个例子可以看出，依存类型系统会更精细，而且也有可能为C++的模块机制提供一个理论基础。</p>
<p>依存类型在定理证明中的可能的作用是：值的属性当成是一个元素为使得证明的属值为真的那些类型。这样，依存类型的编程语言可以当成是逻辑语言使用。</p>
<p>Agda语言的每个源文件都由一个顶层的模块名称声明开始。此外，agda使用的扩展名是lagda，表示的是agda源文件里面支持了文学编程（其实我们也可以把文学编程看成是后现代编程语言的一种特性，Haskell就具有这个特性）。Agda的文件名与模块名保持一致（像Java那样）。</p>
<p>Agda与Haskell与ML一样，支持对代数数据类型进行模式匹配（但是一般介绍Agda语言的书中，刚开始的时候还是介绍简单类型的函数式数据类型的匹配，而把依存类型的匹配规则放在最后）。数据类型使用data关键字来声明。比如声明一个布尔类型为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data Bool : Set where</div><div class="line">	true  : Bool</div><div class="line">	false : Bool</div></pre></td></tr></table></figure>
<p>声明中，Bool的类型是Set，Set是小类型的类型（因为Agda支持把Set这个类型当成是Set1的一个元素，也就是支持层次化类型）。此外，Agda的函数定义语法（不动点定义）与Haskell也是很像的，比如Bool的not函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">not : Bool -&gt; Bool</div><div class="line">not true = false</div><div class="line">not false = true</div></pre></td></tr></table></figure>
<p>不过，not的类型声明其实不是必须的。</p>
<p>另外一种定义是采用归纳定义一个类型定义，比如自然数的定义：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">data Nat : Set where</div><div class="line">	zero : Nat </div><div class="line">	succ : Nat -&gt; Nat</div><div class="line">_+_ : Nat -&gt; Nat -&gt; Nat</div><div class="line">zero + m = m</div><div class="line">succ n + m = succ (n + m)</div><div class="line">_*_ : Nat -&gt; Nat -&gt; Nat</div><div class="line">zero * m = zero</div><div class="line">succ n * m = m + n * m</div></pre></td></tr></table></figure>
<p>这种定义是允许的，但是为了保证合理性，应该加上一个n &lt; succ n的断言。</p>
<p>甚至函数的定义也是基于模式匹配的，比如定义if_then_else为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">if_then_else_ : &#123;A: Set&#125; -&gt; Bool -&gt; A -&gt; A -&gt; A</div><div class="line">if true then x else y = x</div><div class="line">if false then x else y = y</div></pre></td></tr></table></figure>
<p>这样我们就定义了一个if_then_else函数，而且可以把变量加在中间。如果需要声明中缀函数，以及指定中缀函数的优先级，可以使用infixr关键字。另外，像Haskell与ML一样，Agda允许含参数据类型，如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">infixr 40 _::_</div><div class="line">data List (A : Set) : Set where</div><div class="line">	[] : List A</div><div class="line">	_::_ : A -&gt; List A -&gt; List A</div></pre></td></tr></table></figure>
<p>上面的List是一个含参类，除此之外，由于Unicode特性，变量可以包含任何的符号。</p>
<h2 id="agda的依存类型的函数">Agda的依存类型的函数</h2>
<p>Agda的依存类型的函数的声明并不特别之处，也是使用<code>(x:A)-&gt;B</code>来声明这个变量。不过，由于指定了变元x，所以类型B是可以包含x作为变量的。此外，由于Agda的类型层次结构，所以一个类型的元素也可以是一个类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">identity : (A : Set ) -&gt; A -&gt; A</div><div class="line">identity A x = x</div><div class="line">zero&apos; : Nat</div><div class="line">zero&apos; = identity Nat zero</div></pre></td></tr></table></figure>
<p>上面的函数接受类型<span class="math inline">\(A\)</span>以及类型<span class="math inline">\(A\)</span>的一个元素为参数，然后返回相应的元素。再来一个非平凡的例子，这个例子创建了一个apply函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">apply : (A : Set)(B : A -&gt; Set) -&gt;</div><div class="line">	((x : A) -&gt; B x) -&gt; (a : A) -&gt; B a</div><div class="line">apply A B f a = f a</div></pre></td></tr></table></figure>
<p>对于依存函数类型，有一些简便的记法可以使用，比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(x : A)(y : B) -&gt; C for (x : A) -&gt; (y : B) -&gt; C</div><div class="line">(x y : A) -&gt; B for (x : A)(y : A) -&gt; B</div></pre></td></tr></table></figure>
<p>具体的运算，可能要参考依存类型<span class="math inline">\(\lambda\)</span>-演算来解决。函数式语言在处理可选参数的上面可能没有一些命令式语言直观。但是Agda提供了缺省参数的情况，这样一个函数可以应用在不同参数数目的场合。</p>
<p>Agda使用如下的方式声明<span class="math inline">\(n\)</span>-维向量：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">data Vec (A : Set) : Nat -&gt; Set where</div><div class="line">	[]   : Vec A zero</div><div class="line">	_::_ : &#123;n : Nat&#125; -&gt; A -&gt; Vec A n -&gt; Vec A (suc n)</div></pre></td></tr></table></figure>
<p>上式表示Vec A是一个Nat-&gt;Set的映射，所以Vec A n得到一个具体的类型。</p>
<p>个人感觉，Agda的设计体现了对模式匹配与类型系统的大的发展。我们可以参考一下。这样我们遇到再奇怪的编程语言的时候也就不再感到奇怪了。Agda还可以导入Haskell的模块。agda的输入输出也是基于单体的。</p>
<h2 id="agda的文学化编程">Agda的文学化编程</h2>
<p>Agda的文学化编程与Latex是类似的。不过agda程序可以使用–latex来输出一个tex文档，这样的话，可以实现许多的排版的功能。文学编程功能与Haskell是一样的。</p>
<p>lagda可以看成是一个.lhs文件，它可以由lhs2tex来处理。</p>
<p>agda的vim高亮可以参考<a href="https://github.com/derekelkins/agda-vim.git" class="uri" target="_blank" rel="external">https://github.com/derekelkins/agda-vim.git</a>。</p>
<p><a href="http://stevebob.net/agda-environment/" class="uri" target="_blank" rel="external">http://stevebob.net/agda-environment/</a>上介绍了Agda的入门程序。包括在ubuntu下面安装一直到使用。</p>
<p>编译agda的时候，要想连接到相应的库，使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">agda -c -i /usr/share/agda-stdlib -i . hello.agda</div></pre></td></tr></table></figure>
<p>agda的编译器是通过调用Haskell来实现的。</p>
<p><a href="http://blog.oxij.org/2011/12/22/howto-get-started-with-agda/" class="uri" target="_blank" rel="external">http://blog.oxij.org/2011/12/22/howto-get-started-with-agda/</a>上介绍了怎样开始Agda。不过是2011年的。关键的不是自己写出来一个Hello World，而是怎样让别人在网上写的复杂的教程，或者是一个实际的工程在自己的计算机上跑起来。写这篇博文的是教本科生Haskell的老师。但是作者也想利用Agda。看起来，研究生的阶段不是学习Agda，而是真正地理解其背后的依存类型、归纳数据类型等的原理与实现。（其实自己理想中，所有的形而上学的知识都应该是在大学完成的。但是很多时候，研究生的阶段我们尚未完成）。作者那个时候也认为，本科生理解Agda是几乎不可能的。</p>
<h2 id="作者对于高级编程语言的看法">作者对于高级编程语言的看法：</h2>
<p>Advanced programming language requires advanced tools.</p>
<p>比如说，有企业级的开发环境（IDE、自动编译、调试、符号表查找、版本控制）。此外，也可以是最简单的一个文本编辑器。</p>
<p>不过，Agda的程序比较特殊，通常这些代码并不运行，甚至不进行编译，我们只是想对它们进行类型检查。对于Agda来说，调试也是没有用的。也根本没有调试器。</p>
<p>此外，为了使用Agda，还得有一种方便的方式输入Unicode字符。不过，大部分编辑器中，实现这个功能可能是非常复杂的。</p>
<p>写Agda代码也会不同于以往，因为一般有的时候，一天也写不到25行Agda代码。因为需要Unicode，而且目前Agda提供的也只有Emacs，所以不会Emacs就已经把大部分的程序员阻止在外了。</p>
<p>确保安装了如下的程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cabal install agda</div><div class="line">## 打开软件包，并安装agda-libs cabal install</div><div class="line">cabal install Agda-executable</div></pre></td></tr></table></figure>
<p>然后配置~/.emacs文件：　</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(load-file (let ((coding-system-for-read &apos;utf-8))</div><div class="line">    (shell-command-to-string &quot;agda-mode locate&quot;)))</div></pre></td></tr></table></figure>
<p>打开emacs，使用C-x C-f打开一个编辑的文档。配置Emacs环境的方法有很多。但是必须在Emacs下面工作不可。否则，是没法写出合法的Agda代码的。</p>
<p>Agda程序写出来有什么样的作用：其实跟Haskell差不多，Agda程序也从Main开始。</p>
<h2 id="agda的用法06-30-2015-164601">Agda的用法[06-30-2015 16:46:01]</h2>
<p>Agda的一种用法是作为一个交互式的定理编辑器，或者说辅助定理证明器。不过，其实没有意义，是因为这些应用中，看不到使用它们证明了什么样的数学的定理。所以，感觉好像真的是没有什么用途。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/06/150606-Elixir函数式语言/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/06/150606-Elixir函数式语言/" itemprop="url">
                  Elixir：建立在Erlang虚拟机上的函数式语言
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-06-06T00:00:00+08:00">
                2015-06-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:16+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/06/06/150606-Elixir函数式语言/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/06/150606-Elixir函数式语言/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Elixir是建立头Elrang虚拟机上的函数式、并发的、通用的编程语言。Elixir是一个BEAM（Erlang虚拟机的名称）上面的一个比较新的编程语言。Elixir的思想是所有的事物都看成是表达式。现代编程语言通常都具有开些诸如泛型编程、函数式编程、面向对象编程，对并发、并行、异步、非阻塞都有很好的支持，支持多态特性。在函数式编程方面上也支持模式匹配。类型系统当然更为严谨。此外，模式匹配、惰性求值、unicode支持、多态、文档注释甚至文学编程特性、高阶函数也往往都具备。</p>
<p>Elixir的REPL环境是iex命令。Elixir的语言的扩展名是exs。</p>
<p>Erlang的虚拟机的配置是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">erl -name node06@10.0.0.151 --cookie a</div></pre></td></tr></table></figure>
<p>同样地，自己希望在Elixir中也可以采用集群的方式管理和安装。比如如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">juju run --all &quot;wget http://packages.erlang-solutions.com/erlang-solutions_1.0_all.deb &amp;&amp; sudo dpkg -i erlang-solutions_1.0_all.deb&quot;</div><div class="line">juju run --all &quot;sudo apt-get update&quot;</div><div class="line">juju run --all &quot;sudo apt-get install elixir&quot;</div></pre></td></tr></table></figure>
<p>这样就安装好了Elixir环境。然后就是配置程序语言了。不知道与Erlang同样基于BEAM虚拟机，是否可以同时启动Erlang环境与Elixir环境。结果是，确实是这样，如果一个Erlang虚拟机启动了，Elixir也能够连接到Erlang结点。</p>
<p>Erlang的各个结点加入之后，使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">iex --name elixir@node01.107.maas</div></pre></td></tr></table></figure>
<p>来创建一个Elixir结点，然后使用</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Node.connect <span class="symbol">:<span class="string">'node06@node06.</span></span></div><div class="line">Node.list</div></pre></td></tr></table></figure>
<p>如果要开启多个结点，可以使用这样的模式：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">juju run --all <span class="string">'iex --name elixir@$(hostname).107.maas --detached'</span></div></pre></td></tr></table></figure>
<p>来查看Erlang/Elixir已经接受的虚拟机的结点。但是需要注意的是，虽然它们共用同一个结点，但是Elixir的程序的代码与Erlang的程序的代码却是不通用的。也就是说，iex能够发现Erlang的结点，但是在Erlang的结点上spawn程序会造成问题。因此，elixir只能在elixir的结点上分配程序。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Istyasna" />
          <p class="site-author-name" itemprop="name">Istyasna</p>
          <p class="site-description motion-element" itemprop="description">GO FORTH now and create masterpieces of the publishing art!</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">57</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">233</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/irhawks" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://coding.aliyun.com/u/irhawks" target="_blank" title="Aliyun">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Aliyun
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="./" title="Title" target="_blank">Title</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.hainu.edu.cn" title="Hainan University" target="_blank">Hainan University</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Istyasna</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"irhawks"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  


</body>
</html>
