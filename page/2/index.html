<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans,en,default">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="80x24" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="GO FORTH now and create masterpieces of the publishing art!">
<meta property="og:type" content="website">
<meta property="og:title" content="80x24">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="80x24">
<meta property="og:description" content="GO FORTH now and create masterpieces of the publishing art!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="80x24">
<meta name="twitter:description" content="GO FORTH now and create masterpieces of the publishing art!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title> 80x24 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?763bee904aa6d81fdf017659d162188f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">80x24</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Keep Stupid, Keep Hungry</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/atom.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/06/150606-Erlang并发小测试/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/06/150606-Erlang并发小测试/" itemprop="url">
                  Erlang编程语言中的并发小测试
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-06-06T00:00:00+08:00">
                2015-06-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:16+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/06/06/150606-Erlang并发小测试/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/06/150606-Erlang并发小测试/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>已经接触了很多的编程语言。大概分成Lisp一系的、Haskell一系的，Erlang一系的、JVM一系的、C#一系的，以及OCaml一系的语言。但是自己感觉，分类上，可能还是按照类型的动态与静态，是否是纯函数式的，是否支持面向对象特性，是否支持自动类型推断（其实现代编程语言大概都支持了），求值的时候是否是惰性求值的，以及对于并发和并行的支持等。函数式语言的特性大概就这么看。其它的方面，说是语言的包管理系统、编译环境与版本控制。如果是在虚拟机上，那么对虚拟机上的原生语言的支持等。</p>
<p>看到这么多编程语言，自己感觉很多的设计模式都是内置在函数式语言中的，比如自己设想的在改变一个变量的时候，同时产生一种日志记录，已经在Clojure中完美实现。其它的语言特性也很多。</p>
<p>Erlang上面还建立有Eixir编程语言。语言更进一步。Erlang是运行在EVM虚拟机上的。有个时候，一些并发处理的机制与面向对象其实是不谋而合的。由于设计模式已经融入其中，自己感觉，设计模式是一种比较高级的抽象了。</p>
<p>Erlang是一种通用的面向并发的编程语言，它由瑞典电信设备制造商爱立信所辖的CS-Lab开发，目的是创造一种可以应对大规模并发活动的编程语言和运行环境。Erlang问世于1987年，经过十年的发展，于1998年发布开源版本。Erlang是运行于虚拟机的解释性语言，但是现在也包含有乌普萨拉大学高性能Erlang计划（HiPE）开发的本地代码编译器，自R11B-4版本开始，Erlang也开始支持脚本式解释器。在编程范型上，Erlang属于多重范型编程语言，涵盖函数式、并发式及分布式。顺序执行的Erlang是一个及早求值, 单次赋值和动态类型的函数式编程语言。</p>
<p>使用Erlang来编写分布式应用要简单的多，因为它的分布式机制是透明的：对于程序来说并不知道自己是在分布式运行。Erlang运行时环境是一个虚拟机，有点像Java虚拟机，这样代码一经编译，同样可以随处运行。它的运行时系统甚至允许代码在不被中断 的情况下更新。另外如果需要更高效的话，字节代码也可以编译成本地代码运行。</p>
<p>Erlang的设计中采纳了一些Prolog与Smalltalk中的东西。个人感觉，在处理并发问题的时候，还是不得不接触Erlang，就像在函数式语言中不能离开Haskell一样。</p>
<h2 id="erlang的并发测试环境设计">Erlang的并发测试环境设计</h2>
<p>Erlang在安装好之后应该进行分布式集群的创建的工作。每个结点上可以开启一个。安装完Erlang之后，首先应该配置Cookie，因为同一个集群当中的Erlang，应当有相同的Cookie。以juju为例，在所有的结点中执行如下的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">## Install Erlang packages</div><div class="line">juju run --all &quot;sudo apt-get install -y erlang-base&quot;</div><div class="line">juju run --all &quot;echo just_for_test &gt; .erlang.cookie&quot;</div><div class="line">juju run --all &quot;chmod 400 ~/.erlang.cookie&quot;</div></pre></td></tr></table></figure>
<p>上面的代码在每台机器上安装Erlang环境的同时，把各台机器上的Erlang Cookie都设置为<code>just_for_test</code>（以便它们都位于同一个群组中。然后正确设置cookie的权限。</p>
<p>接下来，我们要在每台机器上运行epmd进程，它负责映射符号名到机器地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">juju run --all &quot;epmd -daemon&quot;</div></pre></td></tr></table></figure>
<p><a href="http://gashero.yeax.com/?p=67" class="uri" target="_blank" rel="external">http://gashero.yeax.com/?p=67</a>中讲到了Erlang在单机环境中的应用和配置。</p>
<p>Elixir的连接与Erlang类似，但是还是有一些不同。</p>
<p>开启结点的话，可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">juju run --all &apos;erl -name $(hostname)@$(hostname).107.maas -detached&apos;</div></pre></td></tr></table></figure>
<p>运行成功之后，可以在同一个网络中登录其中的一个结点并进行测试：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">erl -name test@node01.107.maas &lt;&lt;EOF</div><div class="line">net_adm:ping(&apos;node06@node06.107.maas&apos;).</div><div class="line">nodes().</div><div class="line">EOF</div></pre></td></tr></table></figure>
<p>经过ping之后，应该能够发现原来的结点。（实际上是这样的连接建立之后，整个Erlang上面的结点能够互相发现。不一会儿，结点就会加入Full Mesh的Erlang结点网络）这样一个Erlang分布式环境就搭建成功了。但是应该说，在这个平台上实现分布式的Erlang程序还是不够的。因为故障容错等都还需要额外的努力。需要一些特别的机制。</p>
<p>在配置过程中，注意有相同的Cookie才能加入同一个Erlang群组。通过</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">rpc:call('node01@node01.<span class="number">107</span>.maas',erlang,now,[]).</div></pre></td></tr></table></figure>
<p>可以测试在指定的结点上执行代码。其中，Erlang的结点之间自动连接是默认的选项，当然可以在启动Erlang的时候使用相关的选项禁止自动连接。手动连接使用net_kernel，示例如下：</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">net_kernel:connect_node('node01@node01.<span class="number">107</span>.maas').</div></pre></td></tr></table></figure>
<h2 id="erlang的编译工具rebar06-12-2015-220911">Erlang的编译工具Rebar[06-12-2015 22:09:11]</h2>
<p>Rebar是Erlang的编译工具，相当于sbt。见<a href="https://github.com/rebar/rebar" class="uri" target="_blank" rel="external">https://github.com/rebar/rebar</a>。不过，rebar主要用于Erlang下面的OTP应用。中文也有一些参考的资料。</p>
<!--今天解决的问题有三个，第一个是iot-framework-engine，第二个是iot-framework-gui，第三个是cavin-base。希望可以利用好这些工具。-->
<p>此外，<code>sensor_cloud</code>的示例也接触了一些。接下来要继续的是学习cavin的wiki。<a href="https://github.com/EricssonResearch/calvin-base/wiki" class="uri" target="_blank" rel="external">https://github.com/EricssonResearch/calvin-base/wiki</a>。以及这篇论文<a href="http://www.sciencedirect.com/science/article/pii/S1877050915008595" class="uri" target="_blank" rel="external">http://www.sciencedirect.com/science/article/pii/S1877050915008595</a>。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/02/160602-ElasticSearch/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/02/160602-ElasticSearch/" itemprop="url">
                  ElasticSearch搜索软件
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-06-02T00:00:00+08:00">
                2015-06-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:22+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/06/02/160602-ElasticSearch/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/02/160602-ElasticSearch/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这里参考了Gitbook上面中文翻译的<a href="https://www.gitbook.com/book/fuxiaopang/learnelasticsearch/details" class="uri" target="_blank" rel="external">https://www.gitbook.com/book/fuxiaopang/learnelasticsearch/details</a>。也就是ElasticSearch权威指南。自己觉得现在正面临的问题，也就是在文档中说的：已经被数据淹没，我们创造的系统产生的数据可以瞬间轻而易举地将我们压跨。现在的科技只是致力于如何存储数据，并能将拥有大量信息的数据仓库结构化。而一旦我们想从大量的数据中得出结做做决策的时候，美好的一天就要被毁灭了。不可否认的是，没有数据分析，数据确实要成为一种负担了。所以，我们必须建立能够分析数据的工具，帮助我们从数据中得到知识，得到决策的依据。</p>
<p>ElasticSearch适用于全文搜索、结构化数据的实时统计。Elastic并不只是全文搜索，还具有结构化搜索，统计、查询过滤、地理定位、自动完成等。ElasticSearch也可以应用于生产的环境。所以对我们而言是比较合理的。自己理想中的文献检索，特别是学术文献检索系统，也应该就是这样的。个人感觉，希望ElasticSearch成为自己一生的小伙伴。</p>
<p>ElasticSearch安装之后会开启一个服务器，监听9200端口。类似于安装之后直接开启一个网页的应用程序现在变得越来越普遍了。可以说，任何一个分布式的软件，都集成了网页前端与Web Service的功能了。ElasticSearch采用分布式的设计。每个运行的ES（ElasticSearch的简称，下同）实例称为一个结点。具有相同的cluster.name的结点构成一个集群。同一集群下的结点协同工作，互相分享数据，提供了故障转移与扩展的功能。一个节点单独也可以进行工作。</p>
<p>ES的客户端有两类。一种是节点客户端，它以一个无数据节点的身份加入集群。这个节点不存放数据，但是节点本身由于知道什么数据在哪一个节点上，所以它可以执行转发的功能。另一类客户端是传输客户端。本身不是集群的一部分，但是可以把请求转发到集群中的结点。这两个客户端所使用的端口是9300。现在要求Java的客户端的版本号必须与ES节点所使用的版本号一样（这是Java类库的问题）。如果是其它的语言，可以通过9200端口上的REST服务与ES通信。</p>
<p>ES是面向文档的数据库。它不仅存储整个对象或者文档，而且还为他们建立索引，以便我们通过ES搜索。ES还在索引与搜索的基础上实现了排序与过滤的功能。学习使用ES的很基础的工作就是学会JSON与JSON上面的查询DSL。只有这样才能了解数据处理的功能是如何的。</p>
<p>但是从企业架构的角度考虑，搜索只是实现一种功能。建议的架构是，使用mongodb存储数据，然后借助于元数据挖掘工具，从文档中得到文本，把文本送到ES搜索。然后用户在点击的时候，直接返回一个文档即可。Solr与ES都是索引文档的内容。Solr对文档的索引有内部的支持，然而ES还需要一个插件。SOlr与ES都使用Tika作为元数据挖掘的工具。虽然Solr与ES都具有存储文档的功能，然而目前非常不推荐将它们作为主要的存储单元。甚至把原始文档放在本地文件系统中都比放在Solr或者ES中要好。在实现中，ES与Solr通过一些扩展都可以实现元数据存放的功能。（从实用的角度看，个人的文档管理系统确实应该是把存储与搜索放在一起。但是目前个人软件并不能赚钱，需求也不好定位，所以，实践中，都是按照企业的要求设计软件，因此不建议把存储和全文搜索都放在一起。）。总而言之，现状上，它们都支持Mongodb一样的二进制文件存储，经过一些配置也都可以实现文档的全文检索。但是不建议使用。</p>
<p><a href="http://stackoverflow.com/questions/10854858/best-practices-for-searchable-archive-of-thousands-of-documents-pdf-and-or-xml/10861308#10861308" class="uri" target="_blank" rel="external">http://stackoverflow.com/questions/10854858/best-practices-for-searchable-archive-of-thousands-of-documents-pdf-and-or-xml/10861308#10861308</a>上面介绍了搜索上千PDF或者XML文档的最佳实践。我们可以参考一下。要使文档都能够通过Web UI界面搜索，现在还存在文档格式复杂繁多的问题。但是对于一般的文档来说，实现“搜索PDF的哪一页具有什么样的文字”可能还是具有一些挑战的。可能为大多数的文档建立一个统一的模型，能够描述文本在文档中的位置、页数是比较迫切的。</p>
<p>ES可以通过附件的形式返回一个完整的文档。但是作为附件的话，可能没有全文搜索引擎的功能。因此比较好的解决的方案是使用Tika做预处理的工作，把文本与元数据挖掘出来，然后使用它进行搜索。在文本搜索的领域，可能目前也就只能这样的。但是我们知道目前的发展的趋势是很多的。比如，多媒体数据的搜索。Sunspot与RSolr这样的工具，对Solr做了进一步的封装，能够处理大多数的文档格式。为了保持性能，在70K这样的级别的程序中，把文本从PDF中挖掘出来，然后把文本存到SQL或ES中。这样在性能上也是可以接受的。</p>
<!-- 目前来看，好像还不如使用Plone之类的内容管理系统来做目前的个人文档的管理。-->

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/06/01/150601-solr/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/06/01/150601-solr/" itemprop="url">
                  Apache的企业搜索工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-06-01T00:00:00+08:00">
                2015-06-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:16+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/06/01/150601-solr/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/06/01/150601-solr/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>企业级的应用相对于普通的软件相比，体现了更多的理性，体现了更多的需求的驱动。对普通的程序员来讲，学习企业级的软件提供了一个从底层的程序员上升到资深架构师的问题。不同层次的程序员，思考问题的方式也不一样。到了架构的层面，更多的时候讨论的是架构的缺点与优点。这个时候，根本不是一味地讨论程序有哪些功能。技术不等于产品，产品不等于市场，市场不等于盈利。但是一般程序员做的，只能是基本的技术。掌握架构师的技能，大概是可以做到高级的技术、产品以及市场。</p>
<p>不多说然它的事情。今天的主要的目的是帮助实现一个全文搜索引擎。全文搜索引擎在企业中的应用可以说是信息检索的一个重要的应用。整个的框架的部分为自然语言处理等奠定了基础。没有人工智能的时候，可以是传统的检索的方式。有人工智能与自然语言处理的时候，可以以插件的形式提供新的功能。但是这个架构是稳定的。</p>
<p>通过查找网络上的资料。比较有名的企业级应用的全文搜索引擎有Apache Solr、Sphinx、Elasticsearch等。其中，除了Sphinx，都是基于Lucene的。Java平台上还有所谓的Hibernate Search。一个技术到达企业级别的应用，一般而言是在编程与布署的层面上做一些更大的问题。比如，Lucene作为信息检索基础库，在编程层面上就可以做，许多软件的帮助文档就是使用Lucene作为索引的。但是到了企业级的应用上，Lucene就只是一个基本的IR（Information Retrival）库了。在Solr上面可能有更多的集成。所以，目前我们把Solr和Lucene的分界面看成是编程与架构的分界线。并以Lucene作为案例分析编程与架构是如何关联的。</p>
<p>本章的计划是，首先介绍Lucene在信息检索中的基础功能与用法，然后讲解Solr等全文搜索引擎在企业搜索中的应用。再然后是讨论一下为什么全文搜索是必要的。以此为机会，了解编程是如何走向商业实践的，掌握怎样的技术才能够把握技术发展趋势。</p>
<h2 id="lucene软件介绍">Lucene软件介绍</h2>
<p>Apache Lucene是一个开源的IR软件库，原始版本是由Doug Cutting在Java语言之下写成的。目前以Apache Software License发布。目前Lucene程序已经移植到Delphi、Perl、C#、C++、Python、Ruby与PHP等多种语言。（这种移植可能是按照Lucene的架构在另外的语言中重新设计它，而不是简单提供一个接口那么简单）。</p>
<p>Lucene原始版本写于1999年。当时是一个SourceForge项目。后来加入Apache软件基金会，并于2005年成为Apache的一个顶级的项目。Lucene曾经包括许多的子项目，如Lucene.NET、Mahout、Solr、Nutch。现在Solr已经独立出来，而Mahout、Tika等项目也已经成为独立的顶级项目。4.0版本是2012年至2015年主要的开发版本。而2015年Lucene升级到了5.0版本。</p>
<p>Lucene所满足的应用主要有两个方面。第一个方面是应用程序对于全文检索数据的需求，第二个方面是对于单机或者互联网的个性化的数据集上的搜索的需求。比较典型的应用有，Eclipse的帮助子系统使用Lucene作为全文搜索引擎；Apache的网站使用Lucene作为全文检索的引擎。</p>
<p>Lucene的核心逻辑架色是把一个文档document看成是由fields文本构成的结构。这种结构使用Lucene的API独立于文件格式。因此，从PDF、HTML、Word、Open Document中抽取出来的文本都可以被Lucene所识别。对于许多的格式，只要它们的文本信息能够被抽取出来，Lucene就可以利用它构建全文引擎。</p>
<p>这里，我们对Lucene的功能深入思考一下。首先，音乐、图片、视频等信息基本上与Lucene没有什么关系，因为里面没什么文件信息。其次，Lucene是假设文件信息已经从PDF等文件格式中抽取出来，Lucene项目本身并不设计这样的抽取器。另外，Lucene本身并不包含HTML挖掘与解析的功能。但是有一些上层的库可以弥补。比如Apache Nutch提供了HTML抽取（挖掘）与解析的功能、Apache Solr与Elasticsearch这两个企业级的搜索服务器提供了完整的架构。还有Compass、DocFetcher、Swiftype、Kinosearch、Apache Lucy、Luke等工具也对Lucene做了不同程度的补充。</p>
<p>应当注意的是，信息检索程序虽然与搜索引擎有关，但是两者仍然是不同的概念，不应该混成同一个东西。</p>
<p><strong>Lucene实现的特点</strong></p>
<p>Lucene具有如下的特点：</p>
<ol style="list-style-type: decimal">
<li>索引格式独立于应用平台。Lucene的索引文件格式是内部定义的八字节为基础的格式，不受不同的系统与不同的平台的影响。因此应用程序能够共享建立的索引文件。</li>
<li>在传统全文检索引擎的倒排索引（不是由记录来确定属性的值，而是由属性值来确定记录的位置。这种索引的索引表中的每一项都包括一个属性值和具有该属性值的各记录的地址，这种方式正好与数据库中的索引相反）的基础上，实现分块索引（针对新的文件建立小文件索引，提升索引速度，然后与原有索引合并）。</li>
<li>采用面向对象的思想与架构设计，方便扩充新的功能。</li>
<li>设计了独立于语言与文件格式的分析接口。用户可以通过实现文本分析接口来扩展新的语言和文件格式。</li>
<li>默认已经有一套强大的查询引擎，实现了布尔操作、模糊查询、分组查询等功能。</li>
</ol>
<p>面对已经存在的商业的全文检索引擎，Lucene也具有相当的优势。比如开源发行、方便扩展、可以扩展支持中文、扩展支持HTML与PDF等格式。</p>
<p>Lucene的工作的时候采用的是索引检索。因此，可以把任务分割成建立索引与基于索引的查询两个阶段。在建立索引的阶段，做一些指定索引文件位置与索引特性的选项，然后添加字段。在查询索引的阶段，读取索引文件，设置查询格式，然后输出结果。Lucene的操作的对象是很明确的，就是文件系统当中的文件作为索引文件。运行的计算模型是传统的单机模式。</p>
<p>Lucene不是一个看爬虫。如果需要爬虫功能的话，应该参考Nutch；Lucene也不是一个完整的应用，若需要，应该参考PoweredBy；Lucene也不是实现了PageRank等算法的链接分析算法库，若需要后者，应该参考Nutch与Hadoop。它只是一个实现了基于文本的搜索的算法（在其上可以施行PageRank与Arc等链接分析算法）。</p>
<p>Lucene的一个Index是文档的集合Collection；一个文档是Fields的集合；一个Field则由描述文本内容的metadata构成。一个Field里面可以包含多个属性。</p>
<p>Lucene上面的编程任务可以分成两类。第一类是写代码以将Documents添加到index当中；第二类则是写代码将用户的查询转换成Lucene查询，并写Lucene提交查询，然后显示结果。整个的流程可以看成：围绕Index文件，一方面是提取文档元数据，把元数据通过IndexWriter添加到Index文件中。另一方面，通过IndexSearcher查询Index文件。</p>
<p>Lucene本身并不关心文件的格式。因为文件在添加之前，都要构造出一个索引字符串，不论被索引的文档是PDF还是纯文本。这样以来，Lucene必须结合一些好的开源的文档格式抽取器（如Tika）。在搜索的阶段，Lucene Query Parser把字符串转换成一系列的编程对象，由这些对象支持查询。</p>
<p>在从文档构造Index文件的过程中，需要经过“分析”。分析的任务是将原始的文本转化成可被索引的记号流。Lucene使用Analyser、Tokenizer与TokenFilter类负责这些任务。其中TokerFilters就是细节性地修正产生的Token了。</p>
<p>除此之外，Lucene还有一些高亮匹配文本、拼写检查、查找相似页面等功能。Luke是其上的一个前端。可以用它来查看索引文件，并执行相关的查询。</p>
<h2 id="solr介绍">Solr介绍</h2>
<p>Solr于2006年成为Apache的一个项目。目前常把Lucene与Solr放在一起讲述。目前的搜索模型有许多种，布尔模型、向量空间模型、语言模型、概率模型等。向量空间模型用得大概是最多的。经典的TF-IDF方法就是其中之一。Lucene的模型是修改过的向量空间模型，采用这样的原理检索文档。</p>
<p>Solr是一个开源的企业搜索服务器。基于Lucene。具有XML/HTTP API。在工作的时候支持cache、replication、web管理等功能。Solr实现中，借鉴了许多Lucene的最佳实践。方便扩展，并且安装与配置都很方便。在客户端方面，还设计了针对许多语言的接口。Solor的安装与启动都很简单。流程是：下载、运行。想要建立索引的话，cd到examples docs目录下，运行 <code>java -jar post.jar *.xml</code> 就可以了。</p>
<p>Solr的schema.xml描述了用户的数据与数据是怎样被处理的。它还允许用户添加除了字符串以外的一些类型（整型、浮点等）。solrconfig.xml文件描述了用户是怎样与数据交互的。配置了数据放置的位置、性能选项、以及允许的操作权限等。（企业级的应用中，许多的可选项一般是必然需要的）。</p>
<p>在Solr中添加索引一般需要客户端通过HTTP发送XML格式的文档表示添加索引的企图。通过HTTP与XML格式请求，客户端也可以完成删除文档、更新文档的操作。同样地，想要搜索文件，也通过客户端连接HTTP的方式请求指定的URL。Solr也有高亮、更多、拼写检查等功能。</p>
<p>Solr的高级功能有支持提高查询效率的副本功能、负载均衡、缓存等。Lucene采用的是嵌入到应用程序里面进行工作，而Solr采用的是作为单独的网络服务进行工作。</p>
<p>想具体测试Solr的性能，可以使用HTMLUNIT（Google）等工具。Solr的典型的使用场景是在Lucene索引文件的基础上，建立一个Solr Search Server。然后把它布署在HTTP Server应用服务器之上，用户通过访问应用服务器，间接使用Solr的服务。</p>
<p>至于传统CMS想使用Solr作为索引，则可以使用Curl与XSTL工具先进行转换，然后以XML的格式存到Solr当中。</p>
<p>在语言支持上面，Scala的Play框架可以异步调用Solr查询引擎。the play.api.libs.ws.WS library to call Solr and use Plays JSON support to extract the result (like in the example below) or is there any easier/faster way。网上有一些已经存在的好的实践方式，自己可以吸纳它们在Scala中是如何与Solr交互的。</p>
<p>Solr与自己的应用集成的时候，总是通过构造XML格式的添加文档、删除文档等命令实现。只要应用程序知道Solr服务器的URL就可以做到了。值得注意的是，Solr应当配置为utf-8编码，返回的结果也要使用utf-8转码。</p>
<p>注：Apache有一个叫OpenEJB的开源项目。似乎也值得一试。<a href="http://www.crawl-anywhere.com/" class="uri" target="_blank" rel="external">http://www.crawl-anywhere.com/</a>上面给出了一个基于Solr的爬虫设计器。Mahout现在是用于机器学习，特别是用于协同过滤。在Mahout上面还有所谓的Giraph，用于图模型。</p>
<p>Apache的Solr官方网站上有Solr的快速入门及参考手册。但是在Solr快速入门中，介绍的最初的方式是纯文本的东西，比如XML、JSON、CSV格式的文档的查询。<a href="http://www.ibm.com/developerworks/cn/java/j-solr-lucene/#download" class="uri" target="_blank" rel="external">http://www.ibm.com/developerworks/cn/java/j-solr-lucene/#download</a>上面的教程似乎更具有参考性。IBM上面提到了搜索引擎的新的用法。因为之间我们的理解都是搜索引擎用于搜索文本。但是Solr 4.x开始，发现了新的应用的需求。搜索引擎的核心被定义为关乎快速的、高效的过滤，然后依据某种相似度的概念对数据进行归类。搜索引擎还要能够处理稀疏数据和模糊数据，这此数据是现代数据应用程序的标志性特征。Lucene和Solr实现了各种灵活的相似性算法，还能够分析地理空间问题。这些功能使得搜索应用程序与传统的数据库应用程序（甚至是NoSQL应用）之间的界线。现在的Lucene与Solr可以说是不仅集成了数据后端（因而成为一种NoSQL），还可以自己定义复杂数据类型、数据存储、归类与分析功能。虽然搜索引擎不能解决所有的数据问题，然而我们仍然应该跳出众所周知的思维模式。</p>
<p><strong>其实，很多的数据应用都是借助于搜索与简单的分析可以解决的，并不需要那么严谨的科学研究的模式。</strong></p>
<p>欲使Solr支持PDF，还需要一些配置。参考<a href="https://wiki.apache.org/solr/UpdateRichDocuments" class="uri" target="_blank" rel="external">https://wiki.apache.org/solr/UpdateRichDocuments</a> 。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/24/150524-Scala-sbt/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/24/150524-Scala-sbt/" itemprop="url">
                  在Debian/Ubuntu系统下面的Java与Scala包
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-05-24T00:00:00+08:00">
                2015-05-24
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:15+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/05/24/150524-Scala-sbt/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/24/150524-Scala-sbt/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="java包目前在ubuntu下面的管理">Java包目前在Ubuntu下面的管理</h2>
<p>目前的情况是，许多的Java包也安装在系统当中，在系统中的路径是<code>/usr/share/doc</code>、<code>/usr/share/java</code>以及<code>/user/share/maven-repo</code>。三个路径中，<code>/usr/share/java</code>里面用于放置所需要的库，我们可以通过<code>apt-get source libjdom1-java</code>，并在当前目录下解包这个文件，然后就知道jdom1这个jar包是怎样被安装到系统当中去的了。</p>
<p>这里有一个官方的“为Java库构建deb安装包” <a href="https://wiki.debian.org/Java/MavenBuilder" class="uri" target="_blank" rel="external">https://wiki.debian.org/Java/MavenBuilder</a> 的指南。思想是利用Maven构建一个deb安装包。</p>
<p>I think a better way forward is to write a little program that takes the source jar (which most jars in the Maven central should already have) and the POM, then generate a build script that simply compiles the source jar into the binary jar. The said program should also inspect the jar file to figure out any resource files, and treat them as source files. That way, we can machine-generate Debian source packages. Granted, not all source packages produced that way would pass the requirements of the Debian Freesoftware Guideline, but I bet substantial number of Maven artifacts are simple enough that this will be actually completely satisfactory. And then humans can concentrate on harder ones.</p>
<p>对于Debian的世界来说，推荐的方式是在有二进制包的同时，提供源代码包（bin形式的包，与doc、src、dev都是不相同的）。所以目前的maven的只下载二进制包的方式与Debian的理念有一些冲突。</p>
<p>而且，目前的Java的做法的冲突的地方，就是指定了一个Java的版本之后，必须只用当前的那一个Java的版本。比如2.11.5与2.11.6就是不通用的。然而在一般的软件版本管理系统中，同一个major之下，只要比所需minor大的版本应该都是可用的。</p>
<p>The Debian folks have a standard response for this kind of attitude: “Patches are welcome.” If you don’t like it, you have the power to fix it. If you fix it, share the fixes.</p>
<p>Debian的理念是欢迎使用者在不同的情况下对软件作出修改。特别是，用户能够知道错误在什么地方，同时能够得到及时的反馈。如果应用程序出现一些错误，用户能够自己重新编译与测试这些东西。参考Debian社群契约<a href="https://www.debian.org/social_contract" class="uri" target="_blank" rel="external">https://www.debian.org/social_contract</a></p>
<p>Java与Scala的ABI规范可以参考<a href="http://blog.ometer.com/2012/01/24/the-java-ecosystem-and-scala-abi-versioning/" class="uri" target="_blank" rel="external">http://blog.ometer.com/2012/01/24/the-java-ecosystem-and-scala-abi-versioning/</a>。上面详细说明了Java与Scala的API版本管理的策略。其实主要的版本改变之后，整个工程就升级为一个“元工程”了。这个工程重要的是工程的思想，而不是工程制造出来的产品实践。</p>
<p><a href="https://wiki.debian.org/Java/MavenDebianHelper" class="uri" target="_blank" rel="external">https://wiki.debian.org/Java/MavenDebianHelper</a>上面介绍直接根据maven工程生成deb包是很容易的，只需要<code>mh_make</code>命令就可以了。但是现在Ubuntu上面好像没有这个工具了。（现在又有了）</p>
<p><a href="http://www.scala-sbt.org/0.13/tutorial/Installing-sbt-on-Linux.html" class="uri" target="_blank" rel="external">http://www.scala-sbt.org/0.13/tutorial/Installing-sbt-on-Linux.html</a>上面介绍了怎样在Linux发行版下面安装sbt。这里采用的是rpm/deb软件包的方式安装sbt。这是值得推荐的做法。但是并不一定每一个都是按照这种做法来做的。</p>
<p>生成maven的软件包可以参考所谓的jdeb与apt-repo工具，在github上面：<a href="https://github.com/tcurdt/jdeb" class="uri" target="_blank" rel="external">https://github.com/tcurdt/jdeb</a>。</p>
<h2 id="scala下面构建适用于特定系统的包">Scala下面构建适用于特定系统的包</h2>
<p>但是Scala下面的做法有了大大的不同，得益于scala-naive-packager工具。<a href="https://github.com/sbt/sbt-native-packager" class="uri" target="_blank" rel="external">https://github.com/sbt/sbt-native-packager</a>。它还是受到官方支持的sbt构建的方法。生成tar、rpm、deb等都不在话下。关于deb包的，可以参考：<a href="http://www.scala-sbt.org/sbt-native-packager/formats/debian.html" class="uri" target="_blank" rel="external">http://www.scala-sbt.org/sbt-native-packager/formats/debian.html</a>。</p>
<p>sbt-native-packager可能的缺点就是它把依赖的jar包都放在程序当中，因此，整个程序显得非常拥挤了。其实按照集群来配置的话，/usr目录是放置软件的，没有必要每个结点机器上都安装一遍，那样也太占空间了。</p>
<p>我们来看具体的做法。</p>
<p>生成deb包被看成是构建任务的一部分。所以简化到使用一个plugin的程度。首先，我们指定sbt的版本：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sbt.version = <span class="number">0.13</span><span class="number">.7</span></div></pre></td></tr></table></figure>
<p>然后，在project/plugins.sbt文件中添加如下的插件：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">addSbtPlugin(<span class="string">"com.typesafe.sbt"</span> % <span class="string">"sbt-native-packager"</span> % <span class="string">"1.0.0"</span>)</div></pre></td></tr></table></figure>
<p>之后，在build.sbt中启用相应的插件，并指定生成debian包的时候所需要的一些关键字段，比如维护者名称，开发者名称等。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">name :=<span class="string">"example-app"</span></div><div class="line">version := <span class="string">"1.0"</span></div><div class="line"></div><div class="line"><span class="comment">//enablePlugins(DebianPlugin)</span></div><div class="line">enablePlugins(<span class="type">JavaAppPackaging</span>)</div></pre></td></tr></table></figure>
<p>如果只想启用生成Debian包的功能，添加DebianPlugin模块就可以了。注意，这种方便性只能在sbt-native-packager版本不小于1.0，以及sbt版本不低于0.13.5的时候才能使用。</p>
<p>接下来，我们就要创建自己的应用程序了。比如TestApp.scala。这个文件的路径是src/main/org/scala/TestApp.scala。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">object TestApp extends App &#123;</div><div class="line">  println(&quot;IT LIVES!&quot;)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>要构建相应的工具，则使用sbt stage命令。这个时候，在target/universal/stage目录下可以看到bin、lib等目录。缺省情况下，会为JavaApp创建一个shell脚本，以及一个.bat批处理脚本。</p>
<p>接着，使用sbt universal:packageBin，sbt universal:packageZipTarball可以创建相应的tar包或者zip压缩包。这个包就可以直接发布出去了。</p>
<h2 id="构建适合于debian的包">构建适合于Debian的包</h2>
<p>要想构建.deb包，直接的操作很简单，<code>sbt debian:packageBin</code>就是在target目录下生成.deb文件的最终命令。</p>
<p>然而，在生成.deb包之前，要对一些字段进行配置，如维护者的名称，邮件，软件的描述等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">packageDescription in Debian := &quot;Example Cli&quot;</div><div class="line"></div><div class="line">maintainer in Debian := &quot;Josh Suereth&quot;</div><div class="line"></div><div class="line">name := &quot;Debian Example&quot;</div><div class="line"></div><div class="line">version := &quot;1.0&quot;</div><div class="line"></div><div class="line">maintainer := &quot;Max Smith &lt;max.smith@yourcompany.io&gt;&quot;</div><div class="line"></div><div class="line">packageSummary := &quot;Hello World Debian Package&quot;</div><div class="line"></div><div class="line">packageDescription := &quot;&quot;&quot;A fun package description of our software,</div><div class="line">  with multiple lines.&quot;&quot;&quot;</div></pre></td></tr></table></figure>
<p>整体而言，这些字段不需要怎么理解，只需要自己填上去就可以了。</p>
<p><code>sbt-native</code>支持<code>debian:package-bin</code>作为构建deb包的命令，<code>debian:lintian</code>作为使用lintian命令检查deb包是否正确的命令，以及<code>debian:gen-changes</code>作为生成.changes文件的命令。</p>
<p>为了在某种程度上能够保证软件包能够正常工作，在bulid.sbt中添加如下的依赖：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">debianPackageDependencies in <span class="type">Debian</span> ++= <span class="type">Seq</span>(<span class="string">"java2-runtime"</span>, <span class="string">"bash (&gt;= 2.05a-11)"</span>)</div><div class="line"></div><div class="line">debianPackageRecommends in <span class="type">Debian</span> += <span class="string">"git"</span></div></pre></td></tr></table></figure>
<p>如果还想自己编写DEBIAN的preinst、postinst等命令，直接写到src/debian/DEBIAN目录里面就可以了。</p>
<p>If you use the <code>packageArchetype.java_server</code> there are predefined postinst and preinst files, which start/stop the application on install/remove calls. Existing maintainer scripts will be extended not overridden. 这说明，Sbt对于布署Java服务器也有很好的支持。</p>
<p>完整的Debian配置文档，参考<a href="http://www.scala-sbt.org/sbt-native-packager/formats/debian.html" class="uri" target="_blank" rel="external">http://www.scala-sbt.org/sbt-native-packager/formats/debian.html</a>。此外，<a href="http://www.scala-sbt.org/sbt-native-packager/gettingstarted.html" class="uri" target="_blank" rel="external">http://www.scala-sbt.org/sbt-native-packager/gettingstarted.html</a>还告诉我们可以使用<code>windows:packageBin</code>生成MSI安装文档。</p>
<p>sbt-native-packager生成的Java应用有两种，一种是JavaApplication，另一种是Java Server。前者是具有一个bash/bat调用接口，后者则除了有调用脚本之外，还有一些配置文件可以使用，还能够开机自动启动（不过目前还只是支持Fedora的systemd管理工具）。</p>
<p>注：Linux的服务管理机制很多。在Ubuntu下面，默认使用的是upstart，当然，也有systemV服务管理工具。Windows下面的，则是Windows Services程序来管理开机启动的各个服务脚本。</p>
<p>今天就先到这里吧。关于Python的软件包的配置，先放在后面再说。</p>
<h2 id="sbt配置nexus软件包的方法">Sbt配置nexus软件包的方法</h2>
<p>类似于在maven中的添加软件版本库，sbt的方法是添加repositories的字段。注意里面的repositories的配置是在用户的.sbt/conf配置的repo.properties文档，内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[repositories]</div><div class="line">  local</div><div class="line">  nexus:  http://127.0.0.1:8081/nexus/content/groups/public</div><div class="line">  sonatype-snapshots:</div></pre></td></tr></table></figure>
<p>然后在conf目录中的sbtconfig.txt中添加三行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-Dsbt.global.base=E:/sbt/.sbt</div><div class="line">-Dsbt.ivy.home=E:/sbt/.ivy2</div><div class="line">-Dsbt.repository.config=E:/sbt/conf/repo.properties</div><div class="line">## 可选的选项 -Dsbt.override.build.repos=true</div><div class="line">## 这些选项也可以通过sbt_opts的环境变量进行全局的配置这样sbt执行的时候就不需要访问外网了。</div></pre></td></tr></table></figure>
<p>之后从nexus的私服下载jar包。在nexus里面需要添加typesafe的仓库。<a href="http://repo.typesafe.com/typesafe/ivy-releases" class="uri" target="_blank" rel="external">http://repo.typesafe.com/typesafe/ivy-releases</a>。但是注意一般还是要修改nexus虚拟库中的配置，需要把中央仓库放在最后，而把sbt的仓库放在前面。</p>
<p>不过nexus的配置也不是一件容易的事情。这些事情可以写成一本书了。比如<a href="http://my.oschina.net/guanzhenxing/blog/209600" class="uri" target="_blank" rel="external">http://my.oschina.net/guanzhenxing/blog/209600</a>中介绍的配置nexus的数据库的原理。</p>
<p><a href="http://www.tuicool.com/articles/vMnyIb" class="uri" target="_blank" rel="external">http://www.tuicool.com/articles/vMnyIb</a>上面告诉了我们scala的三个主站，分别是</p>
<p>安装Nexus后默认会有一个Public Repositories组，可以将其作为Maven的镜像组，并添加一些常用的第三方镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cloudera: https://repository.cloudera.com/artifactory/cloudera-repos/</div><div class="line">spring: http://repo.springsource.org/libs-release-remote/</div><div class="line">scala-tools: https://oss.sonatype.org/content/groups/scala-tools/</div></pre></td></tr></table></figure>
<p>对于Ivy镜像，我们创建一个新的虚拟组：ivy-releases，并添加以下两个镜像：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">type-safe: http://repo.typesafe.com/typesafe/ivy-releases/</div><div class="line">sbt-plugin: http://dl.bintray.com/sbt/sbt-plugin-releases/</div></pre></td></tr></table></figure>
<p>另外一种方法是直接去配置<code>~/.m2/settings.xml</code>文档。或者maven目录下面的<code>conf/settings.xml</code>文件。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/14/160514-Julia类型系统等/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/14/160514-Julia类型系统等/" itemprop="url">
                  Julia类型系统与并发
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-05-14T00:00:00+08:00">
                2015-05-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:21+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/05/14/160514-Julia类型系统等/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/14/160514-Julia类型系统等/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>一般认为有类型系统的编程语言分成静态类型系统与动态类型系统两大类。静态系统指的是每个程序表达式在程序执行之前都有一个可以计算的类型。而动态类型的类型，只是在运行的期间才被感知。面向对象的编程实践中，经常是在静态类型系统中添加一些灵活的机制。如果代码能够操作不同的类型，便称为是多态。在经典动态类型系统中，多态是显而易见的。</p>
<p>在理解动态系统的时候，需要注意binding与dispatch的区别。具体地说，绑定是把一个名子与一个类型关联起来，而dispatch指的是给出了方法，然后确定由哪个实现来执行这个方法。Julia’s type system is dynamic, but gains some of the advantages of static type systems by making it possible to indicate that certain values are of specific types. This can be of great assistance in generating efficient code, but even more significantly, it allows method dispatch on the types of function arguments to be deeply integrated with the language. Method dispatch is explored in detail in Methods, but is rooted in the type system presented here.</p>
<p>按照类型系统的理论，Julia属于那种dynamic, nominative, parametric类型。在Julia中，又有具体类型与抽象类型的区别。在Julia当中，所有的值都是一个真正的对象，而每一个真正的对象都有一个类型。整个类型系统是全连同的type graph。在Julia的世界中，“编译期类型”是没有意义的，因为只有“运行期类型”。</p>
<p>另外，在Julia中，只有值是有类型的，变量只是一个名称，具体地说，变量是与某个类型范围相绑定的名称而已。</p>
<p>在Julia中，也可以添加一些显式的类型声明，使用 <code>::</code> 来表示。有时候，可以当成是运算符来对待，就像是关系运算符一样，比如(1+2)::FloatingPoint会引发程序错误，但是(1+2)::Int则会正常返回结果。也就是运算符的结果有两种：一种结果是引发程序停止，抛出异常，另外一种，就好像是完全不起作用一样。::相当于一个类型断言。</p>
<p>在出现变量的任何的地方，包括形参当中，都可以使用类型断言。</p>
<p>类型也是我们可以抽象地定义的。比如abstract name &lt;: supertype定义了一个上界为supertype的类型（不过，它到底算是一个类型变量呢，还是一个类型常量呢？）。上界有时候可以省略。（不过，也许这不成为问题，因为没有说类型系统的结构是一个线必序集，它只需要是一个偏序集就可以了）。抽象类型的超类是所谓的Any类型。</p>
<p>Thus, abstract types allow programmers to write generic functions that can later be used as the default method by many combinations of concrete types. Thanks to multiple dispatch, the programmer has full control over whether the default or more specific method is used.</p>
<p>另外，具体类型可能是指的在程序运行期间会占据值的那些类型。比如具体的无符号短整型数据。比如bitstype 16 Float16 &lt;: FloatingPoint就定义了一个具体的“比特类型”。</p>
<p>具体类型与抽象类型的区别可能在于，具体类型是负责实际的操作的，而抽象类型则提供的仅仅是检查操作合法性的功能。也就是抽象类型可以看成是纯粹的逻辑检查，但是具体类型则同时是与内存分配相绑定的。</p>
<p>Julia的类型可以进行组合，就像是结构体那样（其实语法与C的结构体类似）。</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> Foo</div><div class="line">bar</div><div class="line">baz<span class="type">::</span><span class="built_in">Int</span></div><div class="line">qux<span class="type">::</span><span class="built_in">Float64</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>可以使用构造函数来产生新类，以及给某个类型的变量新的值。（不使用new方法）。</p>
<p>另外，如果定义的一个类型完全没有任何的成员，比如</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">type</span> NoField</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>那么，这个类型就对应着一个单件（singleton）。使用is(NoFields(), NoFields())得到的结果就是true(is用于判断两个对象是否是同一个对象）。</p>
<p>如果需要不可变类型，那么就在类型声明中，用immutable关键字代替type。看起来，不可变类型的每一次求值的时候都需要新的内存空间。但是其实问题没有这么简单。实现不可变类型的开销，可能并不比可变类型高多少。在Julia当中，可变类型是按照引用传递的，而不可变类型中通过copy来赋值的。这意味着把变量赋给一个可变类型的时候，并不会创建一个新的对象。</p>
<p>抽象类型、比特类型、组合类型是Julia的三种基本类型。此外，Julia还支持元组类型，也就是用(Int, String)来当成新的类型。这种类型之间也是可以比较的。另外，类型还可以合并起来，比如IntOrString = Union(Int, String)，表示这个东西为一个整数或者字符型。</p>
<p>为了支持泛型编程，Julia还有含参类型。含参类型有一个类型参数。比如</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">type</span> Point&#123;T&#125;</div><div class="line">x<span class="type">::</span>T</div><div class="line">y<span class="type">::</span>T</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>使用 <code>Point{Float64}</code> 可以构造出一个类。它就好像是Point这个类具有一个类型参数，当类型参数给出来的时候，Point类就调用它的构造函数，然后生成一个新的类型一样。注意Point是抽象类型，但是构造出来的是具体类型。</p>
<p>In other words, in the parlance of type theory, Julia’s type parameters are invariant, rather than being covariant (or even contravariant). This is for practical reasons: while any instance of Point{Float64} may conceptually be like an instance of Point{Real} as well, the two types have different representations in memory:</p>
<p>这真的应该参考类型理论了。</p>
<p>在Julia当中，函数是一个把一个参数元组映射一个返回值的类型。所以，在实践中，函数是非常抽象的类型概念。而在Julia中，把函数的实现，也就是把具体的执行看成是一个方法。显然可能会有多种对应。这种对应的过程称为分派(dispatch)。</p>
<p>The choice of which method to execute when a function is applied is called dispatch. Julia allows the dispatch process to choose which of a function’s methods to call based on the number of arguments given, and on the types of all of the function’s arguments. This is different than traditional object-oriented languages, where dispatch occurs based only on the first argument, which often has a special argument syntax, and is sometimes implied rather than explicitly written as an argument. [1] Using all of a function’s arguments to choose which method should be invoked, rather than just the first, is known as multiple dispatch. Multiple dispatch is particularly useful for mathematical code, where it makes little sense to artificially deem the operations to “belong” to one argument more than any of the others: does the addition operation in x + y belong to x any more than it does to y? The implementation of a mathematical operator generally depends on the types of all of its arguments. Even beyond mathematical operations, however, multiple dispatch ends up being a powerful and convenient paradigm for structuring and organizing programs.</p>
<p>里面提出一个不依赖于算术优先级文法的概念，比如x+y为什么调用的是x的方法而不是调用的y的方法？这个问题的提出的情景是这样的，对于一般的函数而言，可能应用的方法是很简单的，很确定，因为f(x,y)很容易确定是哪个函数。但是如果函数采用的是中缀的形式，那么问题就出现了。在出现中缀的地方，可能dispatch的意义更大。对于a f b这样形式的函数，我们知道f是一个纯粹的标签而已，但是这个方法是独立的方法，还是a的一个方法，或者b的方法。在多种可能的情况下，dispatch就显得必要了。</p>
<p>还有，如果参数允许多种类型的话，那么实际上函数代码中的行为也是不确定的。</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(a,b)</div><div class="line"> a +b </div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>对于这种情况，如果a是整数，那么+调用的是整型的+方法；但是a也可以是浮点类型，这样的话，就要调用不同的方法了。如果把+看成是一个方法的话，那么，确实+绑定的是哪一个方法是不确定的。但是在C++当中就没有这样的问题。</p>
<p>利用methods(f)可以查看当前的名子有多少种定义。比如+号，有92种定义。</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">table = methods(+)</div><div class="line">length(table)</div></pre></td></tr></table></figure>
<p>multiple Dispatch（多重分派）机制可以产生神奇的效果，比如</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">same_type&#123;T&#125;(x<span class="type">::</span>T, y<span class="type">::</span>T) = <span class="literal">true</span></div><div class="line">same_type(x,y) = <span class="literal">false</span></div></pre></td></tr></table></figure>
<p>上面的代码实际上是两个函数的定义，但是前一个定义的优先级更高，所以使用这种方法，可以实现一个判断两个变量的类型是否相等的函数。但是实际的执行是这样的：如果两个类型相同，调用的是第一个定义的方法；如果是其它情况，就匹配到后一个方法。结果，这样就可以调用same_type了。但是定义的方式确实是很特殊的。从中我们可以很明显地看到，同一个函数，可以绑定到不同的方法，而且是在运行期间决定的。</p>
<p>判断是否是同一个函数有一些不同的标准。如果仅仅看名称，就是Julia这里的。但是数学上，也许更习惯把函数的参数类型也当成函数的一部分，那时候就有不同的处理的方式。不过在动态类型的语言中，区分“函数”与“方法”确实是有必要的。</p>
<p>具有可选参数的函数，实际上在定义的时候同时产生了几种不同的方法。</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">f(a=<span class="number">1</span>,b=<span class="number">2</span>) = a + b</div><div class="line">methods(f)</div></pre></td></tr></table></figure>
<p>将会查看到f有三个方法绑定。（这种情况下，似乎只要定义函数的时候使用了模式匹配，并且分成了多个句子，似乎都可以看成是多分派的语言了）。</p>
<h2 id="构造函数">构造函数</h2>
<p>在Julia当中，构造子被理解成创建新的对象的函数。这与面向对象语言有一些不同（面向对象倾向于把构造函数理解成类的初始化的过程）。不过，在函数式与面向对象的结合中，把构造子理解成创建新对象的函数确实是更好一些。</p>
<p>在函数式与面向对象的结合的过程中，区分外部构造方法与内部构造方法有一些必要。外部构造方法就是像函数式那样，由一个与类同名的，但是不属于这个类的函数构成。而内部构造方法，则在声明类型的过程中，在类型里面的那些与类同名的函数。</p>
<p>如何在类里面使用这个类的一个对象？这个看起来是很困难的。但是Julia允许这么做而不出现问题。</p>
<h2 id="参数类型提升">参数类型提升</h2>
<p>这基本是和类型转换一个含义。关键在于是否允许自动类型提升。在分类上，Julia是属于那类不允许自动类型转换的语言。使用convert(Type, var)来进行显式的转换。</p>
<h2 id="julia的模块">Julia的模块</h2>
<p>模块使用module来声明，使用export来导出可被利用的函数，使用using或者import来应用。</p>
<p>元编程语言：The strongest legacy of Lisp in the Julia language is its metaprogramming support. Like Lisp, Julia represents its own code as a data structure of the language itself. Since code is represented by objects that can be created and manipulated from within the language, it is possible for a program to transform and generate its own code. This allows sophisticated code generation without extra build steps, and also allows true Lisp-style macros operating at the level of abstract syntax trees. In contrast, preprocessor “macro” systems, like that of C and C++, perform textual manipulation and substitution before any actual parsing or interpretation occurs. Because all data types and code in Julia are represented by Julia data structures, powerful reflection capabilities are available to explore the internals of a program and its types just like any other data.</p>
<p>元编程是把程序与数据混在一起，可以把数据当成程序看待。比如parse(“1+1”)，把字符串1+1当成Julia代码。这种机制下，显然是运行期的特性，而且还要暴露编译器的结构。</p>
<p>利用dump()，还可以把程序变成数据（序列化的一种）。</p>
<p>介于字符串数据与程序之间的是所谓的symbol。一个symbol使用:symbolname来声明。symbol是不可变类型，因此:foo = symbol(“foo”)。symbol里面可以是任何的表达式，所以ex = :(a+b*c+1)也是合法的表达式。使用ex = :(<span class="math inline">\(a+b*\)</span>c+1)的时候，带美元符号的变量会被立即被其值替换。</p>
<p>表达式可以使用eval()函数，根据当前的程序的上下文求出值。这对于符号计算来说可能是必须的。</p>
<p>元编程与宏又比较接近了。</p>
<h2 id="julia的异步与并行支持">Julia的异步与并行支持</h2>
<p>按理说这应该是重点所在，但是现在还不容易理解它们。Julia使用Task的概念来描述一个异步过程。</p>
<p>运行julia -p n可以开启一个<code>n</code>个工作进程的程序。使用remotecall()可以调用另外线程的程序，借此可以实现并行编程的功能。</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">//julia -p <span class="number">4</span></div><div class="line">r = remotecall(<span class="number">2</span>, rand, <span class="number">2</span>,<span class="number">2</span>)</div><div class="line">fetch(r)</div></pre></td></tr></table></figure>
<p>The first argument to remotecall() is the index of the process that will do the work. Most parallel programming in Julia does not reference specific processes or the number of processes available, but remotecall() is considered a low-level interface providing finer control. The second argument to remotecall() is the function to call, and the remaining arguments will be passed to this function. As you can see, in the first line we asked process 2 to construct a 2-by-2 random matrix, and in the second line we asked it to add 1 to it. The result of both calculations is available in the two remote references, r and s. The <code>@spawnat</code> macro evaluates the expression in the second argument on the process specified by the first argument.</p>
<p>通过并行编程的方法也是使用装饰器。它可以把Julia的模块分散到多个工作进程中。</p>
<p>个人认为，在并行计算的情况下，如何保证机器不会运行在内存不够而经常使用交换空间，以及让机器随时能够保持响应是关键的。因为在并行计算的时候，总是要消耗很多的资源。但是确定资源是否够用也很重要。如果不够用，那就只能进入死机状态了。</p>
<p>Julia对于SSH方式工作也有支持。可以用来管理不同的机器。</p>
<p>运行Shell命令，使用 <code>run(`echo hello`)</code> 。其中左单引号表示一个外部程序。括号里面的美元符号里面的变量，同样地会被替换。</p>
<p>Julia对外部程序的支持是非常全面的，可以参考 http://docs.julialang.org/en/release-0.3/manual/running-external-programs/ 。管道等方式的运用，就好像是在Shell自身当中一样。通过julia.h，也可以在C中嵌入Julia的代码。</p>
<h2 id="julia的包管理功能">Julia的包管理功能</h2>
<p>包管理功能是通过github来实现的。通过Pkg来管理。</p>
<p><code>@time</code>装饰器可以在执行代码的时候显示时间和内存使用报告。</p>
<p>其实Julia实现这么多的特性，靠的大多也还是装饰器。在Base.Test中提供了大量的装饰器。</p>
<p>Jeff: Julia基于多分派（multiple dispatch）。这是一种强大的面向对象编程机制，以前其他语言也用过，但出于某些原因从未真正流行起来。我们设计的多分派旨在定义具有多种形式和行为的数学函数，事实证明它也能用于其他情形。它在“你能表达什么”和“编译器能用它做什么”之间达到了很好的平衡。</p>
<h2 id="julia的更多的特性">Julia的更多的特性</h2>
<p>感觉之前在看Julia的维基百科的时候自己都没有看仔细，漏掉了很多的重要的东西。比如在Julia中，有几个非常有用的软件包，PyPlot与SIUnits。</p>
<p>以及比较重要的一类调用其它语言的代码的宏包JavaCall、Mathematica。两者分别可以实现在Julia中调用Java与Mathematica的代码。在维基百科上还介绍了使用Julia调用Torch的代码的程序。使用Spark可以调用Spark，以及调用Hadoop的大数据。虽然Julia使用积极求值的策略，但是通过Lazy.jl包，也可以实现惰性求值。</p>
<p>通过Rcall可以在Julia中调用R，反过来，通过RJulia可以在R里调用Julia。</p>
<p>虽然支持Lisp-like宏，但是大多数时候，宏是不向应用程序的开发者提供的。就像Java中的Lambda与反射一样。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/13/160513-Julia编程基础/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/13/160513-Julia编程基础/" itemprop="url">
                  Julia编程语言基础知识
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-05-13T00:00:00+08:00">
                2015-05-13
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:21+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/05/13/160513-Julia编程基础/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/13/160513-Julia编程基础/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>也许这个编程语言才真正贴近科学计算的真实需求。见<a href="http://en.wikipedia.org/wiki/Julia_%28programming_language%29" target="_blank" rel="external">http://en.wikipedia.org/wiki/Julia_%28programming_language%29</a>。在Ubuntu下面可以直接安装它。</p>
<p>基本的定位是，发明于2012年，多范式（面向对象、过程、函数式加元编程语言），具有动态类型，以及类型注解功能。受到很多高级动态语言的启发。同样地，它也是一个高级动态编程语言，但是对于高性能数值计算与科学计算非常重视。对于通用编程也有一定的效率。注：其实是2009年开发，2012年释出开源版本。</p>
<p>Julia具有一个参数类型的类型系统。使用并行与分布式计算，并且可以直接调用C与Fortran的接口库。而且具有自动内存回收的功能。它的浮点数库、线性代数库、随机数生成、快速傅里叶变换以及正则表达式匹配都非常有效率。目前的版本是0.4。</p>
<p>自己试用了Ubuntu上面的Julia，即使是在命令行界面之下，也有非常好的视觉效果。Julia有一个同名的交互式Shell(正式称呼是Julia REPL)，便于学习和测试程序代码。</p>
<p>Julia直接管理在线的包。因为它的包可以直接从Github上面获取。Julia有JavaCall，Mathematica等，面向R的是Rcall。，可以直接从这些语言里面调用程序。</p>
<p>Julia的其中的一个目标是像R一样好用。Julia的加号等运算符同样地是一种语法糖。</p>
<p>Julia的核心是用C和C++写成的，解析器使用Schema，而Just-in-time编译器使用了LLVM的机制。Julia的JIT是通过LLVM实现的。</p>
<p>其实我们看重的还是Julia的语法功能，其表现力更重要。至于实现，则不用那么重要。就像对于Scala，我们看重的仍是其语法、语义模型等。</p>
<p>关于REPL: A read–eval–print loop (REPL), also known as an interactive toplevel or language shell, is a simple, interactive computer programming environment that takes single user inputs (i.e. single expressions), evaluates them, and returns the result to the user; a program written in a REPL environment is executed piecewise. The term is most usually used to refer to programming interfaces similar to the classic Lisp machine interactive environment. Common examples include command line shells and similar environments for programming languages.</p>
<p>实际上，可以使很多的语言都变成REPL方式工作。参考<a href="http://repl.it/languages" class="uri" target="_blank" rel="external">http://repl.it/languages</a>上面的一个在线的REPL程序，包含了各种程序实现。</p>
<p>虽然julia命令直接打开一个REPL，但是官方还是推荐使用IJulia（以后会改名为Jupyter）。安装它是非常简单的，打开julia,输入Pkg.add(“IJulia”)即可。然后使用Pkg.update()或者Pkg.build(“IJulia”)可以执行更多的包管理的功能。启动IJulia的时候，可以通过打开julia控制台，然后输入：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">using</span> IJulia</div><div class="line">notebook()</div></pre></td></tr></table></figure>
<p>或者使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipython notebook --profile julia</div></pre></td></tr></table></figure>
<h2 id="下面还是浏览一下julia的基本的功能">下面还是浏览一下Julia的基本的功能</h2>
<p>通过说明书<a href="http://docs.julialang.org/en/latest/manual/" class="uri" target="_blank" rel="external">http://docs.julialang.org/en/latest/manual/</a>来看，内容还是比较简单的。但是里面其实不简单。包括了元编程，并行编程等概念。</p>
<p>下面我们一点点解决相关的问题。</p>
<p>在导言的部分，作者指出科学计算有追求高性能的传统。但是目前的情况下，这些科学计算的专家们经常使用较慢的动态语言当成日常的工作。现在随着编译技术的进步等，这些人现在可以使用动态语言的同时写出高效率的工作。同时，JIT、REPL等的进步，也使得交互式工作变得越来越容易了。Julia就在这种情况下应运而生。</p>
<p>Julia的设计其实是沿着经典的数学编程语言（mathematical programming languages）的设计路线，并不同于通用编程语言的路线（虽然从编程语言原理上看没有什么区别，但是在现实中，我们完全可以把通用编程语言，数学编程语言，以及领域专用语言看成是编程语言原理的不同的领域的应用，以致于在讲通用编程语言的机制的时候，几乎完全不适用于领域专用语言。现在，这些语言又有进一步融合的趋势。</p>
<p>作者提到，动态语言并不是没有类型的：虽然大多数情况下类型不用声明，而且会自动进行转换，结果开发人员好像不用考虑类型的问题一样。其实对于静态语言，我们也可以说，类型完全是编译期的一个概念，运行期完全没有那样的一回事。</p>
<h2 id="变量与赋值">变量与赋值</h2>
<p>Julia当中的变量支持使用unicode的字符，但是变量名不能是保留字。赋值使用一般的等号，字符串字面量当中，Unicode是自然而然的。另外，也可以使用latex风格的变量名称，这其实就是把变量以数学模式开始和结束而已，没有什么好奇怪的。</p>
<p>Julia的建议的风格是：变量名以小写的字母开始，同时不使用下划线，而使用大写字母使变量显得紧凑。另外，如果是函数，建议最后加一个叹号，表示这个函数是一个改变状态的函数（也称为过程）。这样可以与函数式风格明显地区别开。</p>
<p>Julia对于常见的类型（整型、无符号整型、长整型、布尔型、字符型、浮点型）都有支持。Julia是动态类型语言，由此它有typeof函数，该函数接受一个变量为参数，然后返回一个类型。我们还可以把类型当成一个值赋给一个变量，这个变量就是一个类型变量了。下面是在Julia当中合法的操作：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">my_type = typeof(<span class="number">123</span>)</div><div class="line">my_type <span class="type">&lt;:</span> <span class="built_in">Int</span></div></pre></td></tr></table></figure>
<p>其中，<code>&lt;:</code>是类的操作符，表示一个子类型。第二条语句运行的结果就是True，因为Int64确实是Int的子类型。另外，整数可以用0x之类的前缀表示，以支持不同进制的字面量输入。另外，使用isa(var, Type)可以判断某个变量是否属于某个类型。</p>
<p>Julia的类型系统直接暴露于程序员可见的范围。比如，通过typemin(T)、typemax(T)可以得到相关类型的表示范围中的极小值与极大值。这比C实践中的方法方便多了。注意，在Julia当中，实行的是所谓的模态算术。因此typemax(Int64)+1 == typemin(Int64)为真。也就是说，整数的加减是循环的。这种数学的处理，大大方便了对于数值操作的溢出的概念。使用bits函数，可以得到数据的内部字节表示。另外，Julia的浮点数的处理的机制按照IEEE 754规范，因此具有Inf、NaN之类的量。使用eps()函数，可以得到浮点类型的机器的最小精度。</p>
<p>浮点数与整数的处理，可以参考<a href="http://docs.julialang.org/en/release-0.3/manual/integers-and-floating-point-numbers/" class="uri" target="_blank" rel="external">http://docs.julialang.org/en/release-0.3/manual/integers-and-floating-point-numbers/</a>。个人觉得，这可以作为高级编程语言的进一步的知识，让学习者可以掌握编程语言处理科学数据的规范。</p>
<p>Julia实现了GMP与MPFR库基础上的变长精度浮点运算。任意长的整数的运算，使用的类型是BigInt。通过BigInt(“2342342342342”)可以制造出这样的大整数来，也可以由其它的整数转换而来。</p>
<p>Julia的乘法运算，有时候可以省略掉中间的乘号。这种方法在符号计算语言中已经实行了很久了。现在只是告诉我们，Julia也具有这种方便性而已。Julia也支持使用 <code>^</code> 来做取指的运算。但是要注意取指的优先级。如果乘法在前面，那么省略号与否，取指的优先级都是高的。但是如果是先做取指再做乘法，就不一样了。<code>2^5x</code>将被翻译成<code>2^(5x)</code>，而<code>2^5*x</code>被翻译成<code>(2^5)*x</code> 。而<code>5x^2==5(x^2)</code>、<code>5*x^2=5*(x^2)</code>。这说明，怎样求值不只是算术优先级的问题，与算术运算符的前后顺序也有关系。</p>
<p>但是需要注意的是，Julia的省略乘号的做法可能会与其编程范式产生冲突。比如(x-1)(x+2)。因为任何表达式都是返回类型的，而对一个表达式应用<code>()</code>，相当于把这个表达式看成一个函数（在Julia中，BigInt也是一个对象，因此有()方法；函数在Juila中使用f()来应用，但是调用的实际上是f.apply()方法），因此便会出错。这一点是我们需要注意的。一般来说，因为函数式加上面向对象的方法中，类也是一个类型，而函数正是一个具有apply方法的类型，所以就有可能与构造函数冲突。但是面向对象加上函数式比较容易解决这个问题，而如果加上省略乘号运算符，可能语法分析就出现困难了。）。在编程实践中， <strong>面对多范式语言，必须小心语法冲突</strong> 。</p>
<p>Julia把类型也当成是值，具有一种优点，那就是我们想得到某个类型的特殊的元素的时候，可以直接通过类的方法产生，比如one(Int32)、zero(Int32)分别产生这个类型的单位元与零元，前面的typemin与typemax函数也是这样。 <strong>但是，如果我们能够通过Int32.zero这样的属性或者方法产生类型的单位元与零元的时候，相信会更方便</strong> 。</p>
<p>Julia作为科学计算语言，支持的运算符的种类是非常多的。加减乘除取指取模都是不例外的。对于除法，还有除与反除两种(视斜杠方向不同)。除此之外，还有按位运算，如~、&amp;, &gt;&gt;, &lt;&lt;,等。具体参考<a href="http://docs.julialang.org/en/release-0.3/manual/mathematical-operations/" class="uri" target="_blank" rel="external">http://docs.julialang.org/en/release-0.3/manual/mathematical-operations/</a>。注意&lt;!&gt;是逻辑非，不是按位的反转。Julia也提供了+=这样的重新赋值操作，实际上，任何二元运算符都可以这么做。</p>
<p>运算符一般来说是按照类别分的，不同类别的含义不同。一般来说，分成算术运算，比较运算、逻辑运算和按位运算等几类。具有C++赋值特性的，只能是算术运算符，因为此时我们认为算术运算符返回的类型与第一个变量的类型是相同的。</p>
<p>Julia还支持比较运算符的累积，这是与Python相一致的，比如1&lt;2&lt;=3这样的表达式是有意义的。</p>
<p><a href="http://docs.julialang.org/en/release-0.3/manual/mathematical-operations/" class="uri" target="_blank" rel="external">http://docs.julialang.org/en/release-0.3/manual/mathematical-operations/</a>里面提供了大量的运算符与类型的特殊函数(数学函数)，有需要可以参考一下。</p>
<p>另外，Julia支持以a+b*im的形式表达复数，以及使用a//b的形式表达有理数，这些也是科学计算语言的必备的特性。(准确地说，科学计算语言的基本数据类型)</p>
<p>科学计算语言通常也有字符与字符串类型的支持。字符串是被当成数组对待的，因此具有中括号方法。</p>
<p>在Julia中，字符串可以直接引用一个变量，这时候使用美元符号引导。因此用双引号括起来的字符串，里面的字符可以被转义，也可以被求值。甚至可以在字符串中使用<code>$name</code>, abc, (1+2)这样的复杂的形式。这里，name被变量值替换，而1+2被求值。</p>
<p>Julia中的字符串不想被转义的话，可以在前面添加一个r，与Python类似。Julia的正则表达式与PCRE是兼容的。r代表的实际上是后面的字符是一个正则表达式字符串。比特数组使用b“DATA”这样的字面形式表示。另外，v“0.2”表示一个版本号类型，具有版本号的一些比较运算符，这是为了方便某些操作吧。版本号的比较机制，可以参考<a href="http://docs.julialang.org/en/release-0.3/manual/strings/" class="uri" target="_blank" rel="external">http://docs.julialang.org/en/release-0.3/manual/strings/</a>。</p>
<h2 id="julia的函数">Julia的函数</h2>
<p>Julia的函数体可以使用</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f(x,y)</div><div class="line">	x + y</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>最后一个表达式的值，默认作为返回的值。另外，也可以使用f(x,y) = x+y来定义一个函数。此时表达式不会被求值。(注意，表达式与表达式被求值是完全不同的概念）。</p>
<p>此外，函数名也可以作为一个变量被赋值，比如g=f，这时候便可以用g(x,y)来调用f(x,y)。另外，函数求值实际上是调用方法，所以可以使用apply(f,2,3)。(不过，直接使用f.apply(2,3)可能是不被允许的（也许像Python那样处理的吧）。</p>
<p>因为Julia支持使用Unicode字符，所以有些时候语法会很奇妙，比如可以直接把Unicode字符的求和<code>\sigma</code>当成函数名称。</p>
<p>函数也可以显式添加return语句。在Julia中，运算符也是函数，所以使用+(1,2,3)以及f = + 也是被允许的。Scala也有这样的特性，但是不知道形式语言理论是怎么说的。</p>
<p>在Julia中，组成数组与Python中一样方便，a, b就组成了一个数组。所以表达式a,b返回的是两个表达式的和按照顺序组成一个数组。x, y = 1, 2这样的赋值语句，也是被容许的。Julia的函数也支持可选参数，做法与Python类似，此外，如果有可选参数名称，显式指定可选参数的时候，位置可以替换。</p>
<p>定义函数的时候发生了什么：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">function</span> f (x, y )</div><div class="line"> x + y</div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>实际上，函数的参数是在比x+y高一个作用域的位置，但是低于可见作用域。而且，参数得到值的过程是从左到右按照顺序来的。所以f(x, y = x)不会发生错误，但是f(y, x = y)却会报“变量未定义”的错误。其实我们可以看成是函数的参数是在执行之前被构造出来的过程，在动态语言中，调用f(1)相当于实际执行的是：</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">eval (x = <span class="number">1</span>)</div><div class="line">// 判断出参数有一个，所以</div><div class="line">eval (y = x)</div><div class="line">x = y</div></pre></td></tr></table></figure>
<p>执行中，左边的形参先得到其值，右边的形参稍后。所以，虽然直觉上可能认为函数的形参取得参数是并行的，但是其实并不是这样。</p>
<h3 id="mapreduce特性">MapReduce特性</h3>
<p>为了方便书写把一个函数作为参数传递到其它的函数，julia使用do语法，比如</p>
<figure class="highlight julia"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">map([A, B, C]) <span class="keyword">do</span> x</div><div class="line">    <span class="keyword">if</span> x &lt; <span class="number">0</span> &amp;&amp; iseven(x)</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span></div><div class="line">    <span class="keyword">elseif</span> x == <span class="number">0</span></div><div class="line">        <span class="keyword">return</span> <span class="number">1</span></div><div class="line">    <span class="keyword">else</span></div><div class="line">        <span class="keyword">return</span> x</div><div class="line">    <span class="keyword">end</span></div><div class="line"><span class="keyword">end</span></div></pre></td></tr></table></figure>
<p>该语句的含义是创建一个以x为参数的匿名函数，后面是该匿名函数的体。最后，do会把这个函数当成是第一个参数传递给map()函数。这与Python语言中的with语句有一些相像。</p>
<p>Julia的控制流可以使用(sentence; sentence; sentence)表示，小括号可以换成begin .. end。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2015/05/04/150504-Scala的一些重要特性/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2015/05/04/150504-Scala的一些重要特性/" itemprop="url">
                  Scala的一些设计特点
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2015-05-04T00:00:00+08:00">
                2015-05-04
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:15+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2015/05/04/150504-Scala的一些重要特性/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2015/05/04/150504-Scala的一些重要特性/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先，Scala中的几乎所有的语言元素都是表达式。也就是返回一个值。另外，Scala中的val实际上是“常量”，或者说，“字面变量”的意思。相当于给常量一个名子。对于编程实践与软件工程具有重要性。</p>
<p>函数可以用def语句定义也可以使用val语句来定义。主要是看有没有小括号方法。这一点就很容易混少淆了：def与val定义的函数在实质上有什么区别呢？</p>
<figure class="highlight plain"><figcaption><span>.scala&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def square(a: Int)  = a * a</div><div class="line">def squareWithBlock(a: Int) = &#123; a * a&#125;</div><div class="line">val squareVal = (a: Int) =&gt; a * a</div></pre></td></tr></table></figure>
<p>Scala的变量的使用的时候不需要指明类型，而且Scala支持按值传递与按名传递，所以就有了不同的模式。试着把函数定义为 <code>def log(msg: String)</code> 与把函数定义为 <code>def log(msg: =&gt; String)</code> 都不会使 <code>log(MSG + 1 / 0 )</code> 出现编译期错误。然而后者是按名传递，所以1/0不会被求值，也就不会在运行期出现错误。按名传递的优点是可以避免不必要的计算。</p>
<p>标准的调用类的方式是使用new方法。</p>
<p>柯里化currying的意思是允许一个函数的多次调用，并且只有最后一次调用的时候返回的是正常的值，中间的所有的调用只是产生一个特定函数（参数被确定了）。</p>
<p>Traits就像是一个Interface。但是可以有函数体。</p>
<h2 id="模式匹配特性">模式匹配特性</h2>
<p>自己中间的时候接触到了模式匹配。模式匹配与switch case语句最大的匹别就是它可以直接匹配一个类型而不单单是匹配在一个值。在支持高阶函数等特性的语言中，模式匹配是很强大的，尤其是用来构造一个分析器。</p>
<figure class="highlight plain"><figcaption><span>.sh&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def fib(int: Any) : Int = in match &#123;</div><div class="line">    case 0 =&gt; 0</div><div class="line">    case 1 =&gt; 1</div><div class="line">    case n: Int =&gt; fib(n-1) + fib(n-2)</div><div class="line">    case _ =&gt; 0</div><div class="line">    case n: String =&gt; fib(n.toInt)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>注意上面的后两个匹配条件。它显然容许了final类型的匹配，以及在泛型的情况下，如果匹配到一个字符串的类型，就把它处理成整数后再计算。这对于应用程序传参是非常有利的。应该是比具有变长参数的函数传递，以及Key=Value方法的传递更自由。</p>
<h2 id="实例类">实例类</h2>
<p>一个函数与一个类有什么样的区别呢？在函数的调用的时候，以及类的构造的时候，都是使用所谓的小括号的表达式。但是不同之处在于，给类传递参数的时候，类的参数会持久化起来。因为类有存储空间。这样的话，类的参数的信息实际上是保留下来了。于是我们可以认为类是一个惰性的函数。即使被调用的时候，里面的参数也保存了下来。请看下面的写法：</p>
<figure class="highlight plain"><figcaption><span>.scala&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">abstract class Expr </div><div class="line">case class FibExpr(n : Int) extends Expr &#123;</div><div class="line">    require(n &gt;= 0)</div><div class="line">&#125;</div><div class="line">case class SumExpr(a: Expr, b: Expr) extends Expr</div><div class="line">def value(in: Expr): Int = in match &#123;</div><div class="line">    case FibExpr(0) =&gt; 0</div><div class="line">    case FibExpr(1) =&gt; 1</div><div class="line">    case FibExpr(n) =&gt; value(SumExpr(Fib(n-1), Fib(n-2)))</div><div class="line">    case SumExpr(a,b) =&gt; value(a) + value(b)</div><div class="line">    case _ =&gt; 0</div><div class="line">&#125;</div><div class="line">println(value(FibExpr(3)))</div></pre></td></tr></table></figure>
<p>工作的时候，FibExpr(0)作为一个参数被匹配。因为FibExpr是一个实例类，所以实例类中的成员都保存了下来。在语义上，FibExpr出现在Case中，表示该类的名称是FibExpr，同时它的传值是0。正好匹配。这样的话，一个类的对象更像是一个实体。因为我们可以拿两个类的构造函数直接比较。</p>
<p>因为函数式语言可以直接将函数作为传递的参数。同时函数式语言中函数的声明与操纵往往很方便，所以判断也是很容易的。比如Scala中|list.exists(_ % 2 ==1)|就表示判断列表当中有没有奇数。</p>
<h2 id="函数式语言中的map-reduce">函数式语言中的Map-Reduce</h2>
<p>在Scala中实现Map和Reduce是非常直接的。因为List对象直接有map方法，而且map的参数就是一个函数。另外，map后可以直接使用reduceLeft这样的函数。用于把列表折叠起来。假设StrList是一个包含字符串的列表，那么下面的方法就用MapReduce实现了一个统计列表中的单词总数的方法：</p>
<figure class="highlight plain"><figcaption><span>.scala&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">def wordCount(str: String): Int = str.split(&quot; &quot;).count(&quot;msg&quot;==_)</div><div class="line">file.map(wordCount).reduceLeft(_+_)</div></pre></td></tr></table></figure>
<p>Map的参数是一个正常的，操纵单个元素的函数是很常见的。许多向量式的语言就有这个特性。但是我们对于reduce函数却生疏一些。因为reduce要把许多元素结合起来。所以reduce函数的执行有两个要素，第一个是怎么结合子元素，第二是怎样执行合并的次序。reduceLeft函数的参数告诉我们，从左到右，两个元素依次相加，返回的元素再和右边的元素相加，直到最后一个元素被处理。</p>
<p>Scala还具有优化尾递归的能力。因为在函数式语言中，尾递归的效率比C++之类的要高很多。在编译器就会全部优化这些东西。</p>
<p>Scala的for也是函数式的for。意思是依次读取列表中的元素，生成一个新的列表。在for当中使用yield可以返回值。比如：</p>
<figure class="highlight plain"><figcaption><span>.scala&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">val counts = for (line &lt;- file) yield wordCount(line)</div><div class="line">val num = counts.reduceLeft(_+_)</div></pre></td></tr></table></figure>
<p>总而言之，Scala对于多种编程方式都有支持，它们完成的任务都类似。关键还是看风格的问题了。现在我们缺的不是先进的编程方法，而是如何更好地运用这样的编程方法。</p>
<p>模式匹配的应用范围很广。比如在得到一个值的时候，返回的是错误该怎么办？通常情况下就要进行错误处理了。但是这样其实很麻烦。更好的做法，而且不打断业务逻辑的做法就是使用内容匹配。</p>
<p>处理错误通常发生在同样具有意义的函数的高层。通常而言是由某个操作所引起的。因此都是放在try块当中。使用错误处理的时候，利用match方法更为简洁，这是因为，处理错误的代码与算法的代码被分割了。比如</p>
<figure class="highlight plain"><figcaption><span>.scala&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">val osName = getProperty(&quot;os.name&quot;)</div><div class="line">osName match &#123;</div><div class="line">    case Some(value) =&gt; println(value)</div><div class="line">    case _ =&gt; println(&quot;none&quot;)</div><div class="line">&#125;</div><div class="line">println(osName.getOrElse(&quot;none&quot;))</div><div class="line">osName.foreach(print _)</div></pre></td></tr></table></figure>
<p>Scala的lazy初始化也是一个具有重要意义的特性。其重点在于把耗时的操作推后，放在尽可能需要做的时候才开始做。特别是访问网络。比如一个类需要访问网址的时候，最好的方法可能不是在构造类的时候就开始做，而是首次访问网络的时候。这个时候用lazy操作就可以了。另外，lazy操作中调用lazy函数的时候，操作也不会立即完成。只有lazy变量被首次使用的时候，才逐步执行lazy变量的初始化。</p>
<h2 id="scala的并发">Scala的并发</h2>
<p>Scala的并发主要是Actor库。Actor是Scala的并发模型。而2.10之后，推荐Akka作为Scala的Actor的实现。Actor类似于一个线程，有一个邮箱。Actor可以通过system.actorOf来创建，通过receive来获取消息，用叹号发送消息。实现了语言级别对于并行的支持。Actor还有一个DSL可以使用。Actor是比线程还较量的并发的实现。因为Scala可以实现线程的复用。</p>
<p>Scala通过future实现异步的返回。另外，对于列表，Scala还能够形成并行集合。像普通并行计算那样进入并行区。通过par.map方法就可以实现并行的map操作了。不过，这里的并行，主要是利用多核的能力。</p>
<p>Akka也支持远程的并发的模型，在Akka中通过<code>akka:&lt;//RemoteSystem@127.0.0.1&gt;:2552/user/echoServer</code>这样的地址就可以做到分布式的消息通信与并发。</p>
<p>自己可能在C42的第一阶段中了解编译的概念与并发的概念，并将它们与操作系统相结合起来了。这样好像是一切的基础。而且自己觉得，只有软件工程与安全工程、系统工程学习得多了，才知道编译器为什么这样设计、并行系统为什么那样处理。</p>
<p>个人始终认为，学习计算机和学习数学是一样的道理，自己学习过很多的基础的知识，未必就理解它的意义和用途了。反而是自己把更高级的东西学会之后，有了新的视角的时候，对于有些东西才能看得非常透。比如，编译原理与操作系统和网络显然是非常深的知识，但是我们肯定不知道为什么这样。</p>
<h2 id="实战中的scala与java的互操作">实战中的Scala（与Java的互操作）</h2>
<p>首先是Java与Scala的互操作。在scala中有beans这样的库，以至于可以允许Scala中也使用beans的对象，Scala也支持beans中的<code>@BeanProperty</code>注解。</p>
<p>在Java中判断类是否相等是一件不容易的事，因为它的equals方法与 <code>==</code> 方法的含义是不一样的。而且有时候这样的判断非常难写正确。在Scala中 <code>==</code> 与equals的含义完全相同。另外，在Scala中，建议在需要判断类的相等的时候使用实例类case class，而不用对通常的类判断相等。</p>
<p>抽取器也是Scala的一大特色。具体来说，抽取器允许直接变量的匹配。注意到Scala的case可以匹配一个带有形参的函数，那么，从Email中抽取用户可以这样做：</p>
<figure class="highlight plain"><figcaption><span>.scala&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">import scala.util.matchingRegex</div><div class="line">object Email &#123;</div><div class="line">    def unapply(str: String) = new Regex(&quot;&quot;&quot;(.*)@(.*)&quot;&quot;&quot;)</div><div class="line">    .unapplySeq(str).get match &#123;</div><div class="line">        case user :: domain :: Nil =&gt; Some(user, domain)</div><div class="line">        case _ =&gt; None</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">&quot;user@domain.com&quot; match &#123;</div><div class="line">    case Email(user, domain) =&gt; println(user + &apos;@&apos;+ domain)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这种方法，依赖于对象有unapply方法，以及正则表达式的match功能。</p>
<p>另外，Scala执行中可以启用Cache的功能。具体来说，就是对于函数的指定调用启用Cache。因为每次结果相同，下一次的时候就不再调用了。这种方法需要显式使用。尤其是自己建立一个维护cache的字典。不过，使用的方法也是相当简单的。使用cache的最大的优势可能在于非尾递归的情形下，也不用我们手工改成迭代的方法。在scala中，是通过memo函数（scala.collection.mutable.WeakHashMap）实现的。中文译为“记忆模式”。</p>
<p>记忆模式在计算Fibnacci数之类的问题上是非常显著的。这使得Scala在科学计算中具有表达十分简洁、效率又十分高的特点。</p>
<p>定义了implicit的函数可以成为一个隐式类型转换函数。比如</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">strToData</span></span>(str: <span class="type">String</span>) = ...&#125;</div></pre></td></tr></table></figure>
<p>这样就可以实现隐式类型转换了。关键还是在于implicit关键字。</p>
<p>另外，Scala的强大的地方就在于DSL。Scala有许多特性看起来是语言级的，但是其实是DSL的结果。比如Scala操作JSON的方法。</p>
<p>此外，Scala还有一些测试的套件。可以使用Spec2、ScalaTest等测试。通过使用shound, mustEqual等语句，就好像是在写自然语言一样(好像是声明式的效果）。</p>
<p>另外，Scala还有自己的sbt工具。构建的时候会方便很多。使用sbt，甚至只需要安装JRE，scala就能够把东西构造出来。</p>
<h2 id="sbt教程">SBT教程</h2>
<p>sbt的入门是非常简单的。创建一个新目录，新目录下有一个scala文件，直接运行sbt run，或者先输入sbt，在交互式窗口中输入run，就可以编译并运行结果了。</p>
<p>但是通常情况下，sbt会像java那样工作。也就是，先查找当前目录下的文件，然后查找src/main/scala或者src/main/java目录下的文件，再找src/test/scala与src/test/java目录下面的文件，再找src/main/resources或者src/test/resources目录下的文件。最后找在lib目录下的jar文件。其实是继承了java的优点。因为java就是让哪些不懂软件工程的人也能够按照软件工程的实践来配置，从而避免了随意性。</p>
<p>sbt是和scala同时发布的。默认的情况下，sbt编译的时候也会使用和scala相同的版本的编译器。其实，scala本身就是用java写的编译器。</p>
<p>sbt的配置文件是当前目录中的build.sbt文件。配置根元素的方法是：</p>
<figure class="highlight plain"><figcaption><span>.scala&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">lazy val root = (project in file(&quot;.&quot;)).</div><div class="line">  settings(</div><div class="line">    name := &quot;hello&quot;,</div><div class="line">    version := &quot;1.0&quot;,</div><div class="line">    scalaVersion := &quot;2.11.4&quot;</div><div class="line">  )</div></pre></td></tr></table></figure>
<p>sbt文件的书写规范可以参考<a href="http://www.scala-sbt.org/0.13/tutorial/Basic-Def.html" class="uri" target="_blank" rel="external">http://www.scala-sbt.org/0.13/tutorial/Basic-Def.html</a>。在project/build.properties文件里面可以加上<code>sbt.version=0.13.8</code>来配置所使用的编译器。scala的工程的目录结构，一般和maven保持相同。但是java目录的优先级要低于scala目录。以点号开头的所有的文件都会被忽略。</p>
<p>在sbt中，主要的配置文件放在build.sbt文件中，而其余的配置文件放在project/目录的下面。它们各自有自己的作用。在project/目录下还可以有.scala文件。它们也用于指导构建的过程。</p>
<p>在目录下完全可以使用.gitigonre文件。尤其是，在根目录下应当有.gitignore文件，把target/目录给忽略掉。</p>
<p>在所有的配置中，添加依赖可以说是最基本的了。一般而言，采取这样的风格：</p>
<figure class="highlight plain"><figcaption><span>.scala&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">val derby = &quot;org.apache.derby&quot; % &quot;derby&quot; % &quot;10.4.1.3&quot;</div><div class="line"></div><div class="line">lazy val commonSettings = Seq(</div><div class="line">  organization := &quot;com.example&quot;,</div><div class="line">  version := &quot;0.1.0&quot;,</div><div class="line">  scalaVersion := &quot;2.11.4&quot;</div><div class="line">  )</div><div class="line"></div><div class="line">lazy val root = (project in file(&quot;.&quot;)).</div><div class="line">  settings(commonSettings: _*).</div><div class="line">  settings(</div><div class="line">    name := &quot;hello&quot;,</div><div class="line">      libraryDependencies += derby</div><div class="line">  )</div></pre></td></tr></table></figure>
<p>特别是，使用derby常量定义一个串，然后在settings的libraryDependencies中添加这个库。</p>
<h2 id="play等网页框架">Play等网页框架</h2>
<p>这里介绍了Play框架用来开发Scala网页应用的技术<a href="https://playframework.com/" class="uri" target="_blank" rel="external">https://playframework.com/</a> 。这里是中文的一个介绍play框架的博客<a href="http://www.cnblogs.com/nixil/articles/play_with_scala.html" class="uri" target="_blank" rel="external">http://www.cnblogs.com/nixil/articles/play_with_scala.html</a> 。</p>
<p><a href="http://stevenshe.ca/" class="uri" target="_blank" rel="external">http://stevenshe.ca/</a> 是一个博士生的主页。做的也是SPLC与feature model方向。而且使用的编程语言是scala。</p>
<p>Scala的语言的完整的规范，包括语法解析规则可以参考<a href="http://www.scala-lang.org/files/archive/spec/2.11/" class="uri" target="_blank" rel="external">http://www.scala-lang.org/files/archive/spec/2.11/</a> 。</p>
<h2 id="scala对于xml的支持">Scala对于XML的支持</h2>
<p>Scala的语言的完整的规范，包括语法解析规则可以参考<a href="http://www.scala-lang.org/files/archive/spec/2.11/" class="uri" target="_blank" rel="external">http://www.scala-lang.org/files/archive/spec/2.11/</a>。以下就是从这本书里面提取出的Scala的语言级别的特性。</p>
<p>XML可以直接作为一种数据类型而出现，而不必添加其它的标注。比如:</p>
<figure class="highlight plain"><figcaption><span>.scala&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">val b = &lt;book&gt;</div><div class="line">&lt;title&gt;The Scala Language Specification&lt;/title&gt;</div><div class="line">&lt;version&gt;&#123;scalaBook.version&#125;&lt;/version&gt;</div><div class="line">&lt;authors&gt;&#123;scalaBook.authors.mkList(&quot;&quot;, &quot;, &quot;, &quot;&quot;)&#125;&lt;/authors&gt;</div><div class="line">&lt;/book&gt;</div></pre></td></tr></table></figure>
<p>其中的scalaBook.version可以用于对于scala变量的求值。这样一来，XML完全可以作为一种原生的数据类型出现。至少表现得与原生数据类型是一样的。在词法的级别，Scala也引入了其它的一些特性，比如支持unicode作为变量名。这是Scala的词法文法的介绍<a href="http://www.scala-lang.org/files/archive/spec/2.11/01-lexical-syntax.html" class="uri" target="_blank" rel="external">http://www.scala-lang.org/files/archive/spec/2.11/01-lexical-syntax.html</a>。</p>
<p>在Scala当中，类型、值、方法、类都统称为一个实体(Names in Scala identify types, values, methods and classes which are collectively called entities)。引入一个名称称为绑定（bind）这个名称。在scala当中，引入一个名称的方式有局部声明与定义、继承、import子句、package子句。将一个名称引入之后，scala就知道这个东西该怎样被解析了。</p>
<p>如果不同的绑定定义了同样一个方法，那么它们会有不同的优先级。在编译的时候，编译器会按照优先级来查找这些名称的含义。</p>
<p>在scala中，有两种name spaces。也就是有两个命名的空间。第一个空间是为类型准备的，第二个是为项准备的。因此即使name相同，如果它们属于不同的语法单元，scala也不会把它们弄混了。根据上下文，一个名称，可以被指派给一个类型或者一个项。</p>
<p>每一个绑定都有一个作用域。(A binding has a scope)。在scala中，作用域是可以嵌套的。如果在上下文菜单中出现了一个普通的标识符，scala会尝试从当前生效的作用域中找出这个绑定对应的名子。如果没有这个名子，将会出错。标识符有定域和非定域之分（identifier: unqualified identifier and qualified identifier）。定域的标识符，指的是使用a.x这样中间有点号限定的标识符。</p>
<p>如果是定域标识符，也就是 <span class="math inline">\(e.x\)</span> 的形式，那么scala会把x绑定到具有成员 <span class="math inline">\(x\)</span> 的一个对象 <span class="math inline">\(e\)</span> 当中，但是这个时候， <span class="math inline">\(e\)</span> 的类型 <span class="math inline">\(T\)</span> 不是任意选择的。如果 <span class="math inline">\(T\)</span> 不是value type，那么就会出错。</p>
<h2 id="scala的类型系统">Scala的类型系统</h2>
<p>Scala的类型有value type, non-value type之分。因为对于高阶的支持，所以在scala中有first-order types与type constructors之分。顾名思义，两种类型中，一种是语言内置的，另外一种是接受类型参数以生成另外一种类型。其实可以算是元类型，因为它接受类型参数之后才变成一个具体的类型。</p>
<p>value types is a subset of first-order types. value types又有具体类型concerte与抽象类型abstract之分。它是一个具体的value types的属性。一个具体的value type，要么是具体的，要么是抽象的。value types在scala中又称为first-class values。译为一等值？</p>
<p>Every concrete value type can be represented as a class type, i.e. a type designator that refers to a class or a trait 1, or as a compound type representing an intersection of types, possibly with a refinement that further constrains the types of its members.</p>
<p>Abstract value types are introduced by type parameters and abstract type bindings. Parentheses in types can be used for grouping.</p>
<p>Non-value types capture properties of identifiers that are not values. For example, a type constructor does not directly specify a type of values. However, when a type constructor is applied to the correct type arguments, it yields a first-order type, which may be a value type.</p>
<p>Non-value types are expressed indirectly in Scala. E.g., a method type is described by writing down a method signature, which in itself is not a real type, although it gives rise to a corresponding method type. Type constructors are another example, as one can write type <code>Swap[m[_, _], a,b] = m[b, a]</code> , but there is no syntax to write the corresponding anonymous type function directly.</p>
<p>在scala中，non-value types包含了其它的一些东西。特别是，在scala中，一个方法的类型与它的字面意思并不相同。方法的签名自然是与它的类型有关，但是方法的名称却不能唯一决定它的类型。也就是说，non-value types的含义实际上就是和编程的时候出现在代码中的名称不一样的类型。它的类型是由编译器推导出来的，有一个内部的，隐式的表达。另外，一个类型构造子也不算一个具体的类型，是因为，一个类型构造子的名称还不足以成为一个类型。只有它接受了特定的参数之后，才成为一个类型。</p>
<p>Scala的名称还可能有点号作为限定符。这个时候，完整的路径并不是类型的一部分。但是它们对于确定出现的一个名称是什么类型非常重要。Paths are not types themselves, but they can be a part of named types and in that function form a central role in Scala’s type system.</p>
<p>在scala中的c.x中，x必须是p的一个稳定的成员： <span class="math inline">\(p.x\)</span> where <span class="math inline">\(p\)</span> is a path and <span class="math inline">\(x\)</span> is a stable member of p. Stable members are packages or members introduced by object definitions or by value definitions of non-volatile types.其中，稳定成员就是在路径中，它是一个叶结点: A stable identifier is a path which ends in an identifier.也就是出现c.x之后，x不能再有子成员？</p>
<p>注意，引用一个类的超类中的成员也是可能的。比如C.super.x或者super[M].x。</p>
<p>A stable type is either a singleton type or a type which is declared to be a subtype of trait scala.Singleton.</p>
<h3 id="编程语言的类型问题">编程语言的类型问题</h3>
<p>在这一领域有许多正式的名称。它们甚至是可以形式地定义出来的。比如<span class="math inline">\(T[T_1,\cdots]\)</span> 。这个完整的整体叫做一个含参类型，称为parameterized types，而 <span class="math inline">\(T\)</span> 本身则称为一个类型构造子。也就是说， <span class="math inline">\(T[T_1]\)</span> 是对类型构造子已经使用了 <span class="math inline">\(T_1\)</span> 构造之后的结果。类型参数是可以定义上界与下界的。尤其是在声明一个类型构造子的时候。</p>
<p>比如声明 <code>class S[K&lt;: String] {...}; class G[M[Z&lt;:I],I]{...}</code> 的话，可以使用 <span class="math inline">\(G[S,String]\)</span> 来构造一个带参类。</p>
<p>Scala还允许元组类型。这种类型是由 <span class="math inline">\((T_1,\cdots,T_n)\)</span> 构成的。在使用的时候，相应的数据的各个维数属于不同的类型，类似于结构体。</p>
<p>另外一种是所谓的注解类(Annotated types)，用法如<code>String @suspendable</code>。其它的，还有合成类型（compound types）、中缀类型（Infix Types）、函数类型(function types)等。</p>
<p>函数的类型是由 <span class="math inline">\(T_1,\cdots, T_n \Rightarrow U\)</span> 来决定的。也可以使用复合的类型，如 <span class="math inline">\(S\Rightarrow T \Rightarrow U\)</span>，但是这个类型是右结合的，表示的是等价于 <span class="math inline">\(S\Rightarrow (T\Rightarrow U)\)</span>的元素。</p>
<p>中缀类型具有 <span class="math inline">\(T_1 op T_2\)</span> 的类型。从实现上看，中缀类型是对于<span class="math inline">\(op[T_1, T_2]\)</span> 的一个语法糖。</p>
<p>在Scala当中，函数是具有apply方法的类，因此函数类型实际上是一种类类型（class types)。函数类型的结果是共变的，但是参数是反变的。</p>
<p>在编程语言中，把一个名子与一个类型关联起来的过程称为绑定。然而，具体实现绑定的方法就是通过声明或者定义。</p>
<p>Scala的Object实际上是由设计模式中的“单件”改变而来。参考 <a href="http://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F</a> 。</p>
<p>模式匹配的技术与模式识别正好相反。在模式匹配中，模型是精确指定的。但是在模式识别中，模式却南大要挖掘。Tree patterns are used in some programming languages as a general tool to process data based on its structure, e.g., Haskell, ML, Scala and the symbolic mathematics language Mathematica have special syntax for expressing tree patterns and a language construct for conditional execution and value retrieval based on it. For simplicity and efficiency reasons, these tree patterns lack some features that are available in regular expressions.</p>
<h2 id="使用scala实现一个符号微分的程序">使用Scala实现一个符号微分的程序</h2>
<p>类型的匹配其实就是使用带参类与泛型的结果。尤其是对于一个表达式，通常的情况下，都是设置优先级来匹配一个类。比如</p>
<figure class="highlight plain"><figcaption><span>.scala&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def Diff(Expr, Var) = Expr match &#123;</div><div class="line">    case Sum (l, r) =&gt; Diff (l, Var) + Diff (r, Var)</div><div class="line">    case Prod (l, r) =&gt; Diff (l, Var) * r + l * Diff(r, Var)</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>实现中缀形式的匹配也是有可能的，特别是在scala中中缀也可以惰性匹配的情况下。个人认为，大学的时候学习编程语言不能非常方便地写出一个符号微分的程序就是一个失败。</p>
<p>写符号微分的另外一种方式是使用语法解析器。如果能把语法解析器自动嵌入到一个语言中，会是很有趣的一件事情。特别是如果一个语言的子解析模式是可以由用户方便地定制的话。</p>
<h2 id="scala下的actor06-09-2015-222156">Scala下的Actor[06-09-2015 22:21:56]</h2>
<p>使用AKKA并发库来解决问题。Actor系统的原理我们已经知道了。对于Erlang而言，程序本身就是一个Actor（进程）。而在scala当中，进程通过创建actor中的一个对象实现与actor通信系统的关联。示例的代码如下：</p>
<figure class="highlight plain"><figcaption><span>.scala&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">case class Greet(name: String)</div><div class="line">case class Praise(name: String)</div><div class="line">case class Celebrate(name: String, age: Int)</div><div class="line"></div><div class="line">class Talker extends Actor &#123;</div><div class="line">    def receive = &#123;</div><div class="line">        case Greet(name) =&gt; println(s&quot;Hello $name&quot;)</div><div class="line">        case Praise(name)=&gt; println(s&quot;$name, you&apos;re amazing&quot;)</div><div class="line">        case Celebrate(name, age) =&gt; println(s&quot;Here&apos;s to another $age years, $name&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">object HeloActors extneds App &#123;</div><div class="line">    val system = ActorSystem(&quot;HelloActors&quot;)</div><div class="line">    val talker = system.actorOf(Props[Talker], &quot;talker&quot;)</div><div class="line"></div><div class="line">    talker ! Greet(&quot;Huey&quot;)</div><div class="line">    talker ! Praise(&quot;Dewey&quot;)</div><div class="line">    talker ! Celebrate(&quot;Louie&quot;, 16)</div><div class="line"></div><div class="line">    Thread.sleep(1000)</div><div class="line"></div><div class="line">    system.shutdown</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面的代码中，使用ActorSystem进入Actor系统当中（可能需要一些认证），而使用actorOf来创建一个actor。发送消息使用叹号，而使用shutdown来实现断开actor.基本原理就是这样。如果需要多个消费者协调，或者错误处理功能，就需要再参考相关的书籍了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/12/06/141206-Ecipse体系架构与EMF/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/12/06/141206-Ecipse体系架构与EMF/" itemprop="url">
                  Eclipse体系结构与Ecore技术
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-12-06T00:00:00+08:00">
                2014-12-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:14+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014/12/06/141206-Ecipse体系架构与EMF/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/12/06/141206-Ecipse体系架构与EMF/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>这对于理解Eclipse的建模的技术至关重要。Eclipse Modeling Framework(EMF)是Eclipse提供的一套建模的框架，可以使用EMF建立自己的UML模型，设计模型的XML格式或编写模型的Java代码。EMF提供了一套机制实现功能的相互转换，大大提高了效率。</p>
<h2 id="统一javauml与xml的ecore文件">统一Java、UML与XML的Ecore文件</h2>
<p>故事不妨从程序员开始。一般的程序员都是上来写Java代码，但是按照软件工程的要求，往往要先开始建模。两种思路各有千秋吧。但是如果我们能写一份代码，然后自动转成另一种格式，明显会使程序员舒服许多，同时又减少了程序员对软件工程的抵触情绪。这种思路能够转变成为现实，这是因为，Java代码描述，UML描述是等价的，理论上也就存在一种转换的可能。（特别是类图的转换）。</p>
<p>Java的接口是统一UML类图与代码的关键。因为Java的接口只有声明而不需要实现，与UML的类图的描述正好相同。如果Java类中包含了代码实现，反而比UML描述的东西更多了。（也许UML不适合在算法的级别上描述软件）。UML图形的保存的格式是XML的，准确地说，是基于XML Schema。</p>
<p>如果我们想设计一种模型，然后在三种模型之间转换，那么就要借助于EMF Model了.EMF给我们的回答是，在软件开发中，设计既可以从UML图形开始，也可以从Java代码开始，也可以从XML Schema开始。这样，大概结束了设计与编程的地位的高低的问题。解决了这个“To model or to program, that is not the question”。(这个思想大概同Knuth的观点相同，关键是EMF似乎也允许了既不是自顶自下也不是自低向下的设计。）</p>
<p>但是我们先看为了统一三种模型，我们应该考虑哪些现实的问题：</p>
<ul>
<li>在UML与Java中是类的东西，在XML Schema中被定义成复杂类型</li>
<li>在UML中使用属性，在Java中使用get/set方法，而在XML Schema中是内嵌元素类型</li>
<li>在UML中是类的关联或者引用，在Java中可能是方法，在XML Schema中是另一种复杂类型的内嵌元素类型</li>
</ul>
<p>于是要实现EMF和三种模型的转换，需要一种能够描述EMF模型的模型，这个模型我们称为元模型，也就是Ecore(Meta)模型。</p>
<p>Ecore模型位于MOF的M2层，它本身也是EMF模型。Ecore模型本身是可以用于描述自身的模型。Ecore是OMG的MOF建议在Eclipse下的一种实现，同时MOF的M2模型还有其它的实现形式。Ecore模型的实例，使用XMI序列来表示。在Eclipse中，导出EMF模型，实际上是导出一个EMF模型，也就是导出EMF模型的XMI格式。</p>
<p>EMF能够将Java接口自动生成UML的属性和方法，但是并非所有的Java接口都自动会生成UML的属性和方法。其实要生成相应接口与方法，编写Java代码的时候必须符合一定的规范。</p>
<p>EMF的核心就是Ecore和它的XMI序列化格式。通过UML、XML Schema与Java接口，Eclipse提供了一种转换成Ecore模型的方法。而且转换Ecore之后，可以生成这三种模式以及其它形式的模型。</p>
<p>使用XML Schema不仅定义了模型，而且还指定了模型实例的持久格式（？）。还有其它的持久模型格式，如Relational Database Schema (RDB)。</p>
<p>注：持久模型好像指的是，Java代码中也有不是自动生成的部分，这部分需要我们手动编写。如果自动工具能够识别哪些是手写的，哪些是自动生成的，然后在更新模型的时候保留我们手写的那部分，则就称为是一个持久化的模型。</p>
<p>EMF是一个强类型的语言。我们也许可以从形式语言的一般理论中理解它。</p>
<p>Ecore模型可以使用GMF可视化工具编辑(就是那个树形的编辑框)。注意，使用Eclipse新建Ecore文件的时候，最好还是不要使用纯文件建立一个空白文件类型，那样要做很多多余的工作，直接新建Ecore Diagram即可，因为它生成的是Ecore文件。</p>
<p>Papyrus插件中再安装上Extras软件包之后就可以有生成Java或者C++的代码的功能了。 Papyrus<a href="http://download.eclipse.org/modeling/mdt/papyrus/updates/releases/luna/extra" class="uri" target="_blank" rel="external">http://download.eclipse.org/modeling/mdt/papyrus/updates/releases/luna/extra</a>。</p>
<h2 id="eclipse的体系结构">Eclipse的体系结构</h2>
<p>了解Eclipse的体系结构对于后面要进行的开发会有一些好处吧。Eclipse的骨架是OSGi体系结构，它是Open Services Gateway Initiative的简称。OSGi技术原是为嵌入式硬件而开发的，使网络上的服务提供者和使用者互相交互。</p>
<p>在OSGi中，所有被配置的组件都是以插件的方式提供的。SWT和JFace是Eclipse的最基本的用户接口API。在其上提供了基本的UI Workbench。在然后上面就有了更新管理器与帮助系统，它们构成了Eclipse的框架。</p>
<p>插件为了自身能够对其它插件进行扩展而提供“扩展点”。当要为插件提供增加功能的时候就可以利用这个扩展点。在扩展点的基础上，插件之间可以互相连接。扩展和扩展点之间的连接是在程序执行的时候被建立的，提供扩展点的插件事先并不知道该扩展点在实际运行的时候被展了什么样的行为。使用扩展点的插件需要在其源代码的plugin.xml配置中使用<code>&lt;extension&gt;</code>元素声明该扩展点。基本格式为:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">extension</span> <span class="attr">point</span>=<span class="string">"被使用扩展点的ID"</span>&gt;</span></div><div class="line">    ......</div><div class="line"><span class="tag">&lt;/<span class="name">extension</span>&gt;</span></div></pre></td></tr></table></figure>
<p>像这样的扩展点和扩展不断地积累，使得Eclipse平台能够实现各种各样的功能。Eclipse平台提供的扩展点许多类，其中有三类比较基础：</p>
<ul>
<li>增加菜单项</li>
<li>增加视图</li>
<li>增加编辑器</li>
</ul>
<p>在Eclipse的帮助中有Eclipse提供的所有扩展点的说明，可供编写扩展时参考。我们也可以为自己的插件定义一个扩展点。</p>
<p>在开发Java的时候，我们已经熟悉了Eclipse窗口由工作台、菜单栏、工具栏、工作台页（也就是包含一个个子窗口的容器）、状态栏构成。其中工作台页又有视图、编辑器等类型的子窗口，通称为透视图(Perspective)。Eclipse工作台即Workbench，它是整个用户接口的总称。</p>
<p>我们的插件使用org.eclipse.ui.PlatformUI类访问工作台，示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取得工作台</span></div><div class="line">IWorkbench workbench = PlatformUI.getWorkbench();</div><div class="line"><span class="comment">//取得工作台窗口</span></div><div class="line">IWorkbenchWindow window = workbench.getActiveWorkbenchWindow();</div><div class="line"><span class="comment">//取得工作台页面</span></div><div class="line">IWorkbenchPage page = window.getActivePage();</div><div class="line"><span class="comment">//取得当前处于活动状态的编辑器窗口</span></div><div class="line">IEditorPart part = page.getActiveEditor();</div></pre></td></tr></table></figure>
<p>在Eclipse启动时，会要求用户配置一个工作空间(workspace)作为开发人员作业的一个区域。它在物理上是一个文件夹。在逻辑上，生成工程、创建文件等操作，一般都会在工作空间中的指定文件夹里面生成实际的文件。Eclipse使用org.eclipse.core.resource在Eclipse启动时，会要求用户配置一个工作空间(workspace)作为开发人员作业的一个区域。它在物理上是一个文件夹。在逻辑上，生成工程、创建文件等操作，一般都会在工作空间中的指定文件夹里面生成实际的文件。Eclipse使用org.eclipse.core.resources包定义的虚拟对象操作工作空间里的资源。如工程是IProject、文件夹是IFolder、文件是IFile。对工作空间的访问就使用org.eclipse.core.resources.ResourcesPlugin。下面的代码给出了访问工作空间的代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取得工作区的root</span></div><div class="line">IWorkspaceRoot wsroot = ResourcesPlugin.getWorkspace().getRoot();</div><div class="line"><span class="comment">//取得项目</span></div><div class="line">IProject[] projects = wsroot.getProjects();</div></pre></td></tr></table></figure>
<p>工作台和资源访问的API是Eclipse提供的API中最基本的，在插件开发时使用频率较高的API。使用PlatformUI作为工作台访问的入口点和使用ResourcesPlugin作为工作区访问的入口点，是无论如何也要记住的。</p>
<p>插件如何与Eclipse交互全在plugin.xml配置文件当中。<code>&lt;extension&gt;</code>元素有point属性以指定扩展点的位置，里面通常包括将插件的图标放在哪里，以及点击插件的时候要调用的动作。另外，注意Activator类，该类为插件提供了生命周期管理。</p>
<p>Eclipse中的Compare功能已经可以在Ecore与UML模型之间相互比较了，在Package Explorer中选择多个文件，然后右键找Compare中的Compare as Model，即可以在语法的级别上进行模型的不同的检查。</p>
<p>Papyrus中包含一些Components，比如Diagram generation, 用于从一个语义UML模型中生成Papyrus图表。Papyrus Compare则用于以语义的形式或图表的形式比较Papyrus模型。C++ Code Generation用于生成C++的Profile与代码。</p>
<h2 id="模型驱动开发">模型驱动开发</h2>
<p>为了支持软件工程以建立大规模的软件系统，传统的编程思想必须发生改变。比如，如果直接访问数据，那么数据读写之后就只是数据的读写，而不会对其它的类产生影响，也不会向软件系统中的其它部分发出通知。这表明，编程方法的好坏是有条件的。在小程序上工作很好的方法，在处理软件系统的问题的时候，就变成非常差的方法了。如果我们坚持不用get/set方法，那么读写数据之后触发其它的动作简直就是不能想象的。</p>
<h3 id="工厂方法">工厂方法</h3>
<p>Eclipse中为我们展示了一个基本的例子。一般创建对象的时候，我们总是使用new的方法。但是这种方法，并没有形成创建对象的统一的模式。于是就了有工厂类。该类的功能就是提供创建各种对象的接口，把它们封装起来。比如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">PurchaseOrder aPurchaseOrder = </div><div class="line">	POFactory.eINSTANCE.createPurchaseOrder();</div></pre></td></tr></table></figure>
<p>用于创建一个购物单。调用该类的其它方法，可以创建其它的对象。使用这种模式，使得创建一个对象，看起来就像是访问不同的数据库一样。像是所有的数据访问的操作都被这一个对象代理了，于是就实现了所谓的“数据抽象”。相当于在人类社会中，有专门的仓库保管员来给我们做这样的事情，我们只需要发号施令即可（看起来人类总是希望指挥别人）。</p>
<p>我想EMF框架的最吸引人的地方不是自动地创建代码中的接口和类，而是配置生成器使得可以根据需要生成Factory类、Package类、Adapter类、Switch类等。EMF框架对面向对象的支持程度还有一些局限。比如动态绑定技术，在EMF中好像就没有得到充分的利用。但是我们知道UML是充分利用了这些技术的。</p>
<p>注：写到这里，我想到了Scala提供强大的面向对象的机制，使编程语言本身再结合面向对象的编程方法，可以写出非常漂亮、功能非常完善的程序的。</p>
<p>官方的软件提供了一些源，但是我们最好能够使用Eclipse Marketplace。该插件可以从Ecipse官方软件源中的General Purpose Tool中选择Marketplace Client选项。</p>
<h2 id="eclipse下feature-model插件">Eclipse下Feature Model插件</h2>
<p>Eclipse下Feature Model是这样做的，首先在EMFT下面有Feature Model的Project，我们可以下载这个Project.然后我们要添加pure_systems提供的更强大的Feature Model与UML相结合的工具，因为Feature Model是变化性建模的标准工具。为此，先从<a href="http://www.emftext.org/index.php/EMFText_Download" class="uri" target="_blank" rel="external">http://www.emftext.org/index.php/EMFText_Download</a>找到EMFtext的下载地址<a href="http://emftext.org/update_trunk" class="uri" target="_blank" rel="external">http://emftext.org/update_trunk</a>下载EMFtext。</p>
<p>EMFText is an Eclipse plug-in that allows you to define text syntax for languages described by an Ecore metamodel. EMFText enables developers to define textual Domain Specific Languages quickly and without the need to learn new technologies and concepts.</p>
<p>下载后的EMFtext要被FeatureMapper工具使用。该工具可以从<a href="http://featuremapper.org" class="uri" target="_blank" rel="external">http://featuremapper.org</a>找到，Eclipse源地址是<a href="http://featuremapper.org/update" class="uri" target="_blank" rel="external">http://featuremapper.org/update</a>下载之后安装，然后可以使用这样的工具了。还有几篇论文可以使用。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/11/22/141022-Scala历史背景介绍/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/11/22/141022-Scala历史背景介绍/" itemprop="url">
                  Scala介绍（第二版资料）
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-11-22T00:00:00+08:00">
                2014-11-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:14+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014/11/22/141022-Scala历史背景介绍/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/11/22/141022-Scala历史背景介绍/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用了这么久的Scala，对于Scala就又有了新的认识。觉得Scala还是一种普通的语言。它有它支持的编程范式。其实编程范式是属于思维方式问题，可以跟编程语言亳无关系。面对对象的程序设计，其实与面向对象的软件工程没有什么关系。因为软件工程的重点在软件系统上。</p>
<p>Scala的IDE需要在Eclipse中实现，这让人实在很头疼。一方面计算机没有足够的性能运行大型的程序，另一方面，自己也不想使用大型的软件了。很多大型软件的设计，其实根本就没有必要。软件设计的最高境界，就是软件本身作为一种语言被人使用着。</p>
<p>Simula 67是第一种面向对象的语言应该是可以接受的（而非Smalltalk），现在回过头来发现，其实面向对象的设计其实就是模拟现实世界，不然，也不会在与软件工程结合得那么紧密。很多软件是我们不曾接触到的。像军工等东西，应用的技术我们听都没听过，更不用说研究了。但是它们确确实实存在着，我们也得正视其存在。虽然我们现在没有那样的实验条件，但是我们也得认可Simula 67与Ada等是一种实际存在的语言。</p>
<h2 id="scala编程语言">Scala编程语言</h2>
<p>Scala是一门多范式（函数式，面向对象）的编程语言，设计初衷是要集成面向对象编程与函数式编程的各种特性。</p>
<h3 id="平台和许可证">平台和许可证</h3>
<p>Scala运行于Java平台（Java虚拟机），并兼容现有的Java程序。它也能运行于CLDC配置的Java ME中。目前还有另一.NET平台的实现，不过该版本更新有些滞后。</p>
<p>Scala的编译模型（独立编译，动态类加载）与Java和C#一样，所以Scala代码可以调用Java类库（对于.NET实现则可调用.NET类库）。</p>
<p>Scala包包括编译器和类库，以BSD许可证发布。</p>
<h3 id="scala的历史">Scala的历史</h3>
<p>洛桑联邦理工学院的Martin Odersky于2001年基于Funnel的工作开始设计Scala。Funnel是把函数式编程思想和佩特里网相结合的一种编程语言。Odersky先前的工作是Generic Java和javac。Java平台的Scala于2003年底/2004年初发布。.NET平台的Scala发布于2004年6月。该语言第二个版本，v2.0，发布于2006年3月。</p>
<p>Scala 2.8的特性包括重写的Scala容器库、命名参数和默认参数、包对象，以及Continuation。</p>
<p>2012年1月，发布版本2.9.1。</p>
<p>2012年4月，发布版本2.9.2。</p>
<h3 id="特性">特性</h3>
<p>面向对象特性</p>
<p>Scala是一种纯面向对象的语言，每个值都是对象。对象的数据类型以及行为由类和特质描述。类抽象机制的扩展有两种途径。一种途径是子类继承，另一种途径是灵活的混入机制。这两种途径能避免多重继承的种种问题。 函数式编程</p>
<p>Scala也是一种函数式语言，其函数也能当成值来使用。Scala提供了轻量级的语法用以定义匿名函数，支持高阶函数，允许嵌套多层函数，并支持柯里化。Scala的case class及其内置的模式匹配相当于函数式编程语言中常用的代数类型。</p>
<p>更进一步，程序员可以利用Scala的模式匹配，编写类似正则表达式的代码处理XML数据。在这些情形中，列表推导式功能对编写公式化查询非常有用。</p>
<p>由于JVM不支持尾调用，Scala也不能完全支持尾调用优化。不过，Scala编译器可以把某些简单的尾递归优化成循环。</p>
<p>以下代码以函数式风格实现了快速排序算法，可以与Erlang快速排序的例子做个比较：</p>
<figure class="highlight plain"><figcaption><span>.scala&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">def qsort(list: List[Int]): List[Int] = &#123;</div><div class="line">    case Nil =&gt; Nil</div><div class="line">    case pivot :: tail =&gt;</div><div class="line">    val(smaller, rest) = tail.partition(_ &lt; pivot)</div><div class="line">    qsort(smaller) ::: pivot :: qsort(rest)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>静态类型</p>
<p>Scala具备类型系统，通过编译时检查，保证代码的安全性和一致性。类型系统具体支持以下特性：</p>
<ol style="list-style-type: decimal">
<li>泛型类，</li>
<li>协变和逆变，</li>
<li>标注，</li>
<li>类型参数的上下限约束，</li>
<li>把类别和抽象类型作为对象成员，</li>
<li>复合类型，</li>
<li>引用自己时显式指定类型，</li>
<li>视图，</li>
<li>多态方法。</li>
</ol>
<p>扩展性</p>
<p>Scala的设计秉承一项事实，即在实践中，某个领域特定的应用程序开发往往需要特定于该领域的语言扩展。Scala提供了许多独特的语言机制，可以以库的形式轻易无缝添加新的语言结构：任何方法可用作前缀或后缀操作符，可以根据预期类型自动构造闭包。</p>
<p>联合使用以上两个特性，使你可以定义新的语句而无须扩展语法也无须使用宏之类的元编程特性。</p>
<p>并发性</p>
<p>Scala使用Actor作为其并发模型，Actor是类似线程的实体，通过邮箱发收消息。Actor可以复用线程，因此可以在程序中可以使用数百万个Actor,而线程只能创建数千个。在2.10之后的版本中，使用Akka作为其默认Actor实现。 以下代码是使用Actor模式的EchoServer实现:</p>
<figure class="highlight plain"><figcaption><span>.scala&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">val echoServer = actor(new Act &#123;</div><div class="line">  become &#123;</div><div class="line">    case msg =&gt; println(&quot;echo &quot; + msg)</div><div class="line">  &#125;</div><div class="line">&#125;)</div><div class="line">echoServer ! &quot;hi&quot;</div></pre></td></tr></table></figure>
<p>Actor模式可以简化并发编程，好利用多核CPU的能力。</p>
<h3 id="程序与编译">程序与编译</h3>
<p>Scala的编译和执行模型与Java是等效的，因而它也兼容于Java的构建工具，比如Ant.</p>
<p>直接使用Scala解释器也可以运行该程序，使用选项-i（从文件加载代码）和选项-e（若要运行额外的代码，就得实际执行HelloWorld对象的方法）即可。</p>
<p>Scala的测试工具有ScalaTest与ScalaCheck，后者类似于Haskell的QuickCheck库。</p>
<p>Scala的标准书籍是Odersky的《Programming in Scala》,见<span class="citation">(Odersky, Spoon, and Venners 2008)</span>。</p>
<div id="refs" class="references">
<div id="ref-odersky2008programming">
<p>Odersky, Martin, Lex Spoon, and Bill Venners. 2008. <em>Programming in Scala</em>. Artima Inc.</p>
</div>
</div>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/09/22/140922-pxeliunux/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/22/140922-pxeliunux/" itemprop="url">
                  PXE方法远程启动Ubuntu 14.04桌面版
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-22T00:00:00+08:00">
                2014-09-22
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:14+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统-pxe-ubuntu/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统, pxe, ubuntu</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014/09/22/140922-pxeliunux/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/22/140922-pxeliunux/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之前使用过各种启动方法。最近要往实验室计算机里装系统，而手头又没有光盘或者优盘，就只能再使用PXELINUX的启动方法了。再想一想，实验室里那么多台计算机，要一个一个地整系统实在太麻烦了，还不如远程启动，让一切自动化。</p>
<h2 id="原理">原理</h2>
<p>许多计算机都有自己的远程启动机制，Intel系列使用的技术叫做PXE(Portable eXcution Enviroment)。</p>
<p>远程启动的过程可以与本地启动相类比。无论SYSLINUX还是Grub，抑或其它的启动模块，都完成的是Bootloader的功能。它们仅限于在开机后，帮助我们找到操作系统内核，向操作系统传递启动参数。完成这些功能后，它们就不再被使用了。引导程序(Bootloader)一般比较轻量，在几兆的数量级。操作系统（的内核）相对较大，在几十兆的数量级。</p>
<p>假设当前系统已经装好了SYSLINUX引导程序，启动的过程大致是：</p>
<ul>
<li><p>机器加电，BIOS开机自检。完成自检后到启动设备（光盘或硬盘）的约定的位置查找引导程序Bootloader，将Bootloader的代码加载到内存指定位置</p></li>
<li><p>BIOS将机器的控制权交给SYSLINUX，原则上SYSLINUX可以做很多的工作。不过，我们现在关心的是，它从指定的位置读取配置文件，找到操作系统，并按设置加载操作系统。</p></li>
<li><p>操作系统启动，设置根文件系统，加载开机自启的程序，等等。</p></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/09/20/140920-PXEboot/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/20/140920-PXEboot/" itemprop="url">
                  命令行下面的关机，PXE远程启动
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-20T00:00:00+08:00">
                2014-09-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:14+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014/09/20/140920-PXEboot/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/20/140920-PXEboot/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>下午针对这个问题google了一下，原因大概就是 halt 是强制关机，而poweroff 会先给 ACPI （Advanced Configuration and Power Management Interface）一个命令，之后再关机（不知道这么理解是不是准确，逃）。感觉是我直接用 halt 才出的问题。继而观察了下这三个命令，</p>
<p>shutdown实际上是调用init 0, init 0会cleanup一些工作然后调用halt或者poweroff。其实主要区别是halt和poweroff，做没有acpi的系统上，halt只是关闭了os，电源还在工作，你得手动取按一下那个按钮，而poweroff会发送一个关闭电源的信号给acpi。但在现在的系统上，他们实际上都一样了</p>
<p>可以参考juju-charm上面的关于maas的区域控制器的介绍。上面用图表的形式列出了区域控制器所依赖的psql、sstream等组件。</p>
<h2 id="远程启动">远程启动</h2>
<p>不同计算机支持的远程启动协议是各种各样的，在Intel的机器上，使用的是所谓的PXE(Preboot Execution Enviroment)技术。PXE协议是根据服务器端收到的工作站的MAC地址，使用DHCP服务给这个MAC地址指定一个IP。在PXE中，待启动的机器常称为工作站。PXE工作的大致过程是，工作站开机后，PXE BootROM(网卡上的自启芯片)获得控制权之前先做自我测试，然后以广播形式发出一个请求FIND帧。服务器若收到工作站的要求，就会发出DHCP回应。内容包括用户端的IP地址、预设通讯通道、开机映象文件等。工作站收到后回应相应的帧请求传送所需文件。之后将会有多次协商过程，以决定启动参数。之后BootROM由TFTP通讯协议从服务器下载开机映象文件。这个映象档就是软盘映象文件（系统映象文件）。工作站使用TFTP接收启动文件后，将控制权转交启动块，引导操作系统映象，完成自启动过程。</p>
<p>配置过程中，针对DHCP、TFTP、NFS进行相应的配置。DHCP用于将引导模块交给工作站，TFTP用于传送操作系统映象，而NFS用于加载开机启动时所需的各个文件。</p>
<p>TFTP的配置可由xinetd决定。而DHCP中的一些选项是与TFTP启动配合的。所以在正常配置好DHCP服务器之后，由next-server选项指定TFTP服务器的地址，由filename选项指定TFTP服务器文件的路径。这是因为，根据DHCP协议的规范，next-server就是TFTP服务器的地址。</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">## 目标机器的DHCP配置项</div><div class="line">host target &#123;</div><div class="line">## 目标机器所匹配的MAC地址</div><div class="line">hardware ethernet 00:13:21:1F:F1:82;</div><div class="line">## 目标机器分配到的IP地址</div><div class="line">fixed-address 192.168.0.10;</div><div class="line">## 目标机器所使用的网关地址</div><div class="line">option routers 192.168.0.254;</div><div class="line">## 目标机器所用的DNS</div><div class="line">option domain-name-servers 208.67.222.222,208.67.220.220;</div><div class="line">## 指定TFTP服务器的地址。如果TFTP与DHCP服务器是一个IP，则可以忽略</div><div class="line">next-server 192.168.0.2;</div><div class="line">## 指定开机文档在TFTP服务器上的路径</div><div class="line">filename &quot;/ubuntu-installer/i386/pxelinux.0&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后可以开启TFTP服务，并且操作系统映象也可以放在TFTP服务器上。对于Ubuntu来说，可以将光盘中的/install/netboot/ubuntu-installer/目录复制到TFTP目录下面。之后，打开客户机的电源，BIOS中选择从网络启动即可。</p>
<p>上面的DHCP配置中仅有被启动的工作站的配置节，而正常的DHCP应当有针对子网的配置。dhcpd.conf文件的其他部分可参考示例文件：</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">ddns-update-style none;</div><div class="line">ignore client-updates;</div><div class="line">allow booting;</div><div class="line">allow bootp;</div><div class="line"></div><div class="line">subnet 192.168.5.0 netmask 255.255.255.0 &#123;</div><div class="line">option routers 192.168.5.1;</div><div class="line">option subnet-mask 255.255.255.0;</div><div class="line">option domain-name-servers 202.112.128.50;</div><div class="line">range dynamic-bootp 192.168.5.33 192.168.5.38;</div><div class="line">default-lease-time 21600;</div><div class="line">max-lease-time 43200;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们知道，本地启动的时候，有GRUB和LINUX系统映象两个文件。前面的pxelinux.0就相当于GRUB、整个光盘就相当于开机系统。linux发行版光盘的<code>install/netboot</code>目录中有pxelinux.0文件及相应的配置选项，使用的时候，该文件夹的内容全部拷贝到TFTP根目录下面。</p>
<p>Ubuntu一系的软件，光盘映象基本上都放在HTTP服务器上。也就是操作系统映象自TFTP传到工作站并运行的时候，Ubuntu自动从本网络的一台HTTP服务器上查找安装所需文档。此时，我们可以选择将整个光盘映象挂载至HTTP服务器的 <code>/ubuntu</code>目录下面。工作站的PXELINUX启动的时候，会向我们询问操作系统映象的地址。</p>
<p>如果合适，我们也可以将安装好的系统分发给其它的工作站，而不用远程安装系统。</p>
<h2 id="实战">实战</h2>
<p>首先安装Ubuntu上所需要的各种软件，然后将Ubuntu14.04的映象下载过来。</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">apt-get install nfs-common nfs-kernel-server</div><div class="line">apt-get install tftpd-hpa tftp-hpa</div><div class="line">apt-get install isc-dhcp-server</div></pre></td></tr></table></figure>
<p>DHCP服务的端口号是TCP67，而TFTP服务的端口号是UDP59，可以通过netstat命令查看相关的设置。</p>
<p>tftp-hpa使用的配置文件是 <code>/etc/default/tftpd-hpa</code> ，可以根据需要，将TFTP的服务器目录改变到其它的位置。不过，配置的时候，注意权限问题。</p>
<p>isc-dhcp-server使用的配置文件是 <code>/etc/dhcp/dhcpd.conf</code> 。配置的时候按照格式。</p>
<p>配置DHCP的时候，应将这里的DHCP与服务器上的DHCP区分开。一般而言，笔记本在连接无线的时候，有线网络并不受到影响。这个时候我们可以指定本机的地址，然后在dhcpd.conf文件中，将网关的位置填写成自己的。其实，如果是局域网里面访问，则根本不需要网关地址。因为局域网中的主机访问，不需要通过网关。</p>
<p>NFS服务是可选的。如果需要使用这个服务的话，使用NFS的时候，别忘了安装nfs-kernel-server。然后编辑 <code>/etc/exports</code> 文件，选择需要导出的数据。</p>
<p>然而在共享的时候，NFS需要用户的密码。这一点需要我们注意。没有<code>/etc/exports</code>里面的文件的时候，导出的目录是空的，NFSD守护进程也不会运行。简单的导出可 以是 <code>/srv/www *(ro)</code> 这样的行。</p>
<h2 id="pxelinux介绍">PXELINUX介绍</h2>
<p>其实使用TFTP服务全部依赖于所谓的PXELINUX启动程序。该程序与SYSLINUX、EXTLINUX同属于一个发行版。PXELINUX的pxelinux.0文件所在的TFTP的根目录，其实就相当于本地启动的时候的boot分区而已。</p>
<p>下载PXELINUX程序之后，将 <code>/usr/lib/syslinux/pxelinux.0</code> 文件复制在TFTP根目录下面。然后在TFTP根目录下建立pxelinux.cfg目录。在目录中建立default文件。其实，PXELINUX的解释是， <code>pxelinux.cfg</code>目录代表了对不同的客户机的启动选项的配置，以便支持不同的系统。而只有一个<code>default</code>文件的时候，相当于局域网中只有一个主机。</p>
<p>下面是PXELINUX的配置文件的一个示例写法：</p>
<figure class="highlight plain"><figcaption><span>.shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">DEFAULT ubuntu</div><div class="line">LABEL ubuntu</div><div class="line">kernel linux</div><div class="line">append initrd=initrd.nfs root=/dev/nfs nfsroot=192.168.1.88:/home/cache/netboot/root ip=dhcp rw</div></pre></td></tr></table></figure>
<p>kernel与append命令所需的linux与initrd文件，都是以TFTP根目录为根所得到的文件路径。因此内核linux与initrd文件要与pxelinux.0一起放在TFTP根目录下。</p>
<p>任何linux内核均支持root=这样的参数，大部分也支持nfsroot选项。如果把nfsroot都指定了，那么工作站将以nfsroot所指的位置作为根系统。然后，找到根系统后，我们就可以从根文件系统的 <code>/etc/fstab</code>中加载其它的NFS挂载选项。通过不同的组合，可以实现无盘工作站或者有盘工作站。</p>
<p>如果理解了内核的root=选项，以及联想到OpenSUSE安装光盘具有指定光盘位置的选项，那么远程安装系统就不是什么困难的事情了。</p>
<p>对于Ubuntu来说，不同之处在于，Ubuntu的安装映象支持ks=选项，而ks=又可以调用http服务，因此Ubuntu具有从HTTP服务器上下载文件的能力。显然，如果工作站能够下载服务器上的安装映象，那么自然就能够完成接下来的安装。</p>
<h2 id="网络唤醒功能">网络唤醒功能</h2>
<p>网络唤醒功能一个是网卡支持，第二个是BIOS启用，另外一个是有应用工具。网卡的支持是生产商的问题。BIOS中启用与否，可以在机器BIOS中启用，应用工具则是运行在具体操作系统下面的。</p>
<p>linux的ethtool工具可以用于修改网卡上WOL的状态，决定从网络唤醒是否启用。使用 <code>ethtool -s eth0 wol g</code> 就可以启用网卡的网络唤醒功能。 <code>wol d</code>表示禁用。</p>
<p>linux的 <code>wakeonlan</code>工具是唤醒网卡的终端。它接受MAC地址作为参数，唤醒局域网中具有此MAC的机器。</p>
<p>完成PXE启动的时候，导出NFSROOT目录，配置为</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/etc/exports: the access control list for filesystems which may be exported</div><div class="line">    to NFS clients.  See exports(5).</div><div class="line"></div><div class="line">Example for NFSv2 and NFSv3:</div><div class="line">/srv/homes       hostname1(rw,sync,no_subtree_check) hostname2(ro,sync,no_subtree_check)</div><div class="line"></div><div class="line">Example for NFSv4:</div><div class="line">/srv/nfs4        gss/krb5i(rw,sync,fsid=0,crossmnt,no_subtree_check)</div><div class="line">/srv/nfs4/homes  gss/krb5i(rw,sync,no_subtree_check)</div><div class="line"></div><div class="line">/srv/www    *(ro)</div><div class="line">/srv/tftpboot/ *(no_subtree_check,rw,no_root_squash,async)</div></pre></td></tr></table></figure>
<p>然后在启动文件 <code>pxelinux.cfg/default</code> 中配置启动选项为:</p>
<figure class="highlight plain"><figcaption><span>.shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"># D-I config version 2.0</div><div class="line">prompt 0</div><div class="line">timeout 100</div><div class="line"></div><div class="line">DEFAULT ubuntu</div><div class="line">LABEL ubuntu</div><div class="line">KERNEL ../ubuntu/casper/vmlinuz.efi</div><div class="line">APPEND initrd=../ubuntu/casper/initrd.lz boot=casper netboot=nfs root=/dev/nfs nfsroot=10.10.10.1:/srv/tftpboot/ubuntu ip=dhcp</div></pre></td></tr></table></figure>
<p>其中 <code>/srv/tftpboot/ubuntu</code> 相当于光盘的根目录，里面有linux安装光盘里面的所有的文件。这种方式只需要NFS就可以，不用HTTP服务，因此是一种比较好的解决的办法。</p>
<p>剩下的就是 <code>wakonlan</code> 的测试了。这也应该是不成为问题的。只需要将网卡配置好就可以了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/09/14/140914-Scala基本教程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/14/140914-Scala基本教程/" itemprop="url">
                  Scala语言编程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-14T00:00:00+08:00">
                2014-09-14
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:13+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014/09/14/140914-Scala基本教程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/14/140914-Scala基本教程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>接触过许多编程语言后，对Scala也就不那么热心了。一句话，Scala有的，有什么是在其它编程语言中没有的么？像函数式编程语言、面向对象编程，找了一打，也找不到以Scala为代表。在具体特性上，Python的字典，比Scala的映射表其实更为好用。在叠代上，Python至少更方便，而且C#的LINQ查询似乎比Scala走得更远。Scala是静态类型的，而现在，有很多脚本语言已经成为了“高级动态语言”，这也是Scala望尘莫及的。</p>
<p>个人觉得，对Scala语言的正确定位是，它是一种新的开发应用的方式，按照Scala的这种方式，并不需要激进的革命，传统的程序员就可以完成转型。因此，软件工程与编程语言的结合得到了保留，一个语言同时也就是为一个软件工程而生。</p>
<p>甚至C#，因为所使用的CLR技术，比Scala更强调机器的技术。Java和Scala一系的基础结构其实很简单，就是脱离机器的JVM虚拟机。得益于对这个虚拟机的优化，它们得以演变成独立的生态环境。而像Python与Ruby这样的，对于怎样编译其实并不关心，因为有CLR帮助它们，所以Python与Ruby可以更强调编程的灵活。</p>
<h2 id="scala的安装配置和基本使用">Scala的安装、配置和基本使用</h2>
<p>Scala与Java有许多相通之处，因此用Java的观点看Scala往往可以减少学习曲线的坡度。有人说，一周学一打语言都不算是值得称道的计算机科学家，此话对于Scala也是适应用的。</p>
<p>可参见Donald E. Knuth的大作《The Art of Computer Programming》。</p>
<p>在Ubuntu下面，安装scala程序之简单，就不必说了。安装好之后，将会得到scala、scalac、scalap、scaladoc、fsc几个命令。由于Scala的语法糖中有一个是既可作为命令式语言中的脚本，也可作为所有方法都在对象中的类(Java)，所以scala既可以作为Scala语言的解释器，也可以作为运行所谓Scala字节码的运行时环境。该技术的实现另有细节，现在只需记住这两种方式即可。</p>
<p>直接运行scala命令，可以进入脚本式执行环境。里面可以逐个写Scala语句，而不用担心非得使用面向对象的编程，像Java那样，把程序写在类里面。scala命令也可以直接运行一个标准的Scala程序，不过由于每次都要加载大量的类库，即使运行一个HelloWorld这样的程序，需要的时间也相当长。因此把Scala当成一个脚本语言，显得非常别扭。</p>
<p>scalac命令是把scala代码编译成字节码格式，以便以后脱离开发环境也能执行。编译生成的 <code>.class</code> 文件，可以交由scala命令直接处理，运行的速度还可以。不过，Scala的scalac编译器编译HelloWorld这样的程序的时候，也是相当慢，为此有了一个人性化的方案，即使用fsc编译，fsc的作用就是开启一个守护进程，将本次编译之前加载的库文件都缓存下来，下次调用fsc的时候，直接从里面取，因此就加快了编译的速度。</p>
<p>说到底，Scala的scala、scalac、scaladoc工具，与Java的java、javac、javadoc可以分别对应，在Java里怎样使用后者，就可以在Scala里怎样使用前者。scalap可以看成是一个逆向工程工具，用于解码Scala类文件。</p>
<p>平常学习的话，使用scala程序直接写脚本，并使用scala运行即可。此外，Martin Odersky等蓍的《Scala Programming》一书的“附录A：Unix和Windows下的Scala脚本”介绍了把scala脚本当成系统的可执行文件的方法。看起来有用，但是那样用的时候，Scala在各种脚本语言与高级动态语言中显得特别笨重、缓慢，使用它太破坏体验了。这种方法，便就不再介绍了。</p>
<h2 id="scala概述">Scala概述</h2>
<p>定位Scala的正确思路，或许是把Scala看成是Java的自然延伸。这里的自然延伸是从编程语言大家族的发展来看的。Java本身与C和C++相比，其进步并不是很大，但是其业务确实很成功。近些年来，函数式编程、动态类型等开始变得流行，使得传统指令式语言受到一定的冲击。应用型编程语言尤其应当得到改进。因为人们看到了它们存在很多能力上的限制。对于单片机程序的开发语言来说，C语言的短处是它们不必看到的，相反，因为基础，还有更多的长处；对于函数式语言编程者来说，LISP等语言现在已发展得很成熟。不仅有严密的理论，也实现了许多的库，甚至以LISP语言实现了操作系统。所以，Java与Scala好像是正夹在中间，其缺点正好为广大的应用开发者所在意。那么，Java的改进就十分现实了。</p>
<p>在设计软件产品上，很多时候，一开始的思想固定下来后，再对它修修补补，还不如来一场更彻底的革命。Java虽然做了很多的改进，然而这些改进似乎不仅不能转化成优势，而且使语言本身变得更为复杂，不得不全部推倒，重新实现。其结果，大概就是现在的Scala了。</p>
<p>Scala本身仍是面向对象的、静态类型的语言。这可能是出于符合现在应用程序员的习惯，也可能是不得不这么做。这使得函数式编程还不能成为该语言的核心卖点。这么说吧。把Scala看成是改进的Java。</p>
<p>即使在Java当中，语法特性也并不值得单独去讲。因此在Scala中，对于经典的数据类型、函数、运算符、控制语句，都略写；对于Scala在业务应用上的特点给以重点的介绍。如线程与消息处理机制。另外，不变类型、 <span class="math inline">\(\lambda\)</span>-演算，笔者在其它语言中也接触过许多，也作简略处理。</p>
<p>一句话，Scala不适合作算法级（结构级）的编程语言，它主要是一个工程级（应用级）的编程语言。</p>
<h2 id="单独运行的scala程序">单独运行的Scala程序</h2>
<p>要使Scala程序能单独运行（在Scala中，指的是可以编译成字节码在Scala虚拟机中执行，并非操作系统直接可认知），程序就要有一个main方法。该方法仅有一个 <code>Array[String]</code> 作为参数，并以 <code>Unit</code>作为返回类型。任何拥有这样签名的main方法的单例对象都可以作为程序的入口。</p>
<p>单独运行的Scala程序示例</p>
<figure class="highlight plain"><figcaption><span>.scala&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">object Hello &#123;</div><div class="line">    def main(args: Array[String]) &#123;</div><div class="line">        for (arg &lt;- args) println(&quot;Hello, World!&quot;)</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Scala应用程序源文件一般以 <code>.scala</code> 作为后缀。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/09/13/160104-MathGL/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/13/160104-MathGL/" itemprop="url">
                  MathGL绘图工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-13T00:00:00+08:00">
                2014-09-13
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:20+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014/09/13/160104-MathGL/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/13/160104-MathGL/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>该绘图工具的应用也很广，但是之前一直都没有能够接触到。现在才将相关的内容补充到笔记当中，希望这是一个非常有效的绘图的工具。</p>
<p>MathGL在Ubuntu下的安装是一件简单的事，安装mathgl关键字开头的程序、文档、头文件与库文件、面向Python语言的python-mathgl库，以及udav可视化工具即可。MathGL支持几种不同的编程方式，面向C、C++、Fortran、Octave或者Python。根据需要，应当安装上不同的接口。也许有一天，支持R也是可行的。此外，MathGL工具还可以分析一种称为MGL的脚本文件，该脚本文件可以方便地完成MathGL中的一些绘图操作，是值得学习的一种操作方式。</p>
<p>在绘图过程中，MathGL有自己的字体系统，但是尽量可以做到与TeX的兼容。不仅可以方便地选择字体，而且提供了大量的数学符号。这些对于初学者及一般的应用都是非常充足的。</p>
<p>MathGL有很多优点。如脚本化的绘图语言、C++的执行效率、多语言接口、支持输出多种图形格式、内建多种绘图方法、支持MPI等编程接口、与C++等宿主语言的数据结构融合。这些使它成为很有吸引力的一个绘图库。</p>
<h2 id="mathgl基础操作">MathGL基础操作</h2>
<p>首先我们介绍在MathGL在C++下的使用。像C++这类接口，一般要安装lib*这样的软件包，而不只mathgl软件包一个，这样g++在编译的时候，才可能与正确的库文件链接。这是一个需要注意的地方。如果下面的MathGL C++程序出错，根据编译器反馈的错误信息，我们应当能够发现错误、纠正错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mgl2/mgl.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></div><div class="line">&#123;</div><div class="line">    mglGraph graph;</div><div class="line">    graph.FPlot(<span class="string">"sin(pi*x)"</span>);</div><div class="line">    graph.WriteFrame(<span class="string">"test.png"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译、运行<code>mathgl1.cpp</code>，查看图片所使用的Bash命令建议为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">g++ -lmgl mathgl1.cpp -o mathgl1</div><div class="line">./mathgl1</div><div class="line">eog sample.png</div></pre></td></tr></table></figure>
<p>注：如果使用了其它的绘图接口，可能需要使用 <code>-lmgl-wnd</code> 等库。</p>
<p>MathGL的绘图画布中使用帧、子图等概念，因此一个 <code>mglGraph</code>对象可以创造出多个子图的组合，以及多个帧的组合。后者使MathGL有制作动画的能力。</p>
<p>使用MGL脚本的时候，MathGL中有 <code>mglconv</code> 工具和 <code>mglview</code>工具可以使用。它们 是运行MGL脚本的宿主环境。</p>
<p>MathGL库支持的输出方式，包括向图形终端输出，此方式下可以完成一些交互式的动作；直接写入到点阵或者矢量图形格式，此方式下直接运行MathGL的C++程序以得到结果。</p>
<h2 id="窗口绘图glut绘图与输出到文件">窗口绘图、GLUT绘图与输出到文件</h2>
<p>绘图到一个单独的窗口，或者使用GLUT库输出，道理是一样的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;mgl2/mgl.h&gt;</div><div class="line">#include &lt;mgl2/window.h&gt;</div><div class="line"></div><div class="line">int do_draw(mglGraph *graph)</div><div class="line">&#123;</div><div class="line">    graph-&gt;Rotate(60,40);</div><div class="line">    graph-&gt;Box();</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">    mglWindow window(do_draw, "MathGL Window example');</div><div class="line">    int status = window.Run();</div><div class="line">    return status;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原理就是如此了，不过在Ubuntu上有些错误，可能是安装MathGL的问题。</p>
<p>使用GLUT作为后端的时候，更为简单，因为不用WX组件了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mgl2/mgl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mgl2/glut.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_draw</span><span class="params">(mglGraph *graph)</span></span></div><div class="line">&#123;</div><div class="line">    graph-&gt;Rotate(<span class="number">60</span>,<span class="number">40</span>);</div><div class="line">    graph-&gt;Box();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function">mglGLUT <span class="title">window</span><span class="params">(do_draw, <span class="string">"MathGL Window example"</span>)</span></span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在编译的时候，调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ mglut.cpp -o mglut -lmgl -lmgl-glut</div></pre></td></tr></table></figure>
<p>如果将 <code>-lmgl</code> 选项放在 <code>mglut.cpp</code>的前面，似乎总会出现连接错误。这个问题 目前还不知道是怎么样的一回事。</p>
<p>在GLUT界面中，使用aswd按键旋转图形，使用r与f切换透明(transparency)与光照(lighting)状态。按键x可以退出窗口。</p>
<p>说明：以后我们的绘图的时候，就使用上面的代码所提供的方法，把绘图的代码都放在 <code>do\_draw()</code> 函数里面，然后由 <code>mglGLUT</code>对象调用。这样可以使我们更 专心于图形的绘制。</p>
<p>如果是输出到文件，那么调用 <code>mglGraph</code> 对象的 <code>WritePNG()</code>、 <code>WriteEPS()</code> 等 函数即可。在使用g++编译的时候，除了<code>-lmgl</code> 选项，其它都不用。</p>
<p>动画的制作使用 <code>mglGraph</code>对象的多帧功能。如果是保存GIF格式，在绘出每帧 之前，就应当使用<code>mglGraph</code> 的 <code>StartGIF()</code> 函数保存文件，并在完成所有的帧的绘制之后使用 <code>CloseGIF()</code> 函数关闭GIF文件的描述符。</p>
<p>保存动画还有另一种方法，就是绘制完当前帧后，以frameXX.jpg的格式保存当前帧，然后切换到下一帧。所有的帧都各自输出成JPEG格式后，使用ImageMagick提供的convert命令将JPEG制作成MPG。</p>
<p>MathGL也支持在Qt绘图画布中绘图，图形作为Qt窗口的一部分。但是那并非MathGL绘图语言的核心。现在不讲，或许以后结合PyQt库使用MathGL的时候这个功能我们会用到。</p>
<h2 id="mathgl对子图绘制的支持">MathGL对子图绘制的支持</h2>
<p>MathGL采用“选中-绘制”的方法支持子图的绘制，也就是一个<code>mglGraph</code> 对象使用 <code>SubPlot()</code>方法选中一块子图区域，之后还是使用 <code>mglGraph</code> 对象的<code>Title()</code>等函数来操作绘图，此时图形会自动绘制在当前的子图上。在绘制子图的时候，另一种编程实现是“切换-绘制”的方法。该方法是调用当前绘图对象的方法产生一个子图对象，通过操作子图对象的方法在子图上绘图。Asymptote与Mathplotlib等都是采用这种方法。MathGL是前一种方法，因此要与后一种实现方式区分开。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_draw</span><span class="params">(mglGraph *g)</span></span></div><div class="line">&#123;</div><div class="line">    g-&gt;SubPlot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>); g-&gt;Box();</div><div class="line">    g-&gt;Puts(mglPoint(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>),:<span class="string">"Just box"</span>, <span class="string">":L"</span>);</div><div class="line">    g-&gt;InPlot(<span class="number">0.2</span>,<span class="number">0.5</span>,<span class="number">0.7</span>,<span class="number">1</span>,<span class="literal">false</span>);</div><div class="line">    g-&gt;Box();</div><div class="line">    g-&gt;Puts(mglPoint(<span class="number">0</span>,<span class="number">1.2</span>), <span class="string">"InPlot Example"</span>);</div><div class="line"></div><div class="line">    g-&gt;SubPlot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</div><div class="line">    g-&gt;Title(<span class="string">"Rotate only"</span>);</div><div class="line">    g-&gt;Rotate(<span class="number">50</span>,<span class="number">60</span>);</div><div class="line">    g-&gt;Box();</div><div class="line"></div><div class="line">    g-&gt;SubPlot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</div><div class="line">    g-&gt;Title(<span class="string">"Rotate and Aspect"</span>);</div><div class="line">    g-&gt;Rotate(<span class="number">50</span>,<span class="number">60</span>);</div><div class="line">    g-&gt;Aspect(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">    g-&gt;Box();</div><div class="line"></div><div class="line">    g-&gt;SubPlot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">    g-&gt;Title(<span class="string">"Aspect in other direction"</span>);</div><div class="line">    g-&gt;Rotate(<span class="number">50</span>,<span class="number">60</span>);</div><div class="line">    g-&gt;Aspect(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);</div><div class="line">    g-&gt;Box();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更复杂的子图绘制方式，可以参考 <code>MultiPlot()</code> 、<code>StickPlot()</code> 等函数。</p>
<p>剩下的就是具体各种图形的绘制了。</p>
<h3 id="使用mathgl绘制动画示例">使用MathGL绘制动画示例</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_draw</span><span class="params">(mglGraph *gr)</span></span></div><div class="line">&#123;</div><div class="line">    gr-&gt;NewFrame();</div><div class="line">    gr-&gt;Rotate(<span class="number">60</span>,<span class="number">40</span>);</div><div class="line">    gr-&gt;Box();</div><div class="line">    gr-&gt;EndFrame();</div><div class="line">    gr-&gt;NewFrame();</div><div class="line">    gr-&gt;Box();</div><div class="line">    gr-&gt;Axis(<span class="string">"xy"</span>);</div><div class="line">    gr-&gt;EndFrame();</div><div class="line">    <span class="keyword">return</span> gr-&gt;GetNumFrame();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用mgl脚本语言">使用MGL脚本语言</h2>
<p>MGL脚本语言其实是很方便的一个东西。该语言每一行都代表一个命令，类似于tcl脚本，而且连注释的格式都是与tcl语言相同的：从<code>#</code>开始直到行尾。另一方面，MGL脚本按行分析语句，语句的第一个单词代表一个命令，像Bash中那样。而MGL脚本中的字符串用成对的单引号括起来，如果需要跨行，则使用反斜杠加换行表示将本行与下一行联系在一起。</p>
<p>MGL脚本中的命令都来自 <code>mglGraph</code>的成员函数，因此只要我们了解了MathGL面向C++的库的用法，自然就知道如何写MGL脚本文件。</p>
<p>除此之外，MGL还有一些定义函数、声明变量的语句。它们都转成相应的C++的语法。在C++中使用MGL语言也是可行的，因为MGL脚本会通过 <code>Parse()</code>函数 被解析，由 <code>Execute()</code>函数执行。(两个函数都在mgl2/mgl.h头文件中)。</p>
<p>A. A. Balakin所蓍的《MathGL官方文档》中的《MathGL core》一章，既介绍了MathGL语言(C++库的函数)，同时又介绍了MGL的命令，是MGL语言与MathGL库的最标准的参考手册。</p>
<p>MathGL所提供的mglconv工具可以将MGL脚本转换成PGF/TikZ、EPS、PRC、SVG等格式，因此也可以作为一个实用的面向TeX文档的接口。这样一来，可能在MathGL中文字处理变得更简单了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/09/13/140913-github博客/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/13/140913-github博客/" itemprop="url">
                  千呼万唤始出来(整好github)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-13T00:00:00+08:00">
                2014-09-13
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:13+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014/09/13/140913-github博客/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/13/140913-github博客/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="整理github博客">整理github博客</h2>
<p>测试了很多。现在的代码应该是正常的吧。</p>
<p>代码使用Python块，使用Markdown内嵌的支持。</p>
<p>A block of text.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> os</div><div class="line"><span class="keyword">print</span> <span class="string">"hello,world"</span></div></pre></td></tr></table></figure>
<p>代码虽然不是很好看，但是也可以接受。</p>
<p>数学公式使用MathJax插件，下面的是勾股定理： <span class="math display">\[a^2+b^2=c^2.\]</span></p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/09/13/140913-MathGL/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/09/13/140913-MathGL/" itemprop="url">
                  MathGL绘图工具
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-09-13T00:00:00+08:00">
                2014-09-13
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:13+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014/09/13/140913-MathGL/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/09/13/140913-MathGL/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>该绘图工具的应用也很广，但是之前一直都没有能够接触到。现在才将相关的内容补充到笔记当中，希望这是一个非常有效的绘图的工具。</p>
<p>MathGL在Ubuntu下的安装是一件简单的事，安装mathgl关键字开头的程序、文档、头文件与库文件、面向Python语言的python-mathgl库，以及udav可视化工具即可。MathGL支持几种不同的编程方式，面向C、C++、Fortran、Octave或者Python。根据需要，应当安装上不同的接口。也许有一天，支持R也是可行的。此外，MathGL工具还可以分析一种称为MGL的脚本文件，该脚本文件可以方便地完成MathGL中的一些绘图操作，是值得学习的一种操作方式。</p>
<p>在绘图过程中，MathGL有自己的字体系统，但是尽量可以做到与TeX的兼容。不仅可以方便地选择字体，而且提供了大量的数学符号。这些对于初学者及一般的应用都是非常充足的。</p>
<p>MathGL有很多优点。如脚本化的绘图语言、C++的执行效率、多语言接口、支持输出多种图形格式、内建多种绘图方法、支持MPI等编程接口、与C++等宿主语言的数据结构融合。这些使它成为很有吸引力的一个绘图库。</p>
<h2 id="mathgl基础操作">MathGL基础操作</h2>
<p>首先我们介绍在MathGL在C++下的使用。像C++这类接口，一般要安装lib*这样的软件包，而不只mathgl软件包一个，这样g++在编译的时候，才可能与正确的库文件链接。这是一个需要注意的地方。如果下面的MathGL C++程序出错，根据编译器反馈的错误信息，我们应当能够发现错误、纠正错误。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mgl2/mgl.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></div><div class="line">&#123;</div><div class="line">    mglGraph graph;</div><div class="line">    graph.FPlot(<span class="string">"sin(pi*x)"</span>);</div><div class="line">    graph.WriteFrame(<span class="string">"test.png"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译、运行<code>mathgl1.cpp</code>，查看图片所使用的Bash命令建议为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">g++ -lmgl mathgl1.cpp -o mathgl1</div><div class="line">./mathgl1</div><div class="line">eog sample.png</div></pre></td></tr></table></figure>
<p>注：如果使用了其它的绘图接口，可能需要使用 <code>-lmgl-wnd</code> 等库。</p>
<p>MathGL的绘图画布中使用帧、子图等概念，因此一个 <code>mglGraph</code>对象可以创造出多个子图的组合，以及多个帧的组合。后者使MathGL有制作动画的能力。</p>
<p>使用MGL脚本的时候，MathGL中有 <code>mglconv</code> 工具和 <code>mglview</code>工具可以使用。它们 是运行MGL脚本的宿主环境。</p>
<p>MathGL库支持的输出方式，包括向图形终端输出，此方式下可以完成一些交互式的动作；直接写入到点阵或者矢量图形格式，此方式下直接运行MathGL的C++程序以得到结果。</p>
<h2 id="窗口绘图glut绘图与输出到文件">窗口绘图、GLUT绘图与输出到文件</h2>
<p>绘图到一个单独的窗口，或者使用GLUT库输出，道理是一样的。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">#include &lt;mgl2/mgl.h&gt;</div><div class="line">#include &lt;mgl2/window.h&gt;</div><div class="line"></div><div class="line">int do_draw(mglGraph *graph)</div><div class="line">&#123;</div><div class="line">    graph-&gt;Rotate(60,40);</div><div class="line">    graph-&gt;Box();</div><div class="line">    return 0;</div><div class="line">&#125;</div><div class="line"></div><div class="line">int main(int argc, char* argv[])</div><div class="line">&#123;</div><div class="line">    mglWindow window(do_draw, "MathGL Window example');</div><div class="line">    int status = window.Run();</div><div class="line">    return status;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原理就是如此了，不过在Ubuntu上有些错误，可能是安装MathGL的问题。</p>
<p>使用GLUT作为后端的时候，更为简单，因为不用WX组件了。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mgl2/mgl.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mgl2/glut.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_draw</span><span class="params">(mglGraph *graph)</span></span></div><div class="line">&#123;</div><div class="line">    graph-&gt;Rotate(<span class="number">60</span>,<span class="number">40</span>);</div><div class="line">    graph-&gt;Box();</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></div><div class="line">&#123;</div><div class="line">    <span class="function">mglGLUT <span class="title">window</span><span class="params">(do_draw, <span class="string">"MathGL Window example"</span>)</span></span>;</div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在编译的时候，调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">g++ mglut.cpp -o mglut -lmgl -lmgl-glut</div></pre></td></tr></table></figure>
<p>如果将 <code>-lmgl</code> 选项放在 <code>mglut.cpp</code>的前面，似乎总会出现连接错误。这个问题 目前还不知道是怎么样的一回事。</p>
<p>在GLUT界面中，使用aswd按键旋转图形，使用r与f切换透明(transparency)与光照(lighting)状态。按键x可以退出窗口。</p>
<p>说明：以后我们的绘图的时候，就使用上面的代码所提供的方法，把绘图的代码都放在 <code>do\_draw()</code> 函数里面，然后由 <code>mglGLUT</code>对象调用。这样可以使我们更 专心于图形的绘制。</p>
<p>如果是输出到文件，那么调用 <code>mglGraph</code> 对象的 <code>WritePNG()</code>、 <code>WriteEPS()</code> 等 函数即可。在使用g++编译的时候，除了<code>-lmgl</code> 选项，其它都不用。</p>
<p>动画的制作使用 <code>mglGraph</code>对象的多帧功能。如果是保存GIF格式，在绘出每帧 之前，就应当使用<code>mglGraph</code> 的 <code>StartGIF()</code> 函数保存文件，并在完成所有的帧的绘制之后使用 <code>CloseGIF()</code> 函数关闭GIF文件的描述符。</p>
<p>保存动画还有另一种方法，就是绘制完当前帧后，以frameXX.jpg的格式保存当前帧，然后切换到下一帧。所有的帧都各自输出成JPEG格式后，使用ImageMagick提供的convert命令将JPEG制作成MPG。</p>
<p>MathGL也支持在Qt绘图画布中绘图，图形作为Qt窗口的一部分。但是那并非MathGL绘图语言的核心。现在不讲，或许以后结合PyQt库使用MathGL的时候这个功能我们会用到。</p>
<h2 id="mathgl对子图绘制的支持">MathGL对子图绘制的支持</h2>
<p>MathGL采用“选中-绘制”的方法支持子图的绘制，也就是一个<code>mglGraph</code> 对象使用 <code>SubPlot()</code>方法选中一块子图区域，之后还是使用 <code>mglGraph</code> 对象的<code>Title()</code>等函数来操作绘图，此时图形会自动绘制在当前的子图上。在绘制子图的时候，另一种编程实现是“切换-绘制”的方法。该方法是调用当前绘图对象的方法产生一个子图对象，通过操作子图对象的方法在子图上绘图。Asymptote与Mathplotlib等都是采用这种方法。MathGL是前一种方法，因此要与后一种实现方式区分开。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_draw</span><span class="params">(mglGraph *g)</span></span></div><div class="line">&#123;</div><div class="line">    g-&gt;SubPlot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>); g-&gt;Box();</div><div class="line">    g-&gt;Puts(mglPoint(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">1</span>),:<span class="string">"Just box"</span>, <span class="string">":L"</span>);</div><div class="line">    g-&gt;InPlot(<span class="number">0.2</span>,<span class="number">0.5</span>,<span class="number">0.7</span>,<span class="number">1</span>,<span class="literal">false</span>);</div><div class="line">    g-&gt;Box();</div><div class="line">    g-&gt;Puts(mglPoint(<span class="number">0</span>,<span class="number">1.2</span>), <span class="string">"InPlot Example"</span>);</div><div class="line"></div><div class="line">    g-&gt;SubPlot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>);</div><div class="line">    g-&gt;Title(<span class="string">"Rotate only"</span>);</div><div class="line">    g-&gt;Rotate(<span class="number">50</span>,<span class="number">60</span>);</div><div class="line">    g-&gt;Box();</div><div class="line"></div><div class="line">    g-&gt;SubPlot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>);</div><div class="line">    g-&gt;Title(<span class="string">"Rotate and Aspect"</span>);</div><div class="line">    g-&gt;Rotate(<span class="number">50</span>,<span class="number">60</span>);</div><div class="line">    g-&gt;Aspect(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">    g-&gt;Box();</div><div class="line"></div><div class="line">    g-&gt;SubPlot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line">    g-&gt;Title(<span class="string">"Aspect in other direction"</span>);</div><div class="line">    g-&gt;Rotate(<span class="number">50</span>,<span class="number">60</span>);</div><div class="line">    g-&gt;Aspect(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>);</div><div class="line">    g-&gt;Box();</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>更复杂的子图绘制方式，可以参考 <code>MultiPlot()</code> 、<code>StickPlot()</code> 等函数。</p>
<p>剩下的就是具体各种图形的绘制了。</p>
<h3 id="使用mathgl绘制动画示例">使用MathGL绘制动画示例</h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_draw</span><span class="params">(mglGraph *gr)</span></span></div><div class="line">&#123;</div><div class="line">    gr-&gt;NewFrame();</div><div class="line">    gr-&gt;Rotate(<span class="number">60</span>,<span class="number">40</span>);</div><div class="line">    gr-&gt;Box();</div><div class="line">    gr-&gt;EndFrame();</div><div class="line">    gr-&gt;NewFrame();</div><div class="line">    gr-&gt;Box();</div><div class="line">    gr-&gt;Axis(<span class="string">"xy"</span>);</div><div class="line">    gr-&gt;EndFrame();</div><div class="line">    <span class="keyword">return</span> gr-&gt;GetNumFrame();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用mgl脚本语言">使用MGL脚本语言</h2>
<p>MGL脚本语言其实是很方便的一个东西。该语言每一行都代表一个命令，类似于tcl脚本，而且连注释的格式都是与tcl语言相同的：从<code>#</code>开始直到行尾。另一方面，MGL脚本按行分析语句，语句的第一个单词代表一个命令，像Bash中那样。而MGL脚本中的字符串用成对的单引号括起来，如果需要跨行，则使用反斜杠加换行表示将本行与下一行联系在一起。</p>
<p>MGL脚本中的命令都来自 <code>mglGraph</code>的成员函数，因此只要我们了解了MathGL面向C++的库的用法，自然就知道如何写MGL脚本文件。</p>
<p>除此之外，MGL还有一些定义函数、声明变量的语句。它们都转成相应的C++的语法。在C++中使用MGL语言也是可行的，因为MGL脚本会通过 <code>Parse()</code>函数 被解析，由 <code>Execute()</code>函数执行。(两个函数都在mgl2/mgl.h头文件中)。</p>
<p>A. A. Balakin所蓍的《MathGL官方文档》中的《MathGL core》一章，既介绍了MathGL语言(C++库的函数)，同时又介绍了MGL的命令，是MGL语言与MathGL库的最标准的参考手册。</p>
<p>MathGL所提供的mglconv工具可以将MGL脚本转换成PGF/TikZ、EPS、PRC、SVG等格式，因此也可以作为一个实用的面向TeX文档的接口。这样一来，可能在MathGL中文字处理变得更简单了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/06/26/140626-Gnuplot/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/06/26/140626-Gnuplot/" itemprop="url">
                  Gnuplot绘图
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-06-26T00:00:00+08:00">
                2014-06-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:13+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014/06/26/140626-Gnuplot/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/06/26/140626-Gnuplot/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>使用过很多的绘图的软件了，但是用起来总是不那么方便。而且我的绘图是在文档当中的，要求与文档有相同的风格。但是通常情况下，这些都难以达到。因此，不管是Asymptote还是其它的软件，配置起来都比较麻烦。</p>
<p>MetaPost的问题是，Metapost与XeTeX不太兼容。使用中文的时候又不方便了。所以我们还是使用其它的方法。</p>
<p>gnuplot有一个优点，就是它可输出成TeX的源代码的格式。第一种是LaTeX自带的picture环境，在里面直接绘图。第二种是tikz环境。无论哪一种环境，排版的工作都是连同文字一起的。所以正文是什么格式，其它文章也可以是这样的格式。</p>
<p>如果将gnuplot的输出改成picture环境，那么在每个gnuplot文件前面添加如下的行：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set terminal latex    ## 也可以是emtex环境。</div><div class="line">set output &quot;pic.tex&quot;  ## 生成的.tex文件。</div></pre></td></tr></table></figure>
<p>然后使用<code>\input{pic.tex}</code>将生成的文件嵌入到文本中，注意段落的安排，以及将图表排版有适当的空格。</p>
<p>如果将gnuplot的输出改成tikzpicture环境，那么在每个gnuplot文件前添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">set terminal tikz     ## 也可以是 set terminal lua tikz。</div><div class="line">## 还可以在 tikz 后添加额外选项，如 fontscale 0.9 , latex, tex, context。</div><div class="line">set output &quot;pic.tex&quot;</div></pre></td></tr></table></figure>
<p>同样使用<code>\input{pic.tex}</code>将生成的文件嵌入到文本中。不过tikz图像 也可以在 <code>plain TeX</code> 环境下使用，因此使用这种方法，支持在tex或者xetex环境中插入图片，并不局限于latex或者xelatex。如果是在LaTeX环境中使用，则需要使用如下的宏包：</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;tikz&#125;</span></span></div><div class="line"><span class="tag">\<span class="name">usepackage</span><span class="string">&#123;gnuplot-lua-tikz&#125;</span></span></div></pre></td></tr></table></figure>
<p>如果是plain TeX，则使用<code>\input gnuplot-lua-tikz.tex</code>命令。这样一来，gnuplot就非常能够满足我们的需要了。所以我们学习绘图也就从 它开始讲起。</p>
<h2 id="gnuplot绘图基础">Gnuplot绘图基础</h2>
<p>Gnuplot是一个交互式的绘图语言。绘出的图形展示在一个设备上。所以我们在绘图脚本中需要指定绘图的终端类型，以及输出的文件。默认情况下，Gnuplot是将图形输出到显示器。我们也可以更改成其它类型。前面我们就已经介绍了如何将图形导出成 <code>.tex</code> 格式。实际上，Gnuplot支持几乎所有的图片格式与文档格式，完整的支持可以参考Gnuplot官方文档的 <code>Terminal Types</code>一节。</p>
<p>从4.6版本开始，Gnuplot支持了控制语句 <code>if/else/while/do</code>。这使得一些 表达式变得非常简单。</p>
<p>建议对Gnuplot文件使用 <code>.gpl</code> 扩展名。</p>
<p>出于排版文档的需要，在绘图之前，我们需要明确地指定绘图画布的大小，使图片不超过这个区域。在Gnuplot中，是通过 <code>set termial</code> 命令的<code>size XX,YY</code>实现的。任何终端均支持这个选项，前面的文档也不例外。如果<code>terminal</code> 类型 是 <code>tikz</code> ，那么默认的单位是 <code>cm</code>，后面跟数字。实际上， <code>XX</code> 、 <code>YY</code> 的 单位也可以是<code>mm</code> 、 <code>in</code> 、 <code>pt</code>等。建议在绘图之前给图像确定一个大小。</p>
<p><code>set size XX,YY</code> 命令也起到设置图片大小的命令。但是它只是改变绘图区的大小，而非改变画布的大小。绘图区的大小可以通过 <code>ratio</code> 等指定，分别表示在 (X) 或 (Y) 方向的比例缩放的情况。</p>
<p>在Gnuplot当中，绘图都是通过绘图语句实现的，因此讲的并不多。重点的是Gnuplot的数据类型与运算规则。</p>
<p>而Gnuplot的表达式运算规则主要来自于C语言。与C语言相同，Gnuplot的表达式中间的空格会被忽略。</p>
<p>在Gnuplot当中，复数值有特定的表示方法，一个二维数组，用大括号括起来，就是一个复数，第一分量代表实部，第二分量代表虚部。如 <code>{3,2}</code> 代表着复数 (3+2i)。如果对字符串使用用于数值类型的运算符，则Gnuplot尝试把字符串转成数值再进行运算。比如在Gnuplot当中， <code>&quot;3&quot;+&quot;4&quot;=7</code> ，并且 <code>6.78=&quot;6.78&quot;</code> 。</p>
<p>对字符串允许使用下标运算符 <code>[BEGIN:END]</code> ，表示提取数组中区间<span class="math inline">\([BEGIN,END]\)</span>中的元素。使用 <code>*</code> 号，可以代表对其中一个区间不加限制。</p>
<p>在Gnuplot当中内置了许多数学函数，而反函数在原函数前加 <code>a</code> ，如 <code>sin(x)</code> 的 反函数是 <code>asin(y)</code> 。三角函数的单位是弧度。<code>**</code> 表示取幂运算， <code>*</code> 表示乘法。 <code>.</code>表示字符串的连接。 <code>ne</code> 、 <code>eq</code> 表示字符串的相等的判断（而 <code>==</code> 表示 的是两个数值类型的相等。</p>
<h3 id="绘图语句">绘图语句</h3>
<p>在Gnuplot中实际绘图的语句只有 <code>plot</code> 、 <code>splot</code> 、<code>replot</code> 三个。 <code>plot</code> 语句产生2D图形， <code>splot</code> 产生3D图形，而 <code>replot</code> 则是把它的参数 加到前一 <code>plot</code> 或 <code>splot</code> 语句绘图当中，并修改它们的绘图结果。</p>
<p><code>plot</code> 绘图可以使用直角坐标或者极坐标，具体行为受到 <code>set polar</code> 命令的 影响。 <code>splot</code> 绘图仅能使用直角坐标，但是也能通过 <code>set mapping</code> 选项使用其它的一些坐标系。最后， <code>using</code> 命令可以让我们对付大多数的坐标系。</p>
<p>在直角坐标系下面， <code>plot</code> 命令可以使用四个坐标轴 (X) 、 (X2)、 (Y) 和 (Y2) 。它们分别代表底、顶、左、右方向的坐标轴。 <code>axes</code> 选项可以指定我们所使用的数对分别与哪一个坐标轴相对应。坐标轴的刻度也可以修改。比如 <code>set logscale xy</code> 允许我们对两个坐标轴都使用对度刻度。</p>
<p><code>splot</code> 命令可以绘制表面图(surfaces)或者等高图(contours)。使用 <code>set contour</code> 或者 <code>set cntrparam</code> 命令可以改变绘图等高图时候的行为。在3D绘图中，对坐标轴同样可以使用不同的刻度，如对数刻数。</p>
<h3 id="绘图的参数来源">绘图的参数来源</h3>
<p>Gnuplot的绘图语句中都可以直接书写绘图的表达式，它们含有若干个变量。但是表达式可以有不同的产生方法。在赋值语句中，以单引号括起来的内容表示一个Shell命令。在解释时，Gnuplot会将出现的地方替换成相应的结果。比如<span class="math inline">\(f(x)=`whoami`\)</span> ，实际上是<span class="math inline">\(f(x)\)</span>等于命令<span class="math inline">\(whoami\)</span>执行的结果。</p>
<p>在shell命令中，也可以通过 <code>@var</code> 引用Gnuplot里面的变量。即使 <code>\\\``出现在字符串双引号当中，也并不影响命令的执行。</code>“`uname -a`”<code>返回的仍然是命令的结果。不过</code>“uname -a”`并不会引起Gnuplot执行一个系统命令。</p>
<p>绘图语句与绘图风格是相关联的。绘图风格指的是图形的类型，比如直方图，散点图等。绘图风格不同，绘图语句的行为也不相同。</p>
<p>绘图风格由 <code>set style</code> 指定。常包括 <code>set style data</code> 与 <code>set style function</code> 。它们影响其后的 <code>plot</code> 与 <code>splot</code> 语句的行为。</p>
<h2 id="gnuplot绘图工具">GNUplot绘图工具</h2>
<p>使用之后，除了命令行不太方便外，其它地方还很方便。至少可以直接整合到LaTeX里面，这样就使排版的效果大大增强了。</p>
<p>GNUplot的用法其实很简单，其设置是样式、选项与绘图的综合。绘图语法中需要指定数据源以及绘图的样式即可。坐标轴也各自有自己设置的办法。</p>
<p>对GNUPLOT有疑问的话，可以直接使用help语句，此时在对话界面中会显示出来相应的帮助。另外，gnuplot的一个简单的例子如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">set terminal png size 1000,400  </div><div class="line">set output &quot;./sin.png&quot;  </div><div class="line">plot sin(x)</div></pre></td></tr></table></figure>
<p>gnuplot的命令有两类，一类是修改状态，一种是绘图指令。set方法都是修改状态。使用plot, replot, multiplot来绘图。</p>
<p>gnuplot对于数据中的时间项有很好的支持，可以直接将文本中某些数据项设置成时间的格式。这一功能对于日志分析与统计报表极为有用。</p>
<p>上面列举了许多极有有趣的例子。</p>
<p>上面给出了调整直方图的一个教程。</p>
<p>命令式编程语言的绘图包括Python绘图工具，gnuplot, 以及C语言的编译工具等。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/06/16/140616-Awk编程语言/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/06/16/140616-Awk编程语言/" itemprop="url">
                  Awk工具与编程语言
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-06-16T00:00:00+08:00">
                2014-06-16
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:12+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014/06/16/140616-Awk编程语言/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/06/16/140616-Awk编程语言/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="说明">说明</h2>
<p>刚接触unix相关的书籍的时候，里面有一章是专门介绍awk的使用的。但当时觉得它过于复杂，很难记住它是什么，能干什么。想来是因为我知识的储备还不够。Awk主要的思想就是，它的确是一种设计得非常精巧的编程语言，很好地满足了实际应用的同时，也能够让我们以软件工程，编译原理等理论性的东西欣赏它。因此，我就知道awk的使用不再是一件困难的事情。</p>
<h2 id="awk基础">awk基础</h2>
<p>有些东西，理解它的过程，就好像是要进入一个豪华的庭院，要进入门内，非得绕过门前的屏风墙。不这样，就看不到里面的风景。</p>
<p>awk本身的语法是比较怪异的。然而外面的人看到的，往往是用awk写出来的程序，而非程序的规范。所以就不得要领。人们又常常抱着学习awk就直接是为了处理文本的功利目的，一旦不能一眼看出来它在处理文本上的直观，就放弃了。但是，绝大部分事情，是不能凭感官的。我们必须要有一种理论的指导。</p>
<p>让我们忽略掉awk的语法形式，单纯地考虑，如果是我们，将会怎样处理文本，特别是在C语言的框架下编写这样的程序。将能设想到，基本的方法，还是通过传递变量。也就是至多每读取一行，就自动将参数匹配到指定的位置。因此整个awk程序，首先看成是一个函数。宿主环境代理地读取目标文本，并在每次调用函数的时候得到参数。文本处理的思想，也就只能如此了。</p>
<p>另外，我们看到，awk在文本处理上做得更深一步。它本身是一个编译型的语言。也就是说，在文本没有读取之前，宿主环境先进行语法等方面的检查，通过之后才开始处理程序。这一点与 <code>make</code> 程序相似。因此，首先应当考虑到awk是如何检查脚本的，再考虑脚本如何执行文件。命令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">awk -f AWK脚本.awk 数据文件</div></pre></td></tr></table></figure>
<p>可以与</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python py脚本.py 参数</div></pre></td></tr></table></figure>
<p>相类比。</p>
<p>通常调用awk的时候，AWK脚本可以是即时编辑的，也就是脚本的内容直接出现在命令行的第一个参数中。把这个功能看成是一个语法糖，也许就顺畅多了。</p>
<p>awk程序的执行流程是：</p>
<ol>
<li>读取指定的脚本命令并进行语法的检查；</li>
<li>从指定的数据文件中读取一个数据行；</li>
<li>自动更新相关的内建变量的值，如 <code>$0</code> , <code>$1</code> , <code>NR</code> ；</li>
<li>依次执行程序中每个 <code>Pattern { Actions }</code> 指令；</li>
<li>处理完当前行之后，读取下一个数据行，自动返回步骤三继续执行；</li>
<li>文件处理完毕，结束运行。</li>
</ol>
<h2 id="awk主要概念">Awk主要概念</h2>
<p>Awk程序的主要语法是 <code>Pattern { Actions }</code> 。一个Awk程序常常由许多这样结构的语句构成。在执行的时候， <code>Pattern</code> 主要是确定一个逻辑表达式，若数据行符合这样的条件，就执行相应的 <code>Actions</code> ；不符合条件则执行下一个 <code>Pattern { Actions }</code> 语句。如果 <code>Pattern</code> 为空，则表示无条件执行该语句的 <code>Actions</code> 。</p>
<p>在 <code>Pattern</code> 部分中，可能最需要介绍的部分是Awk的关系运算符。Awk本身是用C语言编写的，而且继承了其中常见的关系运算符，如 <code>&gt;</code> 、 <code>&lt;</code> 、 <code>&gt;=</code> 、 <code>&lt;=</code> 、 <code>==</code> 、 <code>!=</code> 。此外，Awk还用运算符<sub>与!</sub>表示字符串与正则表达式的匹配。 <code>BEGIN</code> 与 <code>END</code> 是特殊定义的模式匹配语句，分别表示在第一个记录之前，与最后一个记录之后。</p>
<p>在 <code>Actions</code> 部分，主要是许多Awk指令。Awk的指令与C语言也十分相似，大多数时候，只是改用Shell那样的传参方式，而非C语言的函数。Awk的指令大致可分为普通指令与控制指令两类。前者如 <code>print</code> , <code>getline</code> ；后者如 <code>if(...){...} else{...}</code> , <code>while(...){...}...</code> 。除此之外，C语言赋值表达式往往也继续有效。</p>
<p>遇到 <code>Pattern { Actions }</code> 语句，Awk会先计算 <code>Pattern</code> 的值，若计算出的值为 <code>true</code> 、非零的数字或者非空字符串，则awk将执行后面的 <code>Actions</code> 。在其它条件下，将跳过相应的 <code>Actions</code> 。这一过程，可以与路由器上的ACL处理流程相类比。</p>
<p>为了方便对数据行的处理，Awk提供了许多内建的变量。常见的变量如下：</p>
<table>
<thead>
<tr class="header">
<th align="left">变量符号</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">$0</td>
<td align="left">awk当前所读入数据行的所有内容</td>
</tr>
<tr class="even">
<td align="left">$1</td>
<td align="left">当前所读入数据行的第一个字段的内容，下个字段的变量依次类推</td>
</tr>
<tr class="odd">
<td align="left">$NF</td>
<td align="left">Number of Fields。表示当前读入数据行 <code>$0</code> 含有的字段数</td>
</tr>
<tr class="even">
<td align="left">$NR</td>
<td align="left">Number of Records。表示已读入的数据行的数目</td>
</tr>
<tr class="odd">
<td align="left">$FILENAME</td>
<td align="left">当前文件的名称</td>
</tr>
</tbody>
</table>
<p>注：awk的变量并不需要用<code>$</code>符号括住，用以字母打头的英文字符即可。$实际上是awk的一元运算符，它以一个数字为参数，表示操作“取字段”。</p>
<p>awk处理数据的时候，自动从数据文件中每次读取一行记录，然后将记录切分成若干个字段，程序可使用<code>$1</code>、<code>$2</code>等直接取得字段中的内容。若要简单打印出相应字段，使用<code>print $1, $2</code>这样的语句即可。</p>
<p>此外，awk还提供 <code>printf()</code> 指令，它的使用方式与C语言更相近，用于格式化字符串。</p>
<p>比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">awk &apos;</div><div class="line">&#123; printf(&quot;%d times %d is %d.\n&quot;, $1, $2 ,$1 * $2) &#125;</div><div class="line">&apos;</div><div class="line">234234234 234234234</div></pre></td></tr></table></figure>
<p>将显示出两个字段的乘积。从上面的例子我们也看出，awk的整型运算功能是非常强大的，可以进行非常大的整数之间的运算。可以认为具有无限的精度。</p>
<p>作为一个领域专用的语言，在变量的使用上，要尽可能足够简单。所以awk的变量，不需要宣告就能够使用，类型是自动确定。并且，awk提供的“字典”(有人称为数组)类型，也可以自动使用。引用字典不存在的键值的时候，该键值会自动被创建。</p>
<h3 id="awk与shell指令">awk与shell指令</h3>
<p>在awk中使用shell指令是比较方便的。其思想是让字符串通过管道运算符|与awk内置的函数运算。字符串被当成指令执行，执行后的输出的结果，被当成内置函数的运算符。比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&quot;who&quot; \| getline</div></pre></td></tr></table></figure>
<p><code>getline</code> 是awk的输入指令。当 <code>Pattern</code> 为 <code>BEGIN</code> 或 <code>END</code> 的时候， <code>getline</code> 默认从 <code>stdin</code> 读取数据，否则从awk正处理的数据文件上读取数据。 若是后者，将会使数据文件中的两行当成一个记录来处理。</p>
<p>使用getline之后，变量 <code>$0</code> , <code>$1</code> 等的内容会被刷新。</p>
<p>在awk中，输出文件则使用重定向运算符 <code>&gt;</code> 或 <code>&gt;&gt;</code> 。它可以用在任意 <code>Action</code> 之后。重定向运算符可以理解成一个普通的 <code>Action</code> 与一个字符串运算，而字符串被解释成文件的路径。</p>
<p>awk也提供了一个 <code>system()</code> 函数以调用shell命令。</p>
<p>注意，在执行shell指令的时候，相同的字符串代表同一个pipe名称，因此尽管出现在不同的 <code>Actions</code> 当中，shell命令可能只启动一次。具体意思是，比如 <code>print $1, $2 &gt; &quot;sort -k 1&quot;</code> 这一语句，并非每执行一个 <code>print</code> ，就启动一个 <code>sort -k 1</code> 进程。而是所有 <code>print</code> 出来的内容，都送到 <code>sort -k 1</code> 这个程序的输入管道中，因而所有 <code>print</code> 出来的内容都输入同一文件流中，被 <code>sort -k 1</code> 处理。要想关闭此管道，必须显式地使用 <code>close()</code> 函数。</p>
<h2 id="awk程序的结构">awk程序的结构</h2>
<p>一般而言，awk当中都是 <code>Pattern { Actions }</code> 指令。但是还有其它类型的语句，包括注释与函数定义。注释以#号开头的行，而函数字义与C语言类似，比如 <code>function double(x) {return 2*x}</code> 。</p>
<h2 id="其它">其它</h2>
<p>在写awk程序的时候，可能会用到许多字符串函数，如 <code>substr()</code> , <code>length()</code> 。一般而言，是不可缺少的。</p>
<p>awk读取文件的时候，使用FS作为字段分割符。它可以取一个正则表达式， 但默认情况下都是空白字符。若不想在启动awk时指定 <code>FS</code> ，可以在 <code>BEGIN</code> 对应的 <code>Actions</code> 中更改 <code>FS</code> 的值。</p>
<p>awk读取文件的时候，使用 <code>RS</code> 作为记录分割符。默认 <code>RS</code> 是字符 <code>\n</code> 。但是我们也可以改成其它的符号。特别地，当定义 <code>RS=&quot;&quot;</code> 时，分割符是空白的行。此时，中间无论多少空白行，都被当成是记录分割符。</p>
<p>awk程序也可以有参数。这些参数在程序中通过 <code>ARGV[]</code> 与 <code>ARGC</code> 标识。</p>
<p>awk中所有的变量都默认是全局变量，除了函数参数之外。因此在写递归程序的时候，有一些编程上的技巧。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/06/06/140606-非标准分析/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/06/06/140606-非标准分析/" itemprop="url">
                  非标准分析简介
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-06-06T00:00:00+08:00">
                2014-06-06
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:12+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014/06/06/140606-非标准分析/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/06/06/140606-非标准分析/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>人们对非标准分析的通常说法是非标准分析建立在实数域<span class="math inline">\(\mathbb{R}\)</span>的扩张之上。扩张之后的<span class="math inline">\(\mathbb{R}^*\)</span>包含了无限小的非零数，以及无限大的数。无限小的非零数具有的特点是绝对值比任何正实数都小，无限大的数的特点是绝对值比任何正实数都大。</p>
<p>显然，非标准分析得提供许多有益的结论，并且不会导致与直观相悖的结果才能为人接受。事实上它正符合这一点。因此非标准分析很有发展的前途。</p>
<p>然而为此建立新的公理基础的方法却比较艰难。在微积分的创立时期，Newton,Leibniz都是在一阶与高阶无穷小的基础上发展起了微积分的理论。但是因为不严格而备受责难。现在看来，当时主要是没有严格的逻辑公理基础，因而对实数的理解不够深刻。那么这样的思想，也就是把无穷小与无穷大作为实数中正常的元素的思想，就不能继续发展下去。</p>
<p>个人的观点是，实无穷与潜无穷的争论很难解决。甚至准确地描述它们都显得很困难。所以两种哲学观点，都可能具有一些价值。但是我们还是得从理性的角度出发，哪一个上面建立的理论比较完善，就接受哪一个。如果都比较完善，那么就不舍弃另一个，让两种观点同时向前发展。现在，大概“标准分析”与“非标准分析”两者应该是同时发展的。</p>
<p>按照惯例应当介绍非标准分析的发展历史。不过这个新兴领域中的发展，哪些具有更重要的意义可能不太容易说清。结果，这里就不介绍相关背景了。</p>
<h2 id="超实数的构造背景">超实数的构造背景</h2>
<p>超实数域<span class="math inline">\(\mathbb{R}^*\)</span>是非标准分析的空间模型，有时候也称为实数的非标准模型。非标准分析正是在空间<span class="math inline">\(\mathbb{R}^*\)</span>上展开，因此叙述非标准分析必然从超实数域的构造开始。</p>
<p>任何领域在初创的时期，往往比较极端。非标准分析的极端体现在创立者刚开始的时候尝试通过修正数理逻辑与集合论构造能够容纳非标准分析的模型。这样的工作或许在将来的某个时间，被发现了非标准分析更深刻思想的人继承。不过，一开始就修改逻辑，未免让这个理论变得不必要的复杂。在这时候，有一个相对成熟的模型来解释新的模型，也许是更明智的做法。</p>
<p>所以我们先把从ZFC公理系统添加新的东西而构成的内集合论公理放在一边。 当前，对它的理解仅限于：</p>
<p>知道新公理系统与ZFC公理系统是相容的，</p>
<p>内集合论加上了一个新的一元谓词“标准的”，以及三条新的公理，</p>
<p>新添加的三条公理，转换原理，理想化原理，标准化原理与原来ZFC中的公理一起，构成了所谓“非标准分析的饱和模型”中内集的基本性质，</p>
<p>要研究内集合论公理，可能需要更多的数理逻辑基础。</p>
<p>非标准分析提出之后，有若干个相应的模型。第一个是Robinson给出的，基于数理逻辑的紧致性定理的证明而保证存在的模型。第二个仍是Robinson提出的，但经过许多人的改进后形成的模型。这个模型需要较少的数理逻辑的知识，并且建立在标准分析的概念之上，相当于扩充<span class="math inline">\(\mathbb{R}\)</span>形成的新域。它是目前大多数人习惯使用的模型。第三个，则是1977年美国数学家Nelson.E提出的内集合论公理所表述的非标准分析。当前，第三个主要由法国的非标准分析学派使用。</p>
<p>当前，我们仅使用第二个模型，因为这种模型数学较为简单。而且，它能使我们更关注于用非标准方法解决标准的数学问题，而不是一开始就陷入非标准模型本身逻辑性质的抽象之中。</p>
<p>当前，非标准分析的理论已经在微积分，拓扑学、实分析、广义函数、函数论、泛函分析、李群、弹性力学以及流体力学中得到了应用。或许这个领域真的如哥德尔为Robinson的《非标准分析》所写的序言中所写的那样，“以这种或者那种形式表示的非标准分析，将成为未来的分析学”。</p>
<h2 id="超实数域的超幂构造">超实数域的超幂构造</h2>
<p>完整叙述这个构造，需要熟悉“滤子”，“自由超滤子”等概念。但目前甚至难于找到一本书介绍这些东西。因此我们也不一般地介绍它们是什么。仅仅从有限余滤子开始。</p>
<p>自然数集<span class="math inline">\(\mathbb{N}\)</span>上的有限余滤子指的是由自然数集的补集为有限集的子集构成的集族<span class="math inline">\(\mathscr{F}\)</span>。有限余滤子又称Frechet滤子。这样的滤子我们以前见过，比如说，若自从某项开始，数列<span class="math inline">\(\{a_n\}\)</span>与数<span class="math inline">\(A\)</span>的距离小于<span class="math inline">\(\varepsilon\)</span>，那么显然使<span class="math inline">\(\vert a_n - A \vert &lt; \varepsilon\)</span>的<span class="math inline">\(n\)</span>构成的集合，就具有有限余集。若一实数列在某个具有有限余集的子列上收敛于某个数，显然实数列本身也收敛于这个数。</p>
<p><span class="math inline">\(\mathscr{U}\)</span>需要扩张才能进一步满足非标准分析的要求。扩张后的集族，为一个自由超滤子。扩张的过程是简单的，并且其存在性可由选择公理或Zorn引理证明。自由超滤子<span class="math inline">\(\mathscr{U}\)</span>在<span class="math inline">\(\mathscr{F}\)</span>的基础上，对于任一集合<span class="math inline">\(A \in \mathbb{N}\)</span>，若<span class="math inline">\(A\neq \mathscr{F}\)</span>并且<span class="math inline">\(A^c\neq\mathscr{F}\)</span>，那么取<span class="math inline">\(A\)</span>或<span class="math inline">\(A^c\)</span>中的一个加入<span class="math inline">\(\mathscr{U}\)</span>。直到不能扩张时，就构成了自由超滤子<span class="math inline">\(\mathscr{U}\)</span>。</p>
<p>设<span class="math inline">\(\mathbb{R}^{\mathbb{N}}\)</span>是所有实数列构成的集合，即 <span class="math display">\[\mathbb{R}^{\mathbb{N}}=\{ \{a_n\} \,:\, \{a_n\}:\mathbb{N}\to\mathbb{R}\}。\]</span> 定义两个实数列上关系<span class="math inline">\(R\)</span>为<span class="math inline">\(\{a_n\}\,R\,\{b_n\}\)</span>，当且仅当集族<span class="math inline">\(\mathscr{U}\)</span>的某个集合上数列<span class="math inline">\(\{a_n\}\)</span>与<span class="math inline">\(\{b_n\}\)</span>相等。可以证明关系<span class="math inline">\(R\)</span>是一个等价关系。由这个等价关系构成的等价数的集合，我们就用<span class="math inline">\(\mathbb{R}^*\)</span>来表示。<span class="math inline">\(\mathbb{R}^*\)</span>就是我们要的超实数模型，它里面的元素称为超实数。</p>
<p>在<span class="math inline">\(\mathbb{R}^*\)</span>里，加法与乘法都按照实数列的加法与乘法进行。两个元素 <span class="math inline">\(\langle\{a_n\}\rangle\)</span>与<span class="math inline">\(\langle\{b_n\}\rangle\)</span>的序关系，按照 <span class="math display">\[\langle\{a_n\}\rangle &lt; \langle\{b_n\}\rangle,
\ \mathrm{iff} \ \exists\,S\subseteq\mathscr{U}\,\forall n \in S,\,a_n=b_n\]</span> 来定义。</p>
<p>而原来的实数<span class="math inline">\(r\)</span>，在<span class="math inline">\(\mathbb{R}^*\)</span>中与常值数列<span class="math inline">\(\{r,r,\cdots,r,\cdots\}\)</span>等价。因此使<span class="math inline">\(\mathbb{R}\)</span>自然嵌入到<span class="math inline">\(\mathbb{R}^*\)</span>当中。</p>
<p>这样我们可以将<span class="math inline">\(\mathbb{R}^*\)</span>看成是<span class="math inline">\(\mathbb{R}\)</span>的有序域扩张。</p>
<p>思考收敛于零的实数列<span class="math inline">\(\varepsilon\)</span>，由序的定义，我们知道，对于每个正实数<span class="math inline">\(a\)</span>都有<span class="math inline">\(a&lt;\varepsilon\)</span>。而发散到无穷的序列可以看成无限大。可以证明在超实数域上有这样的表示定理：</p>
<p>每个有限的超实数<span class="math inline">\(x\)</span>，可以唯一分解成 <span class="math display">\[x=x^\circ+\varepsilon.\]</span> 其中<span class="math inline">\(x^\circ\)</span>是<span class="math inline">\(\mathbb{R}\)</span>中的数，而<span class="math inline">\(\varepsilon\)</span>是无限小。</p>
<p>对于任意<span class="math inline">\(x,y\in\mathbb{R}^*\)</span>，我们可证明<span class="math inline">\(x-y\)</span>是无限小，是<span class="math inline">\(x\)</span>与<span class="math inline">\(y\)</span>的等价关系。对于每个<span class="math inline">\(a\in\mathbb{R}\)</span>，我们用<span class="math inline">\(M(a)\)</span>记与<span class="math inline">\(a\)</span>等价的元素的集合，称为<span class="math inline">\(a\)</span>的单子。当<span class="math inline">\(x-y\)</span>是无限小的时候，我们记<span class="math inline">\(x\thickapprox y\)</span>。</p>
<p>现在，在超实数域中，无穷小与无穷大都已经引入了。但是我们知道，有许多的实序列头没有收敛的性质，因此它们的行为就比较复杂。这启示我们进一步限制哪些序列是我们将要在其上进一步讨论的对象。</p>
<p>设<span class="math inline">\(A\)</span>是<span class="math inline">\(\mathbb{R}^*\)</span>的一个子集。如果存在<span class="math inline">\(\mathbb{R}\)</span>上的集列<span class="math inline">\(A_n\)</span>，使得在自由超滤子<span class="math inline">\(\mathscr{U}\)</span>的某个集合<span class="math inline">\(U\)</span>上<span class="math inline">\(x=\{x_n\}\in A\subseteq\mathbb{R}^*\)</span>，当且仅当<span class="math inline">\(x_n\in A_n\)</span>，那么称<span class="math inline">\(A\)</span>是<span class="math inline">\(\mathbb{R}^*\)</span>的一个内子集。否则称<span class="math inline">\(A\)</span>为<span class="math inline">\(\mathbb{R}^*\)</span>的一个外子集。可以证明<span class="math inline">\(\mathbb{R}^*\)</span>中的任意开区间，闭区间，半开半闭区间都是内子集。</p>
<p>超实数域的外集与实数集及其子集的性质差别较大，而内子集的性质则较为相近。以后我们的研究主要是超实数域的内子集。<span class="math inline">\(\mathbb{N}^*\)</span>、<span class="math inline">\(\mathbb{Q}^*\)</span>, <span class="math inline">\(\mathbb{Z}^*\)</span>，以及区间<span class="math inline">\([x,y]^*\)</span>、<span class="math inline">\((x,y)^*\)</span>都是<span class="math inline">\(\mathbb{R}^*\)</span>的标准内子集。</p>
<p>当<span class="math inline">\(A\)</span>是<span class="math inline">\(\mathbb{R}\)</span>的有限子集时，<span class="math inline">\(A\)</span>的扩充<span class="math inline">\(A^*\)</span>与<span class="math inline">\(A\)</span>有相同的势。但是当<span class="math inline">\(A\)</span>不是<span class="math inline">\(\mathbb{R}\)</span>的有限子集时，<span class="math inline">\(A\)</span>的扩充<span class="math inline">\(A^*\)</span>将比<span class="math inline">\(A\)</span>中的元素多很多。</p>
<p>在此基础上，自然原延伸是建立超实数域<span class="math inline">\(\mathbb{R}^*\)</span>类似于<span class="math inline">\(\mathbb{R}\)</span>的加法公理，乘法公理，序公理，完备性公理等理论。所以就不再用多余的叙述。</p>
<h2 id="超实数域总结">超实数域总结</h2>
<p>构造完<span class="math inline">\(\mathbb{R}^*\)</span>及其上的内集，非标准分析的基础就算完成了。因此说来，学习非标准分析的难度也不算很高。</p>
<p>不过上面的构造过程应当引起我们更深的思考，比如为什么这样的扩充是容许的，尤其是，为什么实数集的子集，可以进一步扩充成内集。我们知道，实数的某些性质是不完美的，但是实数的构造确实很完美，域结构，序结构，拓扑结构以及微分结构它都有。这启示我们，是否在构造实数时是否遗忘了一些基本的公理。对比超实数的构造，也许我们会发现，如果在集论上添加一些新的东西，实数的理论就会变得更简单。非标准分析的逻辑理论，或者说，尝试在集合论的层次上建立内子集与外子集的想法，或许就是尝试发现这些被忽视的构造吧。</p>
<p>这样一来，好像我们必然要建立更完备的集合论一样，好像内集合论公理是集合论必然的选择一样。</p>
<p>前面我们表达的意思是，超实数域的理论是很容易模仿经典实数理论建立起来的，而现在我们想更详细地谈一些东西。</p>
<p>极限，在超实数域中有特别简单的解释。函数<span class="math inline">\(f\)</span>是连续的，用直观的语言说，就是自变量<span class="math inline">\(x\)</span>与常数<span class="math inline">\(a\)</span>无限接近的时候，函数值<span class="math inline">\(f(x)\)</span>与<span class="math inline">\(f(a)\)</span>也无限接近。这一直观的语言在<span class="math inline">\(\varepsilon\)</span>-<span class="math inline">\(\delta\)</span>语言中并无直接对应。但是用超实数域的语言很容易说明。在<span class="math inline">\(\mathbb{R}^*\)</span>中，函数<span class="math inline">\(f\)</span>是连续的，意思是，当自变量<span class="math inline">\(x\thickapprox y\)</span>的时候，<span class="math inline">\(f(x)\thickapprox f(a)\)</span>。</p>
<p>我们知道，导数与积分都是定义在求极限的过程上的，于是两个概念不难定义。函数的可导，就是自变量无限接近的时候，差商有限具无限接近。差商的标准部分，就是函数<span class="math inline">\(f\)</span>在<span class="math inline">\(a\)</span>点在标准意义下的导数。函数的积分，就是分割、求和、取极限。自然地，不构成太大的困难。</p>
<p>非标准的微分可能需要做一些较多的工作，尤其可能是需要定义扩充后的线性函数。但应该也不会太困难吧。总而言之，非标准分析以一种优雅的方式实现了分析学的扩充。</p>
<p>非标准微积分的思想及其基本内容均由非标准分析的创始人Robinson于20世纪60年代提出。1966年出版的第一本非标准分析专著《非标准分析》中专门有一章叙述非标准微积分。1976年Keisler,H.J.还出版了可供大学生使用的非标准微积分教材《初等微积分》。该书在大学的试用获得了好评。此后出版的非标准分析中关于微积分，便只有少量论述了—因为这个领域已经表明它是足够成熟的。</p>
<h2 id="实数域与超实数域的公理化定义">实数域与超实数域的公理化定义</h2>
<p>可以仿照实数的公理化定义那样定义超实数域的公理。而且后者的定义就建立在前者的基础上。超实数域的具体公理用四条即可概括：</p>
<p><span>实数公理</span> 实数域<span class="math inline">\(\mathbb{R}\)</span>是一个完备的有序域，与之前所有的实数公理化定义相同；</p>
<p><span>扩张公理</span> 超实数域<span class="math inline">\(\mathbb{R}^*\)</span>是<span class="math inline">\(\mathbb{R}\)</span>的真有序域扩张。第一节叙述的方法是一种可行方案；</p>
<p><span>函数公理</span> 对于每个<span class="math inline">\(n\)</span>元实函<span class="math inline">\(f\)</span>，存在<span class="math inline">\(n\)</span>元超实函数<span class="math inline">\(f^*\)</span>是<span class="math inline">\(f\)</span>的自然 扩张，并且<span class="math inline">\(\mathbb{R}^*\)</span>的域运算是<span class="math inline">\(\mathbb{R}\)</span>的域运算的自然扩张；</p>
<p><span>可解公理</span> 如果两组公式有相同的实数解，则它们有相同的超实数解。 这一公理使平方根等概念可以推广到超实数域上。</p>
<p>在四条公理之外，还常常添加一条称为饱和公理的命题，以便超实数域有唯一的基数。</p>
<p>说明：有了这几条公理，感觉可以立即开始非标准分析观点下的一元分析。这种感觉真奇怪：在几十分钟之前还觉得非标准分析是天书一样难的理论，但是几十分钟之后，便觉得它在分析学当中是自然而然的东西了。甚至几十分钟之前，还觉得内集合论公理是不可接受的，几十分钟之后便觉得它是十分必要的。可能是因为迅速接受了非标准分析，所以觉得非标准分析的逻辑理论并不是人为刻意构造的逻辑系统。</p>
<p>用公理除了可以证明超实数的存在，还可以证明超实数域<span class="math inline">\(\mathbb{R}^*\)</span>的唯一性。这样超实数域的性质就非常良好了。</p>
<h2 id="非标准分析展望">非标准分析展望</h2>
<p>如果内集合论公理添加到集合论当中，那么集合中相关的扩张自然在所有的数学门类中应用，包括拓扑空间的理论。事实如此。相关扩张的确可以用在拓扑空间上，使一个一般的拓扑空间<span class="math inline">\(X\)</span>扩张成<span class="math inline">\(X^*\)</span>。也许测度空间等同样可以使用。</p>
<p>这样，非标准分析很容易在其它数学门类获得应用。也许它尤其能改变拓扑学叙述问题的方式。</p>
<p>比如说，超实向量可以写成<span class="math inline">\((a_1,\cdots,a_n)\)</span>，<span class="math inline">\(a_i\in \mathbb{R}^*\)</span>的形式。这说明非标准分析可以向线性空间中扩展。</p>
<p>非标准分析的思想应用在测度论中，对于集函数会是一个好的修正。因为集函数往往需要取值到<span class="math inline">\(+\infty\)</span>。</p>
<p>非标准拓扑学是一个研究得比较多的领域。找到相关的书籍应该是不难的。另外，在分析学中常使用度量空间。在度量空间中改写成非标准分析的形式，要比在一般拓扑空间中容易许多。因为可以用度量趋于零刻画度量空间中无限接近的点列。</p>
<p>在广义函数领域。像<span class="math inline">\(\delta\)</span>-函数这类函数，在应用数学中十分有用，但在标准分析中却不能把它表示为一个具体的函数。于是Schwarz.H.A等人建立了广义函数论，把每一个<span class="math inline">\(\delta\)</span>-函数定义为满足一定条件的一个线性泛函，从而严格定义了这类函数。然而在非标准分析中，<span class="math inline">\(\delta\)</span>-函数可以定义成一个通常的函数，从而避免了标准分析中甚至不能定义广义函数乘法的困难。这也许是广义函数研究的一条更好的路径。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/03/10/140310-dotNet/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/03/10/140310-dotNet/" itemprop="url">
                  .NET平台上的一些程序语言
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-03-10T00:00:00+08:00">
                2014-03-10
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:53:27+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014/03/10/140310-dotNet/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/03/10/140310-dotNet/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="asp.net使用说明">asp.net使用说明</h2>
<p>使用一个技术架构, 需要了解其原理, 并知道其实现的思路. 为了更清楚地知道这一点, 必需从.NET架构开始.</p>
<p>现在的互联网技术, 甚至是一般的连网平台的技术, 跨平台性都是一个重要的特性. 在跨平台的背景下我们讨论各种技术.</p>
<p>.NET的开发虽然比较早, 但是后来被ECMA规范化了, 标准是ECMA335.</p>
<p>关于.NET技术, 我们以Mono的实现为例进行介绍. Visual Studio 开发环境是相同的原理可以理解的.</p>
<p>mono计划从核心虚拟机引擎开始. 这个引擎用于编译C#等代码, 也就是高层的代码. 在一些平台, 比如x86, x86-64当中, 这个引擎具有实时性, 也就是现在可以编译成平台相关代码的形式. 在其它平台上, Mono用解释的方式运行.NET的相关代码.</p>
<p>mono的目标就是创建符合.NET标准的工具. 而.NET架构的核心, 就是C#编译器, 以及通用语言架构(Common Language Instructure, CLI). 因此C#才成为.NET开发的首选的语言. Mono计划中, C#编译器由GPL规范, 运行库由LGPL规范, 类库则由MIT许可证规范. 因此mono是开源的一个计划.　微软也提供了一个共享编码公共语言基础库,　但并不是开源的, 虽然可以跨平台使用.</p>
<p>公共语言基础CLI是ECMA335标准, CLR,即公共语言运行环境, 则是CLI的标准实现, Mono即是其实现者之一. 它可以执行已经编译出来的.NET应用程序. linux下面的mono命令大概就是用于执行编译出来的.NET应用程序的. 虽然.NET应用程序往往使用.exe与.dll等格式, 但是与传统的.exe格式还是有所区别的.</p>
<p>在能够编译本地运行的C#代码, 大概是所有的.NET平台的基础. 了解了C#的编译的原理, 就不难知道其它的语言也可以利用C#语言的这一套基础设施, 比如C#运行时的库, 就可以为C#, IronPython, VB.Net, C++/CLI等.NET平台上的语言使用. .NET平台用命名空间组织各个类库, 使得所有的程序库有相同的调用方法. 命名空间, 比如System.Web, Microsoft.abc等.</p>
<p>.NET framework是微软开发的一套.NET的框架, 主要的内容是大量的类库. 它是继Microsoft DNA之后微软的新开发平台. 实际上, .NET framework与mono, Sliverlight, 以及XNA都是差不多的道理.</p>
<p>.NET framework提供了类库之后, ASP.NET, ADO.NET Windows Forms都是基于这个平台的创建出来的技术. 其中ASP.NET其实是在.NET framework中提供的支持开发Web应用程序的类库, 封装在System.Web.dll文件中, 以System.Web作为命名空间, 它具有负责网页处理的功能. 它是ASP技术的后继, 但是各方面的发展潜力比ASP要大很多.</p>
<p>原来的ASP的特点是其代码封装在HTML标签当中, 在ASP.NET中, 添加了面向对象的支持而变得集成在相应类的Render机制中, 形成一个包装.</p>
<p>.NET技术在2.0之后变得成熟, 在3.5之后又添加了许许多多的功能.</p>
<p>ASP.NET MVC是又开发出来的一个类库, 在System.Web.Mvc.dll当中, 它添加了ASP.NET Routing 以支持动作流与URL重写等功能.</p>
<p><strong>开发网页应用程序</strong></p>
<p>开发网页应用程序的时间, 服务器端的架设仍与原来的机制类似. xsp4是在unix下面支持.NET动态网页技术的一个服务器, 但是配置Apache与nginx以支持.NET格式的动态网页也并不是困难的事情, 因为只需要过滤出相应的文件, 让mod-mono-server2接收并处理就可以了.</p>
<p>后端的数据库当然是由.NET程序来连接. 实际上流行的关系数据库软件面向.NET都是有接口的, 我们可以很容易地在其中写出接口文件.</p>
<p>比如MySQL数据库的, 只需拷贝Mysql.Data.dll文件到系统库目录中即可. 实际上, 这只是编译C#应用程序的时候添加的一个编译选项而已. 使用gacutil工具, 可以将系统库安装到标准目录当中.</p>
<p><strong>学习使用.NET开发应用的步骤</strong></p>
<p>鉴于.NET的技术架构, 首先了解一个C#程序的编译过程即可. 虽然编译出来的文件以.exe作为结尾, 但是与传统的.exe格式我们可以认为是没有关联的. 然后我们学会使用C#面向对象的方法, 调用它的各种类库, 特别是面向数据库的接口.</p>
<p>编译好本地运行的程序之后, 我们再一步一步地走向网页应用程序.</p>
<h2 id="csharp基本介绍">Csharp基本介绍</h2>
<p>C#与java有更多的相近, 然而与com是直接集成的, 并且是Windows网络框架的主角. 现在的大部分的微软的技术, 以C#为基础了.</p>
<p>C#与C/C++相比, 是对后者的继承, 并且去掉了宏, 以及多重继承的规则. C#综合了C++的效率与VB的简单可视化操作, 是.NET的首选的语言.</p>
<p>C#可以调用C/C++编写的本机上的原生的函数.</p>
<p>C#由Anders Hejlsberg主持编写, 于2000年6月发布. 新增了许多的功能与语法糖. Anders也是Dephi语言的开发者. C#很可能是一个全能型的语言, 从复杂的操作系统到嵌入式可能均适用.</p>
<p>类的声明与Java相似而不像C语言. 而且C#的结构体与类不支持继承. 但与Java相同的是一个结构体可以实现接口. 类可以定义成抽象的或者不可继承的. 被声明为abstract的类不能被实例化, 只能被用作一个基类. 而C#的关键字final就象Java的final一样, 具有此声明的类不能被用作另外一个类的基类.</p>
<p>与Java一样, 一个界面是一组方法集合的抽象定义, 当类或者结构体实现这个界面的时候, 它必须实现所有的方法, 而且单一的类可以实现几个接口.</p>
<p>C#也使用true和false作为布尔常量.</p>
<p>C#的内存管理由底层的.NET框架负责. 一个基本的C#类中包含数据成员, 属性, 构造器和方法, 属性可以是静态或者实例成员.</p>
<p>C#是一个强类型的语言, 它的数值类型中有些可以进行隐式转换, 但是其它的必须是显式的转换.</p>
<p>程序被编译成标准的二进制可执行文件, 但是C#的源程序并不是二进制可执行的形式, 而是一种中间语言, 类似于字节码. 如果一个程序保存成一个以cs为后缀的文件, 那么编译器也能将它编译成可执行程序. 虽然扩展名是.exe, 但是没有.NET的时候仍然是不能被执行的.</p>
<p>C#的编译结果不是标准的二进制形式, 而是由.NET的CLR执行的中间代码.</p>
<p>C#中也有预编译指令, 有|#define|等, 但是没有了|#include|.</p>
<p>C#中也有一些操作符重载, 而且数据类型有值类型和引用类型两种.引用类型特点是不自动创建新的分配单元.int, byte是特殊的值类型, 称为简单类型. 所有的值类型都继承自System.ValueType类型, 所有有关的引用和类型都继承自System.Object基类.</p>
<p>方法可以支持可变数目的参数.</p>
<p>注意, C#语言的效率仅是能够与Java相抗衡, 而不足以与C或者汇编相近.</p>
<p><strong>各版本的特性</strong></p>
<p>在2.0版本起, 支持Python那样的yield迭代器类型.</p>
<p>从3.0起, 则支持LINQ, 也就是语言集成查询, 可以在LINQ上下文中作为关键字.</p>
<p>从3.0起, 支持了匿名类型, 使用var关键字即可声明, 因此可以局部变量类型推断.</p>
<p>从3.0起, 还支持了lambda表达式.</p>
<p>从4.0起支持了动态对象, 使用dynamic关键字声明, 而且有具名参数与可选参数, 而且可以更方便地与.COM组件交互.</p>
<p>mono几乎百分之百地实现了C#, 所以是一个不错的编译器, 使用 mcs hello.cs 可以直接编译出.exe文件, 使用 mono hello.exe 则可以直接从虚拟机里面运行它.</p>
<p><strong>LINQ</strong></p>
<p>它是微软的一项技术, 目前可以支持VB.NET与C#.</p>
<h2 id="新闻报道">新闻报道</h2>
<p>根据2014年11月13日的新闻，微软表示将开源.NET，包括整个.NET的核心类别，ASP.NET5.0、.NET CLR、Just-In Time Complier、Garbage Collection以及Base Class Libraries等技术。这一开源让.NET正式推出，使得.NET平台在开源世界以后甚至会优于Java的平台。个人感觉这一新闻比较重要。而且ASP.NET 5.0最好能与Mono计划融合。</p>
<h2 id="csharp编程语言">C<span class="math inline">\(\sharp\)</span>编程语言</h2>
<p>C<span class="math inline">\(\sharp\)</span>是基于.net平台的，但是关键还在于它是ECMA规范。C<span class="math inline">\(\sharp\)</span>之类的项目是由Anders Hejlsberg主持开发的。这之后，作为.Net概念的发起人之一，安德斯·海尔斯伯格被任命为微软.Net的首席架构师，主持.Net的开发工作。</p>
<p>C<span class="math inline">\(\sharp\)</span>也是强类型的语言，而且声明变量采用|var|关键字，因此具有类型推断的能力。C<span class="math inline">\(\sharp\)</span>也是多范式的，支持函数式编程语言。</p>
<p>C<span class="math inline">\(\sharp\)</span>的类型系统称为Common Type System (CTS)。此类型系统中，所有的类型（包括整数等原语类型）都是System.Object的类的子类。这样一来，每一个类都有一个ToString()方法。</p>
<p>CTS把数据类型分成两个范畴。一个是引用类型，另一个是值类型。Instances of value types do not have referential identity nor referential comparison semantics - equality and inequality comparisons for value types compare the actual data values within the instances, unless the corresponding operators are overloaded. Value types are derived from System.ValueType, always have a default value, and can always be created and copied. Some other limitations on value types are that they cannot derive from each other (but can implement interfaces) and cannot have an explicit default (parameterless) constructor. Examples of value types are all primitive types, such as int (a signed 32-bit integer), float (a 32-bit IEEE floating-point number), char (a 16-bit Unicode code unit), and System.DateTime (identifies a specific point in time with nanosecond precision). Other examples are enum (enumerations) and struct (user defined structures).</p>
<p>C<span class="math inline">\(\sharp\)</span>的库使用ECMA的规范，The C# specification details a minimum set of types and class libraries that the compiler expects to have available. In practice, C# is most often used with some implementation of the Common Language Infrastructure (CLI), which is standardized as ECMA-335 Common Language Infrastructure (CLI).也就是在CLI的基础上执行的。</p>
<p>C#也是ISO/IEC 23270:2006规范。</p>
<p>上面是关于C#的类型系统的介绍：In Microsoft’s .NET Framework, the Common Type System (CTS) is a standard that specifies how type definitions and specific values of types are represented in computer memory. It is intended to allow programs written in different programming languages to easily share information. As used in programming languages, a type can be described as a definition of a set of values (for example, “all integers between 0 and 10”), and the allowable operations on those values (for example, addition and subtraction).</p>
<p>The specification for the CTS is contained in Ecma standard 335, “Common Language Infrastructure (CLI) Partitions I to VI.” The CLI and the CTS were created by Microsoft, and the Microsoft .NET framework is an implementation of the standard. 也就是说，CTS类型系统是ECMA的规范。</p>
<p>Value types directly contain their data, and instances of value types are either allocated on the stack or allocated inline in a structure. Value types can be built-in (implemented by the runtime), user-defined, or enumerations.</p>
<p>Reference types store a reference to the value’s memory address, and are allocated on the heap. Reference types can be self-describing types, pointer types, or interface types. The type of a reference type can be determined from values of self-describing types. Self-describing types are further split into arrays and class types. The class types are user-defined classes, boxed value types, and delegates.</p>
<p>Boxing:Converting value types to reference types is also known as boxing. As can be seen in the example below, it is not necessary to tell the compiler an Int32 is boxed to an object, because it takes care of this itself.</p>
<p>Unboxing:The following example intends to show how to unbox a reference type back to a value type. First an Int32 is boxed to an object, and then it is unboxed again. Note that unboxing requires explicit cast.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/01/01/140101-Encyrption/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/01/01/140101-Encyrption/" itemprop="url">
                  密码学原理与开源工具(日期未定)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-01-01T00:00:00+08:00">
                2014-01-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:11+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014/01/01/140101-Encyrption/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/01/01/140101-Encyrption/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="加密及密码体制原理介绍">加密及密码体制原理介绍</h2>
<p>在进行相关的渗透的时候, 可能需要使用SSL. 即使不是从事渗透, 但是为了安全起见, 我们还是使用OpenSSL工具加强数据安全性. 无论如何, 这是密码学的一个应用, 它可以起到十分强大的作用. 事实上是所有的文件加密的重要的, 几乎是唯一现代化的方法.</p>
<p>密码学的一些常识我们必须了解. 现体密码体制中, 密码算法都是公开的, 保密指的是密钥的保密, 而不是算法的保密. 因为研制一个算法是非常麻烦的, 且作为学术上的东西, 它必须还要为人广泛地知道. 这也许体现了人类活动的一个基本准则, 那就是学术开放重要于人类活动. 也就是说, 原理是人类共有的, 应用的不同, 只是人们理解上的差异. 核心的知识是人类共知的, 而那些不为了所知的, 只是用于短期需求, 且没有长久的价值.</p>
<p>密码体制中, 大概有这样几种类型, 加密, 哈希与签名. 它们各自有一套原理.</p>
<p>其中加密又分为对称加密与不对称加密. 不管它们是如何实现的, 我们都可以用通用的公式来说明. 假设加密方有加密函数 <span class="math inline">\(E\)</span> , 解密方有函数<span class="math inline">\(D\)</span> , 原消息 <span class="math inline">\(M\)</span> ,而所使用的密钥是 <span class="math inline">\(K\)</span> , 那么加密解密过程分别是:</p>
<ul>
<li>加密过程<span class="math display">\[E(M,K) = C\]</span></li>
<li>解密过程<span class="math display">\[D(C,K) = M\]</span></li>
</ul>
<p>在加密解密函数相互配套的情况下, 双方均需知道 <span class="math inline">\(K\)</span> 的值. 在发送的时候, 加密方只在不安全信道上传输密文 <span class="math inline">\(C\)</span> , 解密方只需要使用 <span class="math inline">\(K\)</span> 解出密文 <span class="math inline">\(C\)</span> 为 <span class="math inline">\(M\)</span> .</p>
<p>我们可以分析, 实行加密的过程是算法规定的, 因此任何人都可以. 但是一个攻击者将因为无法知道和解密方相同的 <span class="math inline">\(K\)</span> 而不能伪造与解密方通信—如果它对 <span class="math inline">\(K\)</span> 一无所知而又试图发送密码, 那么解密出来的, 往往是随机的文字, 以致于攻击者自己也不知道解密方将会看到什么消息, 因此这种攻击就失去意义.</p>
<p>对称加密的主要问题在于如何达成一致的密钥. 由于 <span class="math inline">\(K\)</span> 需要保密, 因此得事先由发送方与接收方秘密约定, 或使用额外的安全信道. 尽管如何, 对称加密因为速度上的原因, 以及能够配合其它体制使用, 因此也颇有应用. 主要的对称算法有DES, AES, RC4等.</p>
<p>非对称加密一定意义下等同于公钥体制. 将体制下, 密钥分成公钥与私钥两个部分. 它们是成对出现的, 且公钥可以公开发布, 只是人们很难从公钥 <span class="math inline">\(K_1\)</span> 推出私钥 <span class="math inline">\(K_2\)</span> .加密与解密过程分别为:</p>
<ul>
<li>加密过程<span class="math inline">\(E(M, K_1) = C\)</span></li>
<li>解密过程<span class="math inline">\(D(C, K_2) = M\)</span></li>
</ul>
<p>符合这一原理的方法有RSA(基于因子分解), ElGamal(基于离散对数)等.</p>
<p>另外, 离散对数问题可以用于密码协商, 进一步保证前向安全. 基于它的著名协议是Diffie-Hellman密钥协商协议. 协商基本过程是, <span class="math inline">\(A\)</span> , <span class="math inline">\(B\)</span> 双方各自选择仅自己知道的数字(即使对方也不知道), 根据离散对数分别计算明文. 各自接收到对方的明文后, 再计算一次可以得到相同的数字. 该数字即为协商的结果. 该方法的特点是双方各自不知道对方的密码, 但是却可以维持一个仅能双方知道的加密信道. D-H协议的主要问题是协议中没有关于通信双方身份的验证, 因此可能被一个中间人物在协商时截取, 形成一个代理.</p>
<p>HASH技术原本是为了方便和提高速度, 而对数据完整性校验, 但与密码体制结合起来, 也可以用于数字签名. 主要的HASH函数有MD5, SHA1等.</p>
<p>配合HASH进行数字签名的原理是, 双方本来就已经协商好了密码体制. 这个时候, 规定消息格式由消息体和HASH两个部分规范地组成. 根据具体情况, 如果消息可以明文传递, 那么就发送消息明文和加密后的消息HASH, 对方自动计算消息HASH, 并与解开发送方加密的HASH对比就可以了; 如果是密文加密, 亦是类似.</p>
<p>公钥算法的特点是太慢, 因此实际使用公钥的时候, 常用公钥算法传输会话密钥, 再用对称算法加密传递批量数据.</p>
<p>公钥的发布是公钥体制的核心. 一般设立权威中心(CA), 由CA以数字签名的方式签发公钥, 即证书. 证书中包含有公钥, 持有人信息, 用途说明, 有效期, 签发人的数字签名等. 有了对方的证书后, 可以让对方签名来看看, 如果对方发过来的消息中, 能够签出这个公钥验证的名, 则可确认对方应当有对应私钥; 否则对方就是假冒的.</p>
<p>注意, 持有证书的人虽然能够验证签名者的真伪, 但是却不能通过消息推导出签名者的私钥—否则证书体制将会面临重大缺陷.</p>
<h2 id="openssl简介与基本使用">OpenSSL简介与基本使用</h2>
<p>OpenSSL是使用非常广泛的SSL开源实现. 由于其中实现了为SSL所用的各种加密算法,因此OpenSSL也广泛被视为开源的加密函数库—更保况它的确提供了接口函数.</p>
<p>OpenSSL学习的基础环境是openssl命令行. 输入 <code>openssl</code> 命令, 即可进入. 在其中可以执行OpenSSL所提供的各种功能. 比如, 生成随机数, 产生密钥对.</p>
<p>其中较为简单的HASH验证, 产生随从数就不说了. 只是最重要的密钥与加密.</p>
<p>要使用OpenSSL, 我们要知道它有哪几个方面的基本用途. 第一个是非对称加密, 第二个是对称加密, 第三个则是信息摘要算法. 其实信息摘要算法是很简单的, 也就是我们所说的MD5等HASH算法.</p>
<h3 id="对称加密算法">对称加密算法</h3>
<p>对称加密算法的基本流程是, 在一定的对称加密算法的支持下, 输入密码, 指定输入文件, 然后得到一个输出文件. 将输出发送到另外一台机器上, 在另外一台机器上应用相同配置即可解密出文件.</p>
<p>OpenSSL提供的主要的工具是 <code>enc</code> 命令. enc -e用于加密, enc -d用于解密. 执行命令</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl enc -des -e -a &lt; source.txt &gt; source.txt.des</div></pre></td></tr></table></figure>
<p>进入对话框, 输入密码之后就可以生成加密后的文件了, 再使用</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl enc -des -d -a &lt; source.txt.des &gt; source.txt</div></pre></td></tr></table></figure>
<p>就可以恢复想要的 <code>source.txt</code> 文件.</p>
<p>对称加密之间的不同, 主要在于所选用的对称加密算法, 比如 <code>-des</code> . 使用对称加密的时候, 其实也应当注意, 一个长度较少的密码, 是容易被攻破的, 因此不妨选用更长位数的密码. 这样, OpenSSL可以使用 <code>-k</code> , <code>-kfile</code> 选项从命令行选项, 或者从文件中得到密码. 不用在线输入.</p>
<h3 id="非对称加密算法">非对称加密算法</h3>
<p>非对称加密算法的应用范围更广. 而且也有助于产生更长的密码. 非对称加密的原理已经介绍过了. 因此在本地产生钥匙对是最基础的. 对应OpenSSL命令为:</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl genrsa 1024 &gt; hawk.key</div></pre></td></tr></table></figure>
<p>产生ASCII编码的RSA钥匙对. 可以用</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl rsa -noout -text &lt; hawk.pem</div></pre></td></tr></table></figure>
<p>查看包含在 <code>hawk.pem</code> 当中的公钥与私钥的值.</p>
<p>为了更安全起见, <code>genrsa</code> 还支持将生成的钥匙对使用对称加密算法加密, 比如加上 <code>-des</code> 选项后, 以后要再想用这个钥匙对, 必须输入一个密码才行.</p>
<p>不管怎么说, 第一步产生钥匙对的工作总算是完成了. 此时用</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl rsa -pubout &lt;hawk.key &gt;hawk_pub.pem</div></pre></td></tr></table></figure>
<p>可以仅导出RSA中的公钥的那个部分, 直接引用 <code>hawk_pub.pem</code> 以发布公钥. 对于DSA, 需要在生成密码的时候提供一个参数. 因此过程是</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">openssl dsaparam 1024 &gt; dsaparam.pem</div><div class="line">openssl gendsa -des3 &lt;deaparam.pem &gt;private.pem ## 生成密钥</div><div class="line">openssl dsa -pubout &lt;private.pem &gt;public.pem  ## 导出公钥</div></pre></td></tr></table></figure>
<p>这要比RSA方式复杂一步.</p>
<p>产生了钥匙对, 便可以分别使用私钥与公钥对文件签名与验证了. 比如</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">## signature</div><div class="line">openssl dgst -sha1 -sign private.pem &lt;file.txt &gt;file.txt.sgn </div><div class="line"></div><div class="line">## verify</div><div class="line">openssl dgst -sha1 -sign public.pem &lt;file.txt.sgn &gt;file.txt</div></pre></td></tr></table></figure>
<p>不过我们不一定是对整个文件加密, 而是更有可能是对文件的摘要加密.</p>
<p>注意, 这是对文件签名与验证. 前提是接收方有正确的公钥. 如果一开始得到的是窃取者的公钥, 那么窃取者就能伪造发送方与接收方通信.</p>
<h3 id="信息摘要算法">信息摘要算法</h3>
<p>信息摘要算法对于验证文件有时是非常有效的. 对于较弱的验证, 比如看从网上下载的一个文件与服务器一样与否, 可以用|openssl sha1 file.txt|得到SHA1值, 然后与服务品的上对比.</p>
<p>信息摘要算法的另一个应用是保存用户的密码, 前提是保存用户密码的地方, 其它人不能任意修改相应的摘要. 在用摘要算法保存密码的时候, 还可以加上一些噪声, 防止被用常用词摘要表的方法攻破.</p>
<p>密码管理是 <code>passwd</code> 命令, 它可以以UNIX标准的方式加上一个密码, 以及加上一些噪声. 在服务器存储密码的时候特别有用, 比如</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl passwd -1 -salt</div></pre></td></tr></table></figure>
<p>分别以password为输入文件, 和以使用摘要算法后的密码为输出文件.</p>
<p>OpenSSL还有其它的许多功能. 有用到的时候可以参考其手册.</p>
<h2 id="gnupg工具">GnuPG工具</h2>
<p>GnuPG也算是密码学工具. 相对于SSL, 大概长处在于封装了一整套的方案. 面对主流的应用, gnugp直接提供了相应的命令, 相对于密码学工具, 更侧重应用.</p>
<p>GnuPG可以完成几乎全部现行密码体制. 对称加密解密, 非对称加密解密, 数字签名与认证等. 由于已经有了OpenSSL的背景, 我们讲GnuPG的应用.</p>
<p>GnuPG基本上可以看成是管理本地的公钥私钥的工具. 不仅可以管理自己创建的钥匙对, 还可以管理从网上下载的公钥私钥. 甚至可以发展成一个集团认证的工具, 因为对于一个签名的文档, 使用者还可以自己再加上一个签名, 从而让用户知道已经有很多人对这一个公钥认证过, 因此大大增强了信心.</p>
<p>GnuPG的基础命令有|gpg –gen-key|与|gpg -k/-K|, 分别用于生成钥匙与查看本机的所有的钥匙. GnuPG管理它们的时候, 对钥匙文件使用 <code>Key_ID</code> 标识. 也就是说, 使用哪个文件, 通过 <code>Key_ID</code> 来指定.</p>
<h3 id="导出公钥">导出公钥</h3>
<p>示例命令:</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">gpg --export --armor Key_ID &gt; Key_ID_pub.pem</div><div class="line">gpg --export Key_ID &gt; Key_ID.gpg</div></pre></td></tr></table></figure>
<p>分别表示导出ASCII格式与二进制格式的公钥. 同时, 导入另人的公钥, 使用</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gpg --import Key_ID_pub.pem</div></pre></td></tr></table></figure>
<p>公钥总是要发布出来才有意义, GnuPG提供的命令可以直接将公钥发布到网上, 以及从网上的服务器上下载公钥. 这里有一个可用的公钥服务器 <code>keys.gnupg.net</code> .</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gpg --keyserver keys.gnupg.net --send Key_ID</div></pre></td></tr></table></figure>
<p>从服务器上下载相应的公钥, 则可以调用</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gpg --keyserver keys.gnupg.net --recv-keys Key_ID</div></pre></td></tr></table></figure>
<p>其实使用默认服务品的话, 可以不用指定 <code>keyserver</code> 的, 默认服务器可以在.gunpg/gpg.conf文件中配置.</p>
<h3 id="钥匙管理">钥匙管理</h3>
<p>按照GnuPG的基本的意思, 应该是把公钥导出, 在本地有一个私钥就行了. 但是有时候, 因为重装系统等原因, 可能需要导出以迁移私钥. 方法是:</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gpg --export-secret-keys --armor Key_ID &gt; Key_ID.pem</div></pre></td></tr></table></figure>
<p>直于在另一台机器上导入私钥, 则是同样的道理.</p>
<p>从上面的流程, 我们可以看出, 一个完整的 <code>Key_ID</code> 文件中, 不仅有公钥与私钥, 还有用户相关的信息, 以及加密私钥的密码, 只有提供了密码, 才能从 <code>Key_ID</code> 中提取重要数据. 因此一个 <code>Key_ID</code> 可以用于多种用途, 非对称加密, 签名均可.</p>
<h3 id="吊销证书">吊销证书</h3>
<p>该功能可以看成是 <code>Key_ID</code> 机制的扩展. 当一个符合要求的证书因为某种原因, 状态发生变化的时候, 可以根据吊销证书被取消. 当然, 创建吊销证书的, 必须是发布机构, 也就是知道私钥与密码的那个人. 产生相应 <code>Key_ID</code> 的吊销证书后, 在相应的时机, 导入此证书, 便可以使相应 <code>Key_ID</code> 的证书失效.</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gpg --gen-revoke Key_ID &gt; Key_ID.rvk.pem</div></pre></td></tr></table></figure>
<p>导入吊销证书的方法, 与导入一个公钥使用相同的命令.</p>
<h3 id="对称加密">对称加密</h3>
<p>默认GnuPG使用的是非对称加密的方法. 所以要想使用对称加密, 虽然原则上与OpenSSL相同, 但是参数形式要稍微长一些, 或者难记一些.</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">## 对称加密并生成filename.asc文档. 不带armor, 生成gpg二进制格式.</div><div class="line">gpg --armor -c filename</div><div class="line">## -c 等同于命令 --symmetric</div><div class="line"></div><div class="line">## 对称解密时输入相应的密码即可</div><div class="line">gpg --armor -d filename.asc</div><div class="line">## -d 等同于 --decrypt 选项</div></pre></td></tr></table></figure>
<h3 id="非对称加密">非对称加密</h3>
<p>既然在 <code>.pem</code> 文件中, 所有的要素都准备了, 那么非对称加密也就不困难了. 使用</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gpg --armor -r Key_ID -e filename</div></pre></td></tr></table></figure>
<p>解密的时候, 与对称加密的时候相同. 只不过解密的时候, 需要存有私钥的<code>Key_ID</code>文件.</p>
<h3 id="数字签名">数字签名</h3>
<p>对文件进行数字签名也是很简单的, 示例如下:</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">## 对文件签名, 并且将文件签到输入文件中</div><div class="line">gpg --sign filename -o filename.gpg</div><div class="line"></div><div class="line">## 生成文件与HASH分开的签名</div><div class="line">gpg --detach-sig filename -o filename.sig</div></pre></td></tr></table></figure>
<p>也可以通过类似 <code>--armor</code> 的选项, 导出ASCII格式的签名的文件, 这样更易于在互联网上传播( <code>--clearsign</code> 选项).</p>
<p>至于验证签名, 则可以使用 <code>--verify</code> 选项.</p>
<p>GnuPG还有其它很多用法, 比如在一个公钥上签上自己的名. 这里就不多讲了.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Istyasna" />
          <p class="site-author-name" itemprop="name">Istyasna</p>
          <p class="site-description motion-element" itemprop="description">GO FORTH now and create masterpieces of the publishing art!</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">57</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">14</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">233</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/irhawks" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://coding.aliyun.com/u/irhawks" target="_blank" title="Aliyun">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Aliyun
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="./" title="Title" target="_blank">Title</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.hainu.edu.cn" title="Hainan University" target="_blank">Hainan University</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Istyasna</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"irhawks"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  


</body>
</html>
