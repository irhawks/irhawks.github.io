<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans,en,default">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Lobster Two:300,300italic,400,400italic,700,700italic|PT Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="80x24" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="GO FORTH now and create masterpieces of the publishing art!">
<meta property="og:type" content="website">
<meta property="og:title" content="80x24">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="80x24">
<meta property="og:description" content="GO FORTH now and create masterpieces of the publishing art!">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="80x24">
<meta name="twitter:description" content="GO FORTH now and create masterpieces of the publishing art!">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 'undefined',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title> 80x24 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  



  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?763bee904aa6d81fdf017659d162188f";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>








  
  
    
  

  <div class="container one-collumn sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">80x24</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle">Keep Stupid, Keep Hungry</p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/atom.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2014/01/01/encryption/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2014/01/01/encryption/" itemprop="url">
                  密码学原理与开源工具(日期未定)
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2014-01-01T00:00:00+08:00">
                2014-01-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T19:21:03+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机安全/" itemprop="url" rel="index">
                    <span itemprop="name">计算机安全</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2014/01/01/encryption/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2014/01/01/encryption/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="加密及密码体制原理介绍">加密及密码体制原理介绍</h2>
<p>在进行相关的渗透的时候, 可能需要使用SSL. 即使不是从事渗透, 但是为了安全起见, 我们还是使用OpenSSL工具加强数据安全性. 无论如何, 这是密码学的一个应用, 它可以起到十分强大的作用. 事实上是所有的文件加密的重要的, 几乎是唯一现代化的方法.</p>
<p>密码学的一些常识我们必须了解. 现体密码体制中, 密码算法都是公开的, 保密指的是密钥的保密, 而不是算法的保密. 因为研制一个算法是非常麻烦的, 且作为学术上的东西, 它必须还要为人广泛地知道. 这也许体现了人类活动的一个基本准则, 那就是学术开放重要于人类活动. 也就是说, 原理是人类共有的, 应用的不同, 只是人们理解上的差异. 核心的知识是人类共知的, 而那些不为了所知的, 只是用于短期需求, 且没有长久的价值.</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2014/01/01/encryption/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/10/01/bootstrap-syslinux/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/10/01/bootstrap-syslinux/" itemprop="url">
                  从磁盘启动的过程与SYSLINUX
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-10-01T00:00:00+08:00">
                2013-10-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T19:25:37+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2013/10/01/bootstrap-syslinux/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2013/10/01/bootstrap-syslinux/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="磁盘启动原理">磁盘启动原理</h2>
<p>PC在启动的时候是从执行ROM当中的代码开始的。这些代码常根据机器的不同而分布在不同的位置。PC上这种初始化代码称为BIOS(基本输入输出系统)。在PC里有几种不同的BIOS固件。如主板BIOS,显示卡BIOS,以及网卡BIOS.</p>
<p>BIOS通常让用户选择从哪一个设备引导。一旦确定引导设备，BIOS就加载在该设备开头的512字节的信息。这个512字节的段称为MBR.MBR中包含一个程序，它可以执行中决定从哪个位置（哪个分区）加载boot loader(也就是引导程序)。</p>
<p>实际上在一个磁盘设备上从0x0000到0x01bd这446字节为MBR代码，从0x01be到0x1fd这64字节包含有4组分区表信息DPT.在0x01be处的值为引导标志，值为80代表活动分区。而MBR中的0x01fe到0x01ff为结束标志，内容总是0x55aa.</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2013/10/01/bootstrap-syslinux/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/08/25/人工智能语言/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/08/25/人工智能语言/" itemprop="url">
                  人工智能语言介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-08-25T00:00:00+08:00">
                2013-08-25
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:55:53+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/人工智能/" itemprop="url" rel="index">
                    <span itemprop="name">人工智能</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/人工智能/Prolog/" itemprop="url" rel="index">
                    <span itemprop="name">Prolog</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2013/08/25/人工智能语言/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2013/08/25/人工智能语言/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本章单独作为一章，而且并不是用作附录。因为人工智能与程序语言是一体的。每一种语言实际上都可以看成是智能的一部分。而我们的目的是设计出更智能的语言或者程序。为此当然需要了解可计算性理论以及计算复杂性理论。</p>
<p>发现一个优点，就是如果在学习人工智能的时候学习几门语言，要比自己在没有任何指导的情况下看语言入门的书要容易得多。如果直接学习Prolog,我想我会找不到里面的重点。但是在知识表示中顺便介绍了Prolog,我就觉得用它来写程序很自然。</p>
<p>本书第十三章先是一般地介绍了语言的分类，然后介绍了LISP, Scheme, Prolog, POP-11, 以及略微谈及了脚本语言。也许结合七周七语言，让自己对于语言的理解的高度再上一层吧。至少我觉得本章第一节讲语言分类的时候，像是在高屋建翎。由于人工智能本身就说自己写的程序很可能只能在特定情况下被使用，所以人工智能的算法库也不多。这反映了人工智能问题的复杂性，需要使用不同的语言来解决。于是在人工智能领域，我们也更倾向于使用设计得更好的语言，如是不能描述我们的问题，与其使用不合适的语言编程，还不如写一种合乎于我们要求的语言。</p>
<blockquote>
<p>这里所介绍的AI语言，现在看来其实是一些通用的AI语言，也就是使用普遍的编程语言来心量实现AI一样的任务。这种方法对于理解一般编程语言是怎样实现智能的也有一定的好处。但是个人并不认为因此这些语言就是智能的了。所以我们在这里我可以看成是以AI应用为背景的对于编程语言的一个综合介绍吧。</p>
</blockquote>
<h2 id="prologux7a0bux5e8fux8bbeux8ba1">Prolog程序设计</h2>
<p>前面我们已经讲过了Prolog在知识表示与推理中的基本运用。现在我们考虑的是作为一门编程语言的Prolog.</p>
<p>一个事实是，Prolog解释程序很容易用Prolog语言本身实现(有点像GCC编译器自己编译出来自己，而LISP语言可以轻易地写出LISP编译器一样)。Prolog语言很适合于开发基于知识的系统，以及计算机代数系统。它的问题求解的能力依然是解决知识领域问题的一种重要语言。</p>
<p>越来越发现，编程的时候我们只有一个工具而不去借鉴别人的东西。这是不符合学习的一般规律的。应该减少盲目的摸索，把编程看成是知识传承与改进的领域。这样才会把自己的能力提得很高，而且掌握那些不会过时的部分。Prolog语言用于CAS的实例现在我们根本没有看到，而我现在对此有兴趣，那么该怎么办呢? 当然应先参考别人怎样尝试解决问题的，利用了语言的哪些机制，而不是觉得自己现在就可以做出来成果。</p>
<p>前面我们讲Prolog用于知识表示的时候，并没有讲到它的数据表示。实际上，以大写字母开头的单词代表变元外，还有数值类型与原子类型(相当于常量)，一个以单引号括起来的字符串也代表一个原子。而需要注意的是，现在Prolog的数值是整数类型。</p>
<p>除了基本元素还有列表与元组，可以嵌套，而且列表上有合一规则。</p>
<p>除了这些结构外，Prolog也提供了一组常用的外理数据的谓词。比如<code>append()</code>，<code>length()</code>，<code>member()</code>，列表操纵等。在Prolog语言中，</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">length([a,b,c], <span class="symbol">Length</span>)</div></pre></td></tr></table></figure>
<p>用于把Length的值赋成列表<span class="math inline">\([a,b,c]\)</span>的长度，而</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">length([a,b,c],<span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>用于判断列表的长度是否为3.也就是说，在Prolog中，函数值的接收与对值的判断是同样的一个形式。</p>
<p>事实与规则在Prolog知识库中出现。而在推理的过程中实现求值。这些功能在前面我们已经用过了。</p>
<p>最后，在推理的过程中，可以使用trace.跟踪计算的过程。</p>
<p>在Prolog中，把一个表达式赋给一个变量，可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">X is 3+3 **2.</div></pre></td></tr></table></figure>
<p>这样的形式。注意使用的是is运算符。</p>
<p>Prolog中，可以使用小数，这个时候，小数视为常项。</p>
<h2 id="ux4ebaux5de5ux667aux80fdux8bedux8a00ux6982ux8ff0">人工智能语言概述</h2>
<p>首先，人工智能算法可以由众多语言实现，但是有些语言更适合于特定的问题。对于神经网络或者遗传算法之类的数字人工智能问题，用C这样的语言是很高效的。对于依赖逻辑谓词的关系问题，Prolog较为理想。从历史上看，LISP是人工智能的基本语言。</p>
<p>程序设计语言的本质都是使程序员利用一台计算机解决问题，但是如何解决问题则可以千变万化。每种编程语言提供相同的功能，但是以不同的方式实现。(我们一般只考虑图灵完备的语言。)</p>
<p>主要的语言类型，或者说它们的特性，有函数式，命令式，面向对象，逻辑，并发这五个衡量的方面。之所以是这五个方面，因为它们大致决定了一门编程语言的基本面貌。用这几个标准可以更直观有效地对语言进行分类。在基本分类的基础上，我们再考虑求值方式，类型系统，性能与效率等因素。</p>
<p>人工智能早期，系统开发的重点是LISP这样的符号语言，以及Prolog这样的逻辑语言。但是实际上许多语言都能用于人工智能的开发。但是有几种范式对于语言的选择比较有影响。</p>
<p>那些LISP过时论的持见者，如果不能看到它现在的应用规模，它用于解决怎样的问题，那么它就没有资格起到决定作用。如果它没有掌握到语言发展的规律，我们就说那个人的话没有话语权。</p>
<h3 id="ux51fdux6570ux5f0fux7a0bux5e8fux8bbeux8ba1">函数式程序设计</h3>
<p>第一种范式是函数式程序设计。这类语言深植于<span class="math inline">\(\lambda\)</span>-演算的理论框架，具有诸如高阶函数，一等函数，递归，副作用少，连续，以及闭包等诸多特征。</p>
<p>与命令式语言相比，函数式程序设计依赖的是数据上函数的实施，而不是依赖于改变存储器和状态的命令的顺序执行。</p>
<p>高阶函数是函数式程序设计的基本特性，它意味着可以将一个函数作为输入，也可以返回一个函数作为输出。这个概念在数学上较为常见，比如求导函数。比如在Python中，可以使用map把一个函数作为参数作用于列表中的每个元素，甚至C语言也支持传递函数的入口指针。</p>
<p>但是C与Python其中的区别是，在函数式程序设计中，函数是作为一等对象或者一等函数。在一等函数里，我们可以把函数简单地当成数据。一等函数是有值的，就像其它任何数据结构一样。一等函数的一个重要表现是动态函数，也就是在运行期建立。C语言并不支持动态函数。</p>
<p>现代语言都力求支持多编程范式，因此对它们的分类也就越来越困难了。</p>
<p>下面是Ruby中一等函数的例子:</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">mul_by</span><span class="params">(factor)</span></span></div><div class="line"><span class="keyword">return</span> Proc.new(<span class="params">|n|</span> n*factor)</div><div class="line"><span class="keyword">end</span></div><div class="line">mul_by_2 = mul_by(<span class="number">2</span>)</div><div class="line">mul_by_2.call(<span class="number">8</span>)</div></pre></td></tr></table></figure>
<p>其中<code>mul_by()</code>函数接受<code>factor</code>参数，返回相应的乘积函数，然后用<code>mul_by_2</code>作为一个函数对象，使用它的call方法计算函数值。</p>
<p>函数式语言中，通常支持函数调用自身。它是函数式语言中典型的实现循环的方法。比如在LISP中的使用递归计算阶乘:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">defun</span> fact (<span class="name">n</span>) </div><div class="line">(<span class="name">if</span> (<span class="name">=</span> n <span class="number">1</span>) <span class="number">1</span> (<span class="name">*</span> n factor(<span class="name">n-1</span>))))</div></pre></td></tr></table></figure>
<p>LISP的特殊性不只是它采用函数式设计，而也是因为它的运算表达式都是前缀形式的表达式。以前以为理解LISP代码与写LISP代码都很难，但是现在觉得括号也没有引起想象中的太大的混淆。</p>
<p>闭包是函数式程序设计中与一等函数相关的一个很有用的特性。被传递到不同的词汇上下文使用的动态函数(有时是匿名的)被称为闭包。在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。</p>
<p>闭包的特殊性在于它引入了已有函数中的变量，当我们返回一个内部的函数的时候，虽然外函数结束，但是我们不能释放掉此函数里面的参数(因为它被闭包函数使用)，所以需要编程语言进行额外的处理才能支持闭包。</p>
<h3 id="ux547dux5f0fux5f0fux7a0bux5e8fux8bbeux8ba1">命式式程序设计</h3>
<p>命令式程序设计把计算过程看成是改变程序状态的语句的顺序执行。最早的命令式语言是1954年开发的FORTRAN语言。FORTRAN语言位于一棵庞大的语言树的根部，BASIC,Pascal,Modula,C,Ada以及Python与Ruby这样的语言都可以看成是从它而来的。</p>
<p>汇编语言与机器语言也可以看成是命令式语言。而机器语言指令不仅改变存储器的状态，也改变机器的状态。</p>
<p>命令式语言通过循环提供迭代的能力。有时候它们也提供递归，但是它们的递归显然没有函数式语言高效。</p>
<h3 id="ux9762ux5411ux5bf9ux8c61ux7a0bux5e8fux8bbeux8ba1">面向对象程序设计</h3>
<p>面向对象的语言的基本特征是类，对象，继承，封装与多态。类是定义了行为和属性的抽象实体，对象是类的实例化。继承是一个类继承其它类的特征的能力。这样，我们就能够创建定义默认行为的基类，然后建立修正这些行为的子类。封装指的是类可以陷藏它内部操作的细节。多态指的是基类的行为方法被父类的行为方法取代。</p>
<h3 id="ux903bux8f91ux7a0bux5e8fux8bbeux8ba1">逻辑程序设计</h3>
<p>逻辑程序设计于1958年由John McCarthy首次提出(!)。它基于规则的模式导向进行，以达到某个目标。虽然逻辑程序设计基于数理逻辑，但是它在数理逻辑能力上有很多的限制，特别地，逻辑程序设计可以实现熟知的Horn子句。Prolog,G&quot;odel,Oz,Mercury都是支持逻辑程序设计的语言。</p>
<h3 id="人工智能语言选择参考">人工智能语言选择参考</h3>
<p>在人工智能整个领域，单种语言通常不能提供必须的特性。在专家系统中，POP-11,Prolog与LISP这样的语言较常见，动态应用程序上LISP,Scheme,Dylan较常见，而计算机视觉几乎总是C/CXX.自然语言系统可以选用Prolog或者Oz,而演化系统常用C与DSL.</p>
<h2 id="lispux8bedux8a00">LISP语言</h2>
<p>LISP是与FORTRAN,COBOL一样古老的早期语言之一。同时它也是最独特的语言之一。其数据与LISP程序都是以表的形式表示。程序与数据以相同的方式表示。</p>
<p>John McCarthy(现供职于Stanford)于1958年在MIT提出了LISP语言的基本思想。1960年公开发表了设计LISP语言的文章，不久之后语言被实现。McCarthy的符号系统使用一种方括号内的M表达式，但是这种符号系统在早期实现时即被S表达式取代。虽然LISP本身被认为是一种过时的语言，但是它仍然拥有许多重要的思想理念，因而值得学习研究。</p>
<p>在LISP中，一切事物都是表。表可以是空表，包含空表的表，包含单个原子的表，包含多个原子的表，包含表的表，以及作为结构的表(混合表)。</p>
<p>LISP表达式采取表的方式表示，是采用前缀表示法。每一个LISP表达式都会返回一个值，而且事实上，一个LISP函数可以返回任意个值。</p>
<p>LISP中还有提供判断的谓词，比如atom用于返回它的参数是否是一个原子，返回true或者false.</p>
<p>LISP的赋值也有多种方法，常见的是采用setq方法。用于将一个值赋给一个符号，或者将一系列的值赋值给一系列的符号。比如:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(<span class="name">setq</span> score-1 <span class="number">95</span> score-2 <span class="number">100</span>)</div><div class="line">(<span class="name">setq</span> thedate '(<span class="string">"April"</span> <span class="number">13</span> <span class="number">1968</span>))</div></pre></td></tr></table></figure>
<p>其中在表开头前使用单引号，表示不要对此表进行求值后再赋值。LISP语言的另一种赋值方法是let.</p>
<p>LISP的表处理是其核心的机制。前面已经说过用setq建立一个表(是建立一个表的同时对变量赋值)。</p>
<p>函数<code>cons</code>用于通过两个参数构千定个表，也就是把第一个参数作为第二个参数(表)的第一个元素。比如<code>(cons 1 ())</code>返回<code>(1)</code>，而<code>(cons 1 cons(2 ()))</code>返回<code>(1,2)</code>。</p>
<p>对构造表的一种更简便的方法是list.它表里面所有的参数合并成一个表。如<code>(list 1 2 3)</code>将返回<code>(1,2,3)</code>，而<code>(list 1 '(2,3))</code>将返回<code>(1 (2 3))</code>。</p>
<p>需要注意的一个原则是，如果没有加上单引号，那么LISP就会对表进行求值，也就是把表视为一个函数。所以<code>(2 3)</code>在LISP中被求值，函数名为<code>2</code>,而<code>3</code>作为参数，甚至<code>(&quot;Apple&quot; 18)</code>这样的形式，如果不加单引号的话，也会把<code>&quot;Apple&quot;</code>当成一个函数来求值。</p>
<p>LISP提供了一些基本的表处理函数，如car用于得到表的第一个元素，cdr用于得到表的除了第一个元素外的表。使用append可以把两个表连接起来。</p>
<p>注意LISP可以对任何表求值，只要在解析的时候没有加上单引号。</p>
<p>将一个程序作为数据的方法是setq,比如<code>(setq expr ‘(\* 5 5))</code>，表示把expr赋成表<code>'(\* 5 5)</code>(未求值)。然后调用<code>(eval expr)</code>来计算expr的值<code>(25)</code>。</p>
<p>使用print方法输出(此时函数返回被输出的值)，使用if作为条件判断。cond则相当于其它语言里面的case语句。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">(<span class="name">setq</span> name <span class="string">"Elise."</span>)</div><div class="line">(<span class="name">setq</span> greet</div><div class="line">(<span class="name">cond</span></div><div class="line">    ((<span class="name">equal</span> name <span class="string">"Marc"</span>)   <span class="string">"Hi,Marc."</span>)</div><div class="line">    ((<span class="name">equal</span> name <span class="string">"Megan"</span>)  <span class="string">"Hi,Megan."</span>)</div><div class="line">    ((<span class="name">equal</span> name <span class="string">"Elise"</span>)  <span class="string">"Hi,Elise."</span>)</div><div class="line">    ((<span class="name">equal</span> name <span class="string">"Jill"</span>)   <span class="string">"Hi,Jill."</span>)</div><div class="line">    (<span class="name">t</span> <span class="string">"Hi you."</span>)))</div><div class="line">(<span class="name">print</span> greet)</div></pre></td></tr></table></figure>
<p>这里，当name等于各个不同值的时候，把greet设置成不同的值。然后使用greet显示出来。最后的t代表true 的意思，相当于case的默认部分。</p>
<p>LISP每个求值都有返回，返回的都是一个表。</p>
<p>在LISP中，使用defun宏建立函数。格式是:</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="name">defun</span> func-name (<span class="name">parameter*</span>)</div><div class="line"><span class="string">"Optional string to describe function"</span></div><div class="line">(<span class="name">body-form</span>))</div></pre></td></tr></table></figure>
<p>在LISP中，各个不同的词法成分完全通过空白字符以及括号分隔，名称都是可以任意取的。</p>
<p>这里只略微讲它的基本特性。作为编程语言的一面，可以参考LISP的有关书籍。</p>
<p>一个编译器很简单的语言一般都是好的语言，可以供程序员自由地开发。</p>
<h2 id="schemeux8bedux8a00">Scheme语言</h2>
<p>Scheme是20世纪70年代在MIT创建的，是LISP语言的一种新的变体并支持诸如命令式与面向对象等多种程序设计范式而设计的，不仅仅是一种函数式语言。</p>
<p>Scheme是Gerald Jay Sussman和Guy Steele, Jr.的一系列论文的综合成果。这些论文着重研究程序语言的设计思想，特别是一种既高效又不受任意规则约束的简单语言的设计。这些论文演化出的语方包括这门语言的体系结构，若干操作原语和以库的形式实现的其它成分。</p>
<p>看来我也对设计语言很着迷。但是不应该纯粹只是一种兴趣，还要使这种语言具有优良的性能。需要了解程序设计语言的本质，才能设计出来不致使自己都厌烦的语言。</p>
<p>程序的本质是什么? 上面说的，体系结构，操作原语与函数库，我觉得是一个语言的核心。我曾意识到，许多语言到最后都变成像汇编那样的长串的操作，比如像TeX那样只由一些内置宏组成，像m4那样的内置宏。但是就是不知道叫什么名子。现在知道，一个程序的功能，或者说代码的语义，所代表的操作，很大程度上决定于原语。</p>
<p>Scheme语言确实很简单，因为全部语言描述大约50页，另有100页的关于库的讨论。同样地，Scheme也有多种实现。</p>
<p>Scheme与LISP一样，都是易于学习，难于掌握的。但是像这样的语言，如果我们最点接触，那么慢慢地有了经验，就会比后来再集中学习好得多。</p>
<p>Scheme作为LISP的一种方方，数据与程序的表示都是相同的。在数据表示上，除了支持原有的表类型外，还支持整数，实数，字符串，符号以及其它一些类型，相当于说扩展了能够识别的类型。Scheme的数学表达式与LISP是相同的。Scheme会将数学符号识别成表示数学运算符的原语，并且使用所谓的前缀表示法。</p>
<p>极端地，在m4语言当中，任何记号都被当成字符处理，这种类型系统就很单调。而Scheme内置了针对实数加法的运算符，我们就称它的类型系统中有实数。也就是说，一门语言的类型系统指的是它内置了那些不同的操作，这些操作又作用在哪些词法单位上。</p>
<p>在Scheme中的谓词有null表示判断表是地为空表，如果用于判断，这些谓词后面都紧跟一个?号。返回的值为<code>\#t</code>或者<code>\#f</code>。如果期望检查内存中的两个对象是否相同，可以使用等价运算符<code>eq?</code>。</p>
<p>在Scheme当中，全局变量使用define赋值，如<code>(define pi 3.1415926)</code>，而局部变量使用<code>(let (var-list) (exr))</code>的形式来表示。比如<code>(let ((pi 3.14159256) (r 5)) (\* pi (\* r r)))</code>表示在计算表达式<code>(\* pi (\* r r))</code>的时候，用<code>3.1415926</code>代表<code>pi</code>,用<code>5</code>代表<code>r</code>.</p>
<p>在Scheme当中，构造表同样可以采取cons与list过程。表示对未被求值的表进行合并，结果是一个不被求值的表，比如<code>(list \</code>a’(b c))<code>返回值是</code>’(a (b c))`。</p>
<p>Scheme基本的表的操作过程与LISP语言相同，也是car与cdr过程。与LISP相同，Scheme也提供了合并算子，比如cadr代表先car,再cdr,cdar代表先cdr再car.除此之外，也可以使用list-ref提取它的第N个元素，比如<code>(list-ref '(a b c d) 2)</code>代表提取它的第三个对象<code>'c</code>(因为编号从零开始)。</p>
<p>而length()返回表的长度。</p>
<p>Scheme支持if与cond这样的表达式。除了以递归实现循环与迭代外，Scheme还提供了类似于do那样的循环与迭代。除此之外，还提供了map函数，用于将一个函数作用于列表中的每一个对象，如<code>:(mapa (lambda (x) (\* x x)) '(0 1 2 3))</code>。Scheme提供两种类型的函数，原语和过程，原语可以理解为内置过程。在语法上，使用<code>(define (proc arg1 arg2) (body-list))</code>来定义函数，与LISP原版稍微不同。</p>
<p>可以使用write或者display函数进行输入与输出。</p>
<h2 id="pop-11ux8bedux8a00">POP-11语言</h2>
<p>POP-11是一种著名的多范式语言，具有函数式语言的许多特性。POP-11因为具有垃圾收集器而被划为函数式语言，但是它像许多命令式语言一样具有块结构语法。POP-11还是面向堆栈的，在语言设计方面具有第四代语言相对独特的功能。</p>
<p>基于堆栈的另一个语言只能想到PostScript了。</p>
<p>POP-11是爱丁堡大学在人工智能研究中进行POP系列语言开发的产物，于20世纪70年代中期在PDP~11/40计算机UNIX操作系统上实现。POP-11在语言设计方面已达到最先进的水平，它不但有函数式功能，还具有面向对象性能与一个图形库。POP-11是一个专为教学而设计的语言，虽然它功能很强大，但是却没有广泛用于软件产品的开发。</p>
<p>POP-11的有益之处是，它在单种语言中支持命令式程序设计，逻辑程序设计以及函数式程序设计，这通常被视为是艰巨的任务，而POP-11却能很好地完成。</p>
<p>在互联网上，这样的语言的资料还真不好完成。至少中文的维基百科上面就缺少这些资料。只能从英文网页寻找。而且关于POP-11的资料实在是太少了。几乎只能上英文官网上面查找。安装过程也比较奇怪。而且现在还不能编译出来带图形界面的版本。最后，能用就行了，安装完成后，输入<code class="shell">poplog pop11</code>就可以进入交互式环境了。POP-11的后缀名也是.p,不过为了避免重复，还是使用p11作为后缀吧。不幸的是，listings宏包还没有POP-11的语法高亮。不过现在POPLOG是一个SOURCEFOGRE上的项目，名为OpenPoplog,希望它可以让POP-11发展壮大吧。</p>
<p>POP-11的一个比较全面的描述是支持多种范式的程序设计，对每种范式都有相应的概念。但是在这里显然只能讨论有助于说明语言的基本特性的那些机制。</p>
<dl>
<dt>数据表示(类型系统)</dt>
<dd>POP-11包括多种数据对象，从数值(整数与小数)，到字，串，表以及向量。其中的表可以是复合的，可以包含其它的对象或者表。向量数据类型包括一组标准操作的类，用户可以进一步创建自己的向量类。字是用双引号括起来的，不知道它与串有什么区别。串是用单引号括起来的，它与其它语言中的字符串有更大的相似性。
</dd>
</dl>
<p>当然了，在POP-11中，用方括号表示表，用大括号表示向量。</p>
<dl>
<dt>谓词</dt>
<dd>对于给定的一个对象，POP-11提供了<code>dataword()</code>函数用于识别其数据类型。如果在一行语句后面添加上<code>=&gt;</code>;，作用是告知解释器输出表达式的结果。如<code>dataword(5) =&gt;;</code>。(这里光说不能讲明白，找一个POPLOG程序试一下就知道了。)
</dd>
</dl>
<p>下面是POPLOG的一个交互式输入示例:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">15:48 kael~$ poplog pop11</div><div class="line">Poplog Version 15.6.4</div><div class="line">setting poplib</div><div class="line">poplib set to /usr/local/poplog/current-poplog/Poplib</div><div class="line"></div><div class="line">Sussex Poplog (Version 15.64 Mon Oct 24 00:15:10 BST 2011)</div><div class="line">Copyright (c) 1982-2009 University of Sussex. All rights reserved.</div><div class="line"></div><div class="line">Setpop</div><div class="line">: dataword(&quot;zoe&quot;)=&gt;</div><div class="line">** word </div><div class="line">: dataword(5)=&gt;</div><div class="line">** integer </div><div class="line">:</div></pre></td></tr></table></figure>
<p>抄终端代码实在是太难看了，要多难看有多难看。</p>
<p>表达式:由于POP-11是一种多范式的语言，我们可以使用多种方式定义表达式并求出其值，像<code>5+7=&gt;;</code>，<code>*(3,4)</code> 这样的形式都是允许的。前缀表示与后缀表示都是可以的。通过两种方式，POP-11同时支持命令式编程与函数式编程。</p>
<p>变量:在POP-11中使用关键字 <code>vars</code> 声明变量，可以用它一次建立多个变量，如matlab中那样。变量之间用逗号分开，语句结束用分号分开。(用分号结尾的句子可以抑制向终端输出，Sage也有这样的功能)。变量的类型是动态确定的，它可以被赋予任意的值，比如 <code>[a b c] -&gt; x</code> (使用 <code>-&gt;</code> 作为赋值运算符(因为 <code>=</code> 代表的是相等测试(逻辑或算术相等)))。</p>
<p>同样地，POP-11提供了表处理功能。对于一个表，可以使用 <code>&lt;&gt;</code> 连接两个表，合并成新的表，并赋给新的变量。(使用pr(var)的方法在终端输出一个变量的值)。除此之外，还可以使用 <code>[x ^^list1 y ^^list2 z]</code> 这样的表达式，来重新组成一个表，其中运算符 <code>^^</code> 表示将表的元素提出来，各并到新表中。</p>
<p>POP-11的表处理，还有hd()，tl()，length()函数，分别相当于Scheme的car,cdr与length.</p>
<h3 id="条件语句">条件语句</h3>
<p>~ POP-11的条件语句采用命令式块结构模型。形如if-then-endif这样的形式，因而不再使用括号块。类似的命令式结构，还有until-do, do-until, repeat, while-do与for等等。不过尽管POP-11支持许多迭代方法，但是事实上，有些仅仅是语法糖(那些语言的附加成份，但是不不扩展该语言的表达能力的语句)。</p>
<p>POP-11支持maplist()作为其它语言中的map过程。用于将函数应用到一个表。而在POP-11中，过程的定义与块结构语言一样，使用define-endfine的结构，不过POP-11的函数定义是很广的，可以向过程传递多个结果，也可以返回多个结果(就和Python的语法一样)。</p>
<p>模式匹配:POP-11提供一组完美的模式匹匹功能，用于逻辑程序设计或者自然程序设计过程。POP-11的匹配是通过matches关键字实现的。比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[ [tim 41] [jill 35] [megan 15] ] =&gt; mylist;</div><div class="line">vars age;</div><div class="line">mylist matches [ == [jill ?age] == ] =&gt;</div></pre></td></tr></table></figure>
<p>其中matches匹配的是列表中的每一个元素。如果有等于jill的项，那么返回真值，并且将age变量的值赋给符合要求的匹配(使用?代表我们的意愿)。</p>
<p>其中的==用于表示模式在列表中出现的位置不限。这种模式匹配对于开发自然语言系统来说特别有用，如著名的Eliza程序。 比如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[I hate you] -&gt; inp_sentence;</div><div class="line">if inp_sentence matches [I ?verb you == ] then</div><div class="line">[why do you ^verb me] =&gt;</div><div class="line">endif;</div></pre></td></tr></table></figure>
<p>它表示在遇到指定的模式的时候，把中间的verb提取出来，然后返回输出。</p>
<p>也告诉我们，匹配的时候用问号，而引用变量的匹配的时候用<code>^</code>号。</p>
<p>POP-11内置的输出语句是printf,它的参数的类型是一个串(不是字)。</p>
<p>对POP-11的学习就先到这里吧。实际上，如果要达到可以自由试验的地步，应该知道怎样使用程序的交互式控制台，怎样从命令行运行一个源文件，怎样编译出来结果，以及怎样编译成库。这样才算是比较完美。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/06/20/TeX-Token/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/06/20/TeX-Token/" itemprop="url">
                  LaTeX的编程原理
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-06-20T00:00:00+08:00">
                2013-06-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:11+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2013/06/20/TeX-Token/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2013/06/20/TeX-Token/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- 这部分是关于\TeX{}的输入与词法的。但是在texbook这本书中也介绍了不少的关于控制系列，以及中英文的括号的输入的问题。比如左单引号，双引号该怎样断开。因此有少数部分是关于正字法（比如英语与中文的标点符号约定）。有时间的话应该将这部分内容独立出来，放到语言与字体，或者放到正文内容排版规则当中。-->
<h2 id="第二节-书籍排版与普通排版">第二节 书籍排版与普通排版</h2>
<p>%%% 这部分实际上是介绍tex的输入与词法规则，算是编程基础</p>
<p>当使用计算机排版，我们首先要知道传统排版与使用计算机输入字符的区别。本来计算机上面的字符并不是专门为了排版而设计的。为了使用现有的计算机键盘输入TeX的源文件，我们需要对原来的键盘符号进行一个重新定义。</p>
<h3 id="单引号双引号">单引号，双引号</h3>
<p>键盘上，左单引号与右单引号是区分开来的。一个是好像重音符号的东西，另一个就是普通的单号号。但是直接键入的时候，TeX将这个符号理解成左单引号。显然我们不能使用ASCII上的双引号排版双此号，因为那样无法区分左右。所以两个连在一起的左单引号代表左双引号，而两个连在一起的右单引号代表右双引号。</p>
<pre><code>这种方式总让我想到那个m4编程语言，也使用`与&#39;代表成对的单引号。这样的标记有一个明显的好处，那就是我们可以利用它实现块的嵌套。而且我们可以根据引号的方向就可以看出来被括起来的文本是在这个括号的前面还是在这个括号的后面。</code></pre>
<h3 id="连字符短破折号破折号减号">连字符，短破折号，破折号，减号</h3>
<p>在键盘上它们有一些相像。通常直接键入<code>-</code>产生一个连字符，<code>--</code>代表一个短破折号，而使用<code>---</code>代表一个破折号，最后的一个减号只在数学模式当中使用，方法是<code>$-$</code>。连字符常用在复合单词当中，短破折号常用来表示一个范围，比如<code>page12--23.</code>。其实也就是短破折号常用在表示数字范围上面。破折号是作为一个标点符号来看的。经常用于区分两个句子或者一个句子中不同的短语成分。我们可以想象，假设在符号<span class="math inline">\(X\)</span>前面有<span class="math inline">\(A\)</span>，后面有<span class="math inline">\(B\)</span>，那么连字符将<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>视为一个word,而短破折号将<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>视为一个number，破折号将<span class="math inline">\(A\)</span>与<span class="math inline">\(B\)</span>视为两个短语。至于减号，则是附加了运算符的意义。</p>
<p>按照长度从长到短来说，破折号&gt; 减号&gt; 短破折号&gt; 连字符。</p>
<p>在英文中，hyphen表示连字符，dash表示破折号，minus表示减号。在常用的文献当中，有时候也使用连字符代替短破折号以代表从第XX页到第YY页。不过，我们还是严格按照TeX当中的规定吧。以后就用<code>--</code>表示从第多少页到第多少页。</p>
<p>ex2.1 [怎样键入单引号，双引号，连字符，破折号，短破折号，连字符]</p>
<p>方法如上。</p>
<p>ex2.2 当你在一行中连续键入四个连字符时会得到什么结果?</p>
<p>按照最最长记号识别原则，应当是在第三个连字符后面断开，结果为一个破折号与一个连字符。</p>
<p>在排版精良的书籍中，两个相近的字母有时候会连在一起，称为组合字。组合字常用在ff,fi,fl,ffi,ffl这样的组合当中。主要是提高可读性。我们可以以find为例查看一下排版效果(默认为根据单词的组合情况自动排成组合字的)。如果要取消组合字，可以在字母中间加上一对大括号，表示从这里断开分组，将前面的词视为一个完整的排版单元。</p>
<p>在TeX当中，除了这样的调整外，还有字距的自动调整，比如<span class="math inline">\(V\)</span>与<span class="math inline">\(A\)</span>在合在一起的时候，会自动调整它们的间距，以使得排版更好看一些。</p>
<p>一般而言，TeX直接排版的时候就好像在打字机上键入书稿一样，但是在前面所提到的情况，以及其它的一些细节会做好调整。</p>
<p>如果我们的键盘上没有左引号或者又引号，可以使用控制序列<code>\lq</code>,<code>\rq</code>代替。注意TeX在识别记号的时候是遇到非字母符号的时候结束。如果控制序列后面是一个空白字符，那么控制序列后面的空白字符会被忽略，如果想使本控制序列结束，而后面的空格不被忽略，可以使用一个转义的空格，如<code>\rq\rq\</code>。</p>
<p>ex2.4 好了，现在你知道怎样得到相邻引号的排版方法了吧。</p>
<p>在单引号与双引号连续排版的时候，我们不能简单地敲入<code>'''</code>,<code>{'}''</code>等其它的任意设想的符号，按照习惯，在两者连续排版的时候，应当在单引号与双引号之间加入一个窄的空格，比如<code>'\thinspace''</code>。</p>
<p>ex2.5 想一下作者为什么使用控制系统<code>\thinspace</code>而不是<code>\,</code>以解决相邻引号的问题?</p>
<p>为什么使用<code>\thinspace</code>而不是<code>\,</code>呢? 我觉得可能根据TeX的设计原理，在<code>\thinspace</code>处不会发生断行吧。在进入数学模式之前与离开数学模式的时候可能会断行。所以可以设想一个TeX源文件有一个断行点。这个断行点决定了在那些位置可以断行。</p>
<h2 id="tex的控制系列">TeX的控制系列</h2>
<p>键盘所含的字符与所期望的显然是太少了，所以一些字符不得不转义使用。在TeX程序源代码中，使用反斜杠作为转义符。实际上，TeX允许使用任意字符作为转义符，但是一般采用反斜线。主要因为它在一般文本中很少被使用。</p>
<p>操作系统的转义符通常是ESC按键，它与TeX系统的转义符根本不是同一个概念。</p>
<p>TeX系统的转义序列由反斜杠加后面的一个单词构成，单词的定义是<code>[a-zA-Z]+,</code>因此既不能含有数字也不能含有下划线。</p>
<p>常用的控制序列有<code>\input{STRING}</code>用于将目录名为STRING.tex的文件读入到当前文档里面并执行。而<code>\'</code>，<code>\&quot;</code>表示重音符(一个像是加拼音中的二声，另一个是上面加两个点)。而且在TeX当中使用\\并不表示换段(与LaTeX不同)，而是表示排版出反斜杠来。</p>
<p>控制序列有两类，前面的一类我们已经介绍过了。实际上，<code>\'</code>这样的控制系列就是第二类，它们由反斜杠后面加上一个非字母符号构成。</p>
<p>ex3.1 在<code>\I'm \exercise3·\\!</code>中，控制序列有哪些?</p>
<p>有<code>\I</code>, <code>\exercise</code>, \\三个。</p>
<p>ex3.2 键入各种重音符号。</p>
<p>除了前面的<code>\'</code>、<code>\&quot;</code>外，还有其它的控制序列。</p>
<ul>
<li><code>\'</code> 产生一个类似于阳平的声调符号，acute accent, 尖调符号</li>
<li><code>\.</code> 在字母上面产生一个点号， dot accent, 点调符号</li>
<li><code>\=</code> 在字母上面产生一个，macron accent,平调符号</li>
<li><code>\^</code> 在字母上面产生一个<code>^</code>、circumflex accent,长调符号</li>
<li><code>\\`` 在字母上面产生一个\</code>,grave accent, 重调符号</li>
<li><code>\&quot;</code> 在字母上面产生两点，umlaut accent,元音变音符号</li>
<li><code>\~</code> 在字母上面产生一个波浪线</li>
<li><code>\d</code> 下加点</li>
<li><code>\H</code> 匈牙利元音变音符号</li>
<li><code>\t</code> 连接两个字母的等号，</li>
<li><code>\u</code> 上面加一个类似u的东西，</li>
<li><code>\v</code> 上面加上一个类似v的东西，上声。</li>
</ul>
<p>由于<code>\v</code>是一个控制系列，所以我们后面得加上一个空格或者一对大括号以使它结束。控制系列的作用域实际上是它的参数，关于TeX的控制系列如何得到参数，可以参考后面的学习主题。</p>
<p>在转义符后面跟一个空格表示的是一个不能被忽略的空格。它是第二类控制序列，所以在转义后的空格后面的所有字符都会被忽略。所以使用转义时，用<code>\ \ \</code>表示三个连续的不能忽略的空格。</p>
<p>一般来说，在英文中，句子之间的间距要比空格大一些。因此打字员通常使用两个连续的空格以表示句子结束。但是在TeX中，连续的空白字符作用是一样的。并且，TeX会自动判断哪里是句子的结束，并在排版时自动计算出较大的间距。</p>
<p>关于TeX标记的排版</p>
<p>TeX标记本身用<code>\TeX</code>控制系列产生。但是它后面是没有自动排版括号的，所以如果将TeX作为一个单词来看，我们还必须在后面加一个转义的空格。</p>
<p>TeX命令后面不加空格是有原因的，因为我们经常使用`’这样的括号，如果<code>\TeX</code>恰好后面是一个引号，如果有空格，就会产生错误的结果。</p>
<p>TeX系统控制系列的情况</p>
<p>TeX的内置控制系列大概有900个。其中有许多都是数学符号，如<code>\pi</code>,<code>\Pi</code>,<code>\aleph</code>,<code>\infty</code>, <code>\le</code>, <code>\ge</code>, <code>\ne</code>, <code>\oplus</code>,<code>\otimes</code> 等。</p>
<p>记符号也是一件不容易的事情。如果是希腊字母，小写的用全小写的英文，大写的则使用首字母大写的控制序列，至于<code>\oplus</code>,<code>\otimes</code>,则可以看成是带圆圈的加法与乘法，在群论里面经常会用到。</p>
<p>其中的大约300个称为原始控制系列，其中<code>\input</code> 就是一个原始控制系列。原始控制系列是很基本的。我们不妨看一下，<code>\TeX</code>,<code>\'</code>, <code>\oplus</code> 这些符号都不是原始系列，所以原始系列几乎可以看成是TeX语法当中的关键词。</p>
<p>在TeX运行时的交互式环境下，用<code>\show</code>命令后跟控制序列可以查看它的类型与值。我们不如在交互式环境下面读<code>\show``\thinspace</code> 看一下结果。</p>
<p>TeX的交互式环境下面有各种不同的提示符，当有两个星号时，表示需要输入一个文件名进行处理(因此进入TeX前我们先touch一个tex文档); 当有一个星号的时候，表示我们可以正常输入控制序列了。而问号表示我们进入了程序的菜单界面，这个时候按回车返回到一个星号的状态，使用X表示退出。当使用<code>\show</code>命令后，以&gt;开头的行表示控制序列的含义，-&gt;这一行表示控制系列的定义。</p>
<p>通过测试<code>\&lt;回车&gt;</code>是一个高级控制序列</p>
<p>ex3.4 有多少个两个字符的不同控制系列? 有多少三个字符的?</p>
<p>逻辑上跟ASCII编码数有关。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/06/20/LaTeX-grouping/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/06/20/LaTeX-grouping/" itemprop="url">
                  TeX与LaTeX的编组
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-06-20T00:00:00+08:00">
                2013-06-20
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:10+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2013/06/20/LaTeX-grouping/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2013/06/20/LaTeX-grouping/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="编组">编组</h2>
<p>编组可以理解成计算机编程中的模块结构。编组发生作用是在编程语言层次上的，也就是每经过一个编组，编译器就回复到编组之前的正常规则。</p>
<p>ex5.1 得到ff不连在一起的<code>shelfful</code>.</p>
<p>方法是输入<code>shelf{ful}</code>.也就是在f中间加上一个编组。</p>
<p>ex5.2 不用转义的空格，怎样在一排中得到三个空格。</p>
<p>使用<code>{ }{ }{ }</code>吧。或者<code>{ } { }</code>，注意编组后面的空格不会被自动忽略。</p>
<p>为了使控制序列作用在特定的文本上，我们也使用<code>\centerline{}</code>这样的结构。</p>
<p>虽然编组的功能很强大，但是也容易使文档变得难读。幸好在普通文稿当中不必使用太多的编组。</p>
<p>括号的作用有多个，一个是把多个单词看成一个结构，另一种是提供了一个局部模块结构。不应当认为大括号仅有一个作用。</p>
<p>ex5.3 键入下列内容会得到什么结果?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">\centerline&#123;This information should be &#123;centered&#125;.&#125;</div><div class="line">\centerline So should this.</div></pre></td></tr></table></figure>
<p>它的结果是，第一条命令产生一个居中的文本块，但是第二行将只有一个单词S。第三行变成了一o开头。</p>
<p>注意第二行不是一个单词，因为TeX控制系列默认将后面的一个字母而不是单词视为一个单独的参数。</p>
<p>ex5.5 定义一个控制系列<code>\ital</code>,使得用户键入<code>\ital{text}</code>来代替<code>{\it text\/}</code>.与<code>\it</code>相比它有什么优缺点。</p>
<p>显然使用<code>\def\ital#1{ {\it #1\/} }</code>它的不足只是放在后面，并且总是有一个斜体校正，它的所有的特点都跟它的封装形式有关。</p>
<p>TeX的宏定义与m4差不多，过多的括号里面，只有最外层的被去掉，内层的括号得到了保留。</p>
<p>TeX的参数的处理</p>
<p>与C语言不同，在编组当中改变即使是全局变量，当走出编组的时候全局变量也会恢复成原来的样子（这有一点像是有硬堆栈变量的计算机）。使用<code>\global</code>命令可以做到这一点。比如将计数器加一的操作，显然通过普通方法是不行的，在块里面需要使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\global\advance\count0 by 1</div></pre></td></tr></table></figure>
<p>其中的advance表示对指定的计数器加上特定的值。<code>\count0</code>是TeX内部的一个计数器。</p>
<p>分组</p>
<p>另一个分组的命令是<code>\begingroup{GRPNAME}...\endgroup{GRPNAME}</code>.</p>
<p>这个可以看成是LaTeX环境的基础。如果使组正常工作，那么我们就应当避免Sa,Sb,Ea,Eb这样的情况，方法其实很简单，在Sa的时候定义一个<code>\blockname{}</code>名子与本环境的名子相同，Sb也同样这种做法。这样在Ea的时候，Sb定义的blockname就会消失，在读到Eb的时候检查一下b有没有被定义就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">\def\beginthe#1&#123;\begingroup\def\blockname&#123;#1&#125;&#125;</div><div class="line">\def\endthe#1&#123;\def\test&#123;#1&#125;%</div><div class="line">\ifx\test\blockname\endgroup</div><div class="line">\else\errmessage&#123;You should have said</div><div class="line">\string\endthe&#123;\blockname&#125;&#125;\fi&#125;</div></pre></td></tr></table></figure>
<p>（具名编组的概念，有些像是Pascal语言的end for语句之类的扩展）。</p>

<p>从外壳中键入tex命令，出现双星号提示符，要求输入文件名，这个时候我们可以代之以输入<code>\relax</code>命令，进入到一个星号的状态。之后就进入排版了。</p>
<p>在输入完成内容后，键入<code>\end</code>可以结束会话，TeX会把文件输出到当前目录里面。</p>
<p>在第一篇TeX当中，可能<code>\hskip</code>, <code>\vskip</code> 以及后面的<code>\hrule</code> 我们比较常用吧。</p>
<p>直接的波浪线表示告诉TeX前后两个文本是连在一起的，不要在此处断行。<code>\vfill</code>表示用空白将本页剩下的部分用空白填满，然后用<code>\eject</code>把它送到输出文件。</p>
<p>在出现**提示符的时候，我们可以以<code>&amp;</code>开头表示以特定的宏格式处理文件，比如 <code>&amp;plain \input story</code>表示使用plainTeX的格式处理文件。一般来说，还可以在从外壳调用它的时候使用<code>tex &amp;plain story</code>或<code>tex \relax</code>这样的形式直接跳过双星号提示。</p>
<p><code>\eject</code> 表示本页处理完毕，不代表所有的页都处理完成了。我们仍然需要使用<code>\end</code>来结束文本的输入。</p>
<p>在TeX中，由<code>\hsize=</code>控制本行的排版宽度(不是页面宽度)。</p>
<p>如果TeX发出警告，那么每段文本后面最后有一个|表示在输出的时候TeX加了一个黑色的方块。以产生警告作用。</p>
<p>在输出文件的时候，TeX总会产生log日志。</p>
<p>TeX通过给定的信息以断词。比如通过<code>\hyphenation{gal-axy}</code>，中间的一个-让TeX知道这是一个可以断词的位置。</p>
<h2 id="错误信息与处理">错误信息与处理</h2>
<p>TeX的错误信息是以感叹号!开始的。并提供了错误上下文。上文是读出的内容，下文是要读的内容。并在上文的最左边给出了错误的行号(X.Y中Y表示行号)。</p>
这个时候可以键入回车，表示试图忽略本次错误，或者输入

<p>在TeX当中，这些命令改变了交互的等级。S,R,Q分别对应于<code>\scrollmode</code>,<code>\nonstopmode</code>,<code>\batchmode</code>.使用<code>\errorstopmode</code>转成正常的模式。这些命令是全局作用的，无论它们出现在哪一个组当中。</p>
<p>调用宏的时候产生的错误就像编程语言里面函数调用栈的错误一样，我们可以设置<code>\errorcontextlines</code>设置显示出来的调用栈的深度。</p>
<h2 id="tex的工作原理">TeX的工作原理</h2>
<p>在TeX中有如下约定，一个回车类似于一个空格，一行中的两个连续空格被视为一个，无论出现在哪一个位置，并且使用一个空行表示一段的结束。</p>
<p>TeX的字符所属的类</p>
<p>256个字符被分成16类。数字编号从0到15.TeX在读入文件的时候每次读取一个记号，并对比当前记号所在的类，以决定所产生的行为。这些类及作用为:</p>
<table>
<thead>
<tr class="header">
<th align="left">类别</th>
<th align="left">意义</th>
<th align="left">默认字符</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0</td>
<td align="left">转义符</td>
<td align="left">反斜杠</td>
</tr>
<tr class="even">
<td align="left">1</td>
<td align="left">组开始</td>
<td align="left">{</td>
</tr>
<tr class="odd">
<td align="left">2</td>
<td align="left">组结束</td>
<td align="left">}</td>
</tr>
<tr class="even">
<td align="left">3</td>
<td align="left">数学环境</td>
<td align="left">$</td>
</tr>
<tr class="odd">
<td align="left">4</td>
<td align="left">表格对齐</td>
<td align="left">&amp;</td>
</tr>
<tr class="even">
<td align="left">5</td>
<td align="left">换行</td>
<td align="left"><return></return></td>
</tr>
<tr class="odd">
<td align="left">6</td>
<td align="left">位置参数</td>
<td align="left"><code>#</code></td>
</tr>
<tr class="even">
<td align="left">7</td>
<td align="left">上标</td>
<td align="left"><code>^</code></td>
</tr>
<tr class="odd">
<td align="left">8</td>
<td align="left">下标</td>
<td align="left"><code>_</code></td>
</tr>
<tr class="even">
<td align="left">9</td>
<td align="left">可忽略字符</td>
<td align="left"><null></null></td>
</tr>
<tr class="odd">
<td align="left">10</td>
<td align="left">空格</td>
<td align="left"><space></space></td>
</tr>
<tr class="even">
<td align="left">11</td>
<td align="left">字母</td>
<td align="left">[a-zA-Z]</td>
</tr>
<tr class="odd">
<td align="left">12</td>
<td align="left">其它字符</td>
<td align="left">无</td>
</tr>
<tr class="even">
<td align="left">13</td>
<td align="left">活动符</td>
<td align="left">~</td>
</tr>
<tr class="odd">
<td align="left">14</td>
<td align="left">注释符</td>
<td align="left">%</td>
</tr>
<tr class="even">
<td align="left">15</td>
<td align="left">无用符</td>
<td align="left"><delete></delete></td>
</tr>
</tbody>
</table>
<p>其中每类都可以包含若干个字符。当使用plainTeX格式的时候，$,%,&amp;,#,_要转义使用。此外，一些词在转义时有其它的含义，比如<code>\~</code>得到的是波浪重音。</p>
<p>在TeX工作的时候源文件中所有的部分被分成一个一个的记号，它们或者是指定类代码中的单个字符，或者是一个控制序列。也就是在读内容的时候，TeX先给字符分类，根据分类的情况作进一步的处理:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">\hskip 36 pt</div><div class="line">\\[1]skip3[12]6[12] [10]p[11]t[11]</div></pre></td></tr></table></figure>
<p>TeX有一个叫INITEX的版本。这个版本里面气有的字母都被认为是12,除了字母，回车，空格，delete,注释与反斜杠符号之外。</p>
<p>一个明显的特点是，编组符号是不能使用的。</p>
<p>使用<code>\catcode</code>SYMBOL=N`来将字符更改到指定的类代码当中。</p>
<p>catcode的作用域是局部的。使用<code>\string</code>命令可以将控制字符分成单个的对象。使用<code>\csnameXXXX\endcsname</code>可以将一个字符记号列表变成一个单独的控制系列。只要它不与TeX的原始控制序列相冲突。这个时候，控制系列的名子完全来自于后面的字符，比如 <code>\csname TeX\endcsname</code> 我们不能使用<code>\csname\TeX\endcsname</code>这样的格式，因为<code>\TeX</code>在被调用的时候会被宏展开成其它的东西。</p>
<p><code>\string</code>宏可以看成是读取后面的非空白字符并按照原样显示，它可以用在我们的<code>\message{\stringXXX}</code>命令当中，以便正确显示出向用户提示的信息。</p>
<p>注: 当<code>\csname</code>用来第一次定义控制系列的时候，那个控制系列在重新被定义之前等价于<code>\relax</code>命令产生的效果。</p>
<p>使用<code>\let</code>命令可以给一个记号赋值，使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\ifundefined&#123;TOKEN&#125;&lt;if_true&gt;\else&lt;if_false&gt;\fi</div></pre></td></tr></table></figure>
<p>可以完成一个复杂的判断逻辑。比如</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\ifundefined&#123;TeX&#125;&lt;true_text&gt;\else&lt;false_text&gt;\fi</div></pre></td></tr></table></figure>
<p>表示在<code>\TeX</code>宏未被定义或者为<code>\relax</code>的时候被展开成<true-text>，否则被展开成<false-text>.</false-text></true-text></p>
<p><code>\let</code>的语法是<code>\let\TOKEN=\VALUE</code></p>
<p>除了<code>\string</code>用于得到记号外，还可以使用<code>\numberNUM</code>用于得到一个小数，使用<code>\romannumeralNUMBER</code>得到一个用小写罗马数字表示的数(如<code>\romannumeral24</code>得到xxiv)。并且可以使用<code>\numberREG</code>来得到一个内部寄存器里面的数字。</p>
<p><code>\uppercase{token_list}</code>,<code>\lowercase{token_list}</code>用于完成记号的转换。</p>
<p>ex7.8 想一想，<code>\uppercase{a\lowercase{bC}}</code>得到的记号列表是什么</p>
<p>这可能是TeX语法最为特殊的一点了吧。它的展开不是从内到外逐渐展开的，而是从外到内按照记号逐个分析出来的。发生的过程是，首先<code>\uppercase</code>宏看到了它的一系列参数。这些参数被识别成记号的列表，a, <code>\lowercase</code>, <code>{</code>, b, C, <code>}</code>，各自都是完整的单位。这个时候，每一个列表被分类。被uppercase宏作用，就变成了<code>A\lowercase{BC}</code>。然后继续向前读入字符并排版，转成Abc.</p>
<p>这个过程可能很特殊吧。仔细想一想，它跟m4宏还是很相像的，不过m4宏把它们都当成字符，而TeX还分类处理这些记号。</p>
<p>ex7.9 TeX有一个内部整数参数叫做year,它等于任务开始时当前年的数字，看看怎样用<code>\year</code>以及<code>\romannumeral</code>和<code>\uppercase</code>对所有运行在2003的任务给出后面的版权表示。</p>
<p>根据前面的介绍<code>\uppercase{\romannumeral\year}</code>显然是不行的，因为uppercase在展开的时候，首先得到它的参数，而它的参数还没有被展开，为了解决这个问题，必须使用<code>\expandafter</code>宏，让里面的宏先展开，让uppercase得到宏展开后的参数。</p>
<p>正确的答案是 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">\copyright\ \uppercase\expandafter&#123;\romannumeral\year&#125;</div></pre></td></tr></table></figure></p>
<p>TeX的语法的特殊性现在有一点了解了。但是还差很多基础的知识，等看到后面更多的控制系列之后再看它的语法结构吧。</p>
<h2 id="字符输入">字符输入</h2>
<p>很少有键盘能够提供256个字符，而且有的字符已经有其它的用处，所以我们使用下面的char命令得到任意的字符。格式是: <code>\char&lt;NUMBER&gt;</code>得到当前字体的相应字符。注意是当前字体中的字符。</p>
<p>在TeX刚设计的时候，一个字体文件就最多只有256个字符。在TeX内部，字体的代码总是以ASCII格式被调用的。b的内部代码，这样就总是98.</p>
<p>Knuth喜欢使用斜体表示八进制数，使用打字机字体表示十六进制数。个人的习惯不同吧。我觉得都使用正常字体就行了，Knuth的字体使用风格有些复杂。</p>
<p>八进制数使用右单引号引导，而十六进制数使用<code>&quot;</code>引导。比如<code>\char'142</code>与<code>\char&quot;62</code>与<code>\char98</code>是等效的。</p>
<p>定义char还有一个比较方便的方式，这时候不用使用<code>\def&lt;SEQ&gt;{\char&lt;NUM&gt;}</code>这样复杂的形式，而是直接使用<code>\chardef&lt;SEQ&gt;=&lt;NUM&gt;</code>。</p>
<p>有些人的键盘上直接有<span class="math inline">\(\leq\)</span>，<span class="math inline">\(\geq\)</span>这些字符，它们的生活还真是比较方便啊。</p>
<p>像回车等换行字符的ASCII可以使用<code>^^M</code>这样的形式来表示。<code>^^</code>后面实际上还可以跟两位十六进制数字，用于表示指字代码的ASCII字符。</p>
<h3 id="tex系统读入的规则">TeX系统读入的规则</h3>
<p>TeX的输入是一系列的“行”，当TeX从里面读入文本的时候，它就处于三个状态中的三歧的一个: 新行N,行中间M,跳过空格S.</p>
<p>在每行的开头它处于状态N,但是大部分的时间它处在状态M,当读入一个控制词或者一个空格之后它进入状态S,这个时候再遇到空格就会被忽略。</p>
<p>出现在行尾的任何空格都会被删除。当TeX在任意的状态读到一个第零类的字符的时候，它就会搜索这个控制序列的名子。如果行中没有其它的字符，那么定义这个序列的名子为空。如果接下来的一个字符不是属于第11类，那么它读入一个字符作为控制系列的名子。如果是属于第十一类，那么继续读，直到读到一个非第11类的字母为止。作为控制序列的一个记号。在读完记号后进入到处理第十类字符的状态S,如果读的记号为空，那么进入状态M当中。</p>
<p>TeX在任意状态遇到第7类字符，并且接下来还是一个第7类字符，也就是遇到了<code>^^</code>，如果后面跟一个小于128的字符，那么<code>^^</code>被去掉，并且从c中加上或减去64.于是<code>^^A</code>就被解释成ASCII为1的字符。但是如果后面跟的是0123456789abcdef,那么读取两位字符，然后使用十六进制代码对应的符号替换<code>^^xx</code>.当替换完成后，TeX返回到原来的位置继续开始。</p>
<p>比如，使用<code>\T</code><sup><sup>65X得到的结果与<code>\TeX</code>结果相同，因为</sup></sup>65代表的就是字母e.</p>
<p>在上面的状态下，如果遇到的不是三字符或者四字符，采用另外的处理办法。在读入一个<code>^</code>后，下面的字符如果是1,2,3,4,6,8,11,12,13类中的一个字符，或者第七类的字符，但是不能理解成上面的三字符或者四字符，那么它给字符一个类代码并且进入状态M.</p>
<p>如果遇到的是第5类(行尾字符)，那么它就放弃本行剩下的所有的内容但是如果在状态N的时候遇到了行尾字符，那么行尾字符就被转换到控制系列<code>\par</code>.如果处于状态M,那么行尾字符转换成第10类(空白)记号。如果处于状态S的时候遇到了行尾符，那么行尾的字符就被忽略。(同时转到状态N?)</p>
<p>如果遇到第9类字符，那么直接忽跳过它，就好像没有它一样。</p>
<p>遇到第10类字符的处理: N或S时，第10类字符被直接跳过，并且保持当前状态，处在状态M的时候，字符被转换成第10类的记号，并设此记号代码为32.然后进入状态S.空格记号当中，字符代码总是32.</p>
<p>我们不妨看成这就是TeX程序的词法分析。在词法分析的时候它得到了记号的类型与记号的值。</p>
<p>如果TeX遇到了注释符，它就不再读入当前行剩下的内容。</p>
<p>遇到无用符(第15类)的时候，跳过此字符，打印出错误消息，并仍保持当前的状态不发生改变。</p>
<p>如果当前行没有要读入的内容了，就进入下一行并且进入状态S.但是如果是<code>\input</code>文件结束，或者<code>\input</code>的文件给出了<code>\endinput</code>,那么TeX返回到<code>\input</code>文件读取结束后的状态，就好像是从读完input的内容一样。</p>
<p>ex8.2 回答下面简短问题，看看你对TeX的读入规则的理解程度: a.第5类和第14类的不同在什么地方 b.第3类和第4类的不同在什么地方 c.第11类和第12类的不同在什么地方 d.活动符后面的空格要忽略掉么 e.当一行以注释符%结尾的时候，在下一行开头的空格被忽略了么? f.一个可被忽略的字符能出现在控制系列的名子中间吗?</p>
<p>答:a.第5类是换行，第14类是注释，两者都结束了当前行，但是换行会被转成第10类(空白符)的代码或者一个<code>\par</code>控制系列。但是第14类的字符永远不产生任何记号。</p>
<p>b.第3类是数学类，第四类是表格类。它们产生不同类型的代记号。在后续的处理当中它们是完全不同的。</p>
<p>c.类似于b.第11类是字母，第12类是其它符号。但是只有第11类的字母有组成较长的控制系列的能力。</p>
<p>d.不能被忽略掉。活动符是第十三类，读完它后处于状态M,后面的空格不能被忽略。</p>
<p>e.是的，当注释符里面的内容结束后，TeX进入状态N,任何位于行首的空白字符都会被删除的。</p>
<p>f.不可以。控制系列是连续读取在第11类中的单词，遇到其它类就是结束对控制系列名字的读取。从而起到了分割的作用。</p>
<p>ex8.3 再次看看有关<code>\vship</code>的错误信息，当TeX报告说<code>\vship</code>是一个未定义的控制序列的时候，它输出了两行上下文，表明它正在读入文件story的第二行的中间部分，在遇见错误的时候，TeX处于什么状态，它下一个要读入什么字符。</p>
<p>我们可以按照正确的路向分析。它读入一个控制系列后处于状态S,会忽略掉后面的空白的字符(第10类)，因此它下一个要读取的是非空白字符。</p>
<p>ex8.4 给定plainTeX格式的类代码后，从输入行<code>$x^2$~  \TeX ^^62^^6</code>得到什么样的记号?</p>
<p>这得好好分析。首先数学模式正常排版，读完$后进入M状态，活动符是有效的，所以波浪线后面的空格不能被忽略。接下来读<code>\TeX</code>,在读完<code>\TeX</code>之后，进入状态S,因此后面的空格都被忽略，接下来读<code>^^62</code>,得到字母b,再接下来读记号<code>^^6</code>,得到字母v.</p>
<p>我们完全可以把这种分析过程理解成词法分析，分析之后形成了记号的类型与值的线性序列。</p>
<p>ex8.5 想想正好有一个三行的输入文件，第一行是Hi!,其它两行都是空的，当TeX读入这个文件的时候，按照plainTeX的类代码将会得到什么记号?</p>
<p>这个时候处理的方式是，处理成<code>[11]H[11]i[12]![10] [0]\[S]par</code>.空格是第一行的回车引起的。</p>
<p>据Knuth自己的表述，类代码写成数值格式主要是为了防止人们过度使用<code>\catcode</code>.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/05/07/PythonPlot/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/05/07/PythonPlot/" itemprop="url">
                  使用python下面的enthought和matplotlib绘图
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-05-07T00:00:00+08:00">
                2013-05-07
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:36:10+08:00">
                2016-12-14
              </time>
            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2013/05/07/PythonPlot/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2013/05/07/PythonPlot/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="关于matplotlib的一些问题">关于matplotlib的一些问题</h2>
<h3 id="安装模块的问题">安装模块的问题</h3>
<p>一直不了解模块到底是什么东西，它与对象有什么样的区别。到了现在才差不多把模块比成一个可以加载与控制的子程序。在Python这样的动态类型里面相当于扩展功能。相当于在C语言程序里面使用了其它的库。</p>
<p>这么说来，模块的编译原理理论应当是与子程序密不可分的。以前甚少将动态语言里面的模块与C语言这样的传统语言里的程序联系在一起。那仅仅是因为自己觉得C语言这样的程序是连接到二进制的库，而动态语言是导入源代码。而库与源代码是绝对不同的事物。这说明自己还是抱着以前形成的概念，以为在二进制与源代码是绝对分离的。但是在开源世界源代码与二进制通常并不存在异步的现象。两者还是非常相近的。</p>
<p>在开源的世界里淡化了库与源文件在用户与程序员角度上的差别。这个观点应当好好地思考一下。在Shell里面是没有什么模块的，它们使用的都是脚本与函数这样的概念。基本上只是使用另一个编译单元或者运行实体的一部分代码，这部分代码只是一个源文件里面很少的一个成分，基本上我们调用一次函数后就不再用它了。但在Python当中，我们不如认为一个模块可以以解释的方式出现，也可以以编译的方式出现。或者以混合的方式出现。这并不阻止我们使用一个模块。</p>
<p>于是使用模块就好像是在C语言里面加载动态链接库一样。大致来说就是如此。但是模块在脚本文件里面通常有更多的应用。也就是如果我们在文件a里导入一个代码，通常我们在a文件里面大量的功能都是通过库来实现的。但是在C语言里面并不能感受到这一点。</p>
<p>在C语言里面并不怎么关心库是怎样导入的。这大概是因为C是一个系统级的语言。通常而言如果我们要使用C库，需要一个头文件一个库文件就可以了。由于了解C语言的人数是那么地多，所以导入C库的方法就变得几乎不用任何思考了。</p>
<p>但是脚本语言的应用还是没有C那么多。脚本语言里的模块，虽然功能上与C还是那么地相象。但是所用的指导理论至少在形式上与C的差别还是比较大的。类似于C,模块也有自己的命名空间。但是在Python当中，模块是以一个对象的形式存在的。</p>
<p>在C语言里面也没有接触过怎么编译与安装模块，似乎那是不用考虑的，只要我们有头文件与库文件就可以了。但是那只是模块的产品，我们如何根据源代码生成库呢。</p>
<p>还有，Python里面的库是可以有很多的层次的关系的。这一点在C语言里就更没有体现了。CXX里面还有命名空间的概念的。可是以前学习CXX的时候都没有怎样讲命名空间。我想设计CXX时，命名空间那个时候还是为一解决函数调用重复而设置的一个机制，并没有太多其它的意思。但是脚本语言里面，命名空间得到了广泛的应用的同时，可能也有了一个理论的基础。不过，由于模块这个词比较陌生，在理解时用C语言的头文件加上库文件理解就是一个相当必要的方法了。</p>
<h3 id="python的库的安装">Python的库的安装</h3>
<p>以matplotlib为例吧。安装一个模块的基本过程是:</p>
<ol style="list-style-type: decimal">
<li>检查要安装的模块所需的依赖关系是否满足。我们可以视为当前系统上面是否有相应的头文件与库文件。但是C语言里面还没有见到过。我们就把模块想象成C语言里的动态链接库吧，它不仅是需要一个编译器，还需要其它的库。我们知道C语言里面单独发布一个动态链接库版本是不可想象的。伴随一个动态函数库发布的通常还有其它的依赖的关件。不过造成这一现象可能更多是策略的原因吧。</li>
</ol>
<p>对于matplotlib来说，检查的主要是numpy模块。要在动态语言里面检查模块是否被安装了，可以在执行解释器的时候导入该库，然后调用该库的 <code>__version__</code> 函数。因为在Python里面，一个模块可以通过一个对象的方法进行访问。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> numpy</div><div class="line"><span class="keyword">print</span> numpy.__version__</div></pre></td></tr></table></figure>
<p>模块与函数库的区别还在于，函数库是脱离编译器运行的。但是模块却是在解释器下源代码被解释器执行的。</p>
<p>在Python里面，对象占据着重要的地位。在导入模块的同时，不如就视为创建了一个模块访问对象。我们通过它访问到模块里面的各种数据结构，还可以通过里面的函数定义一个其它的对象。在Python里面不用声明变量类型。这是很有用的，因为模块里面对象的类型可能是非常长的一个名子。</p>
<p>在WINDOWS下面使用一个安装好的exe文件就可以了。</p>
<p>Python的库有时候需要编译。我们不如假设Python的模块不只是可以被解释，也可以直接先被编译出来，这样可以进一步加快速度。</p>
<p>matplotlib也是如此。如果我们从源代码构建它，可能就需要添加freetype,libpng,tk,pyqt,pygtk,wxpython等组件了。有了这些支持我们最终构建出来模块在被执行时所必需的程序，配置或接口实现等。</p>
<p>matplotlib的具体依赖可以查看INSTALL文档。与unix下面的其它文件基本相同。</p>
<ol start="2" style="list-style-type: decimal">
<li>编译模块</li>
</ol>
<p>matplotlib里面实际上提供了一个Makefile文件。但是make help并没有显示出结果，也就不敢随便用它。按照上面的说明，编译的时候执行命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">python setup.py build</div></pre></td></tr></table></figure>
<p>这是很简单的。因为我们还在没有configure的时候就已经编译出来了，到最后我们应该把文件安装到哪个位置呢。C语言的库来说并不成问题，一来有configure的prefix指出目标目录，并且unix系统搜索C库的位置我们也是知道的。但是Python就不同了。我们可能安装的并不是标准位置。但是先不管它。</p>
<ol start="3" style="list-style-type: decimal">
<li>安装模块</li>
</ol>
<p>安装模块实际上相当于保证主程序，也就是python里面在import命令被执行的时候能够找到相应的模块。一般来说，模块能不能被导入仅仅是取决于它们是否在搜索路径里面。而Python的搜索路径除了当前工作目录外，就是在安装Python的时候的标准的路径了。</p>
<p>不同的系统有不同的定义吧。在我的系统上/usr/lib64/python*里面有python的标准模块。但是仍然没有发现matplotlib被安装在了哪里。</p>
<p>可以通过sys模块的 <code>exec_prefix</code> 与path变量得到关于python解释器的一些信息。模块文件可以是.py, .pyc, .pyo, .pyd, .so. 结果按照这种要求。在/usr/lib64/python2.7/site-packges里面找到了matplotlib. 假设Python安装在了 <code>$PREFIX</code> 下，可执行程序在 <code>$EXEC_PREFIX</code> 。下面，那么一般先找 <code>$PREFIX/lib/pythonX.X</code> 文件夹(Python可以向系统提供自己格式的库文件)，找 <code>$PREFIX/lib/pythonX.X.zip</code></p>
<p>有的时候 <code>$PREFIX/lib/pythonX.X/plat-linux2</code> 也会被设置。动态加载模块的路径放在 <code>$PREFIX/lib/pythonX.X/lib-dynload/</code> 下面。其它模块的默认安装路径一般是 <code>$PREFIX/lib/pythonX.X/site-packages/</code> 。整个模块组织成了一颗树的形状。这颗树的根由库的搜索路径合并而成。每遇到一个子文件夹可能这颗树就向下延伸一层。</p>
<p>在sys模块里面的path变量里显示的是模块的ROOT的来源。而sys模块的本来含义并不是操作系统，而是Python解释器里的相关变量。</p>
<ol start="4" style="list-style-type: decimal">
<li>检查模块是否可用</li>
</ol>
<p>这部分通常要运行一些测试脚本来完成。有时候如果没有的话，我们可以尝试导入我们安装的库，看看有没有异常出现。</p>
<p>自动测试应该还是有一些技术可言的。个人觉得应该使用脚本以及高度自动化的工具完成这些任务。说明一下，自己还想到使用m4宏处理器写一个简单的TeX前端，用于包含了复杂选项的TeX变成一些容易设置的选项的集合。</p>
<p>注：unix下面的应用程序都可以这么来看。一个应用程序的目录总是符合unix下面目录的规范的，库安装到 <code>$PREFIX</code> 的lib/下面，诸如这些规定。对于Python来说也是不例外的。因此对于matplotlib包来说，它不必什么都看Python安装在哪里。它可以认为它就是一个库，因此它的库与模块就安装在 <code>$PREFIX/lib/python</code> 下面，它的文档就安装在 <code>/share/doc/$LIBNAME</code> 下面。</p>
<h3 id="关于ipython交互式解释器">关于IPython交互式解释器</h3>
<p>matplotlib的pylab在运行show()时有时会不出现结果，那是因为我们当前可能并未关联到图形库。要想显示图片通常在shell里执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ipython -pylab=qt</div></pre></td></tr></table></figure>
<p>之后，使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">run $script_name</div></pre></td></tr></table></figure>
<p>然后输出Python相应的代码进行。</p>
<p>使用IPython也算是能够提高工作的效率吧。不过也许只有在IPython里面才可以直接使用run命令了。这对于执行脚本是很有好处的。</p>
<p>在使用pylab的时候，绘图的后端决定了图片在哪里被显示。在ipython里面可以使用debug命令进入调试。</p>
<h3 id="matplotlib的其它问题">matplotlib的其它问题</h3>
<p>其实可以使用setup.cfg对matplotlib的安装进行更详细的配置。我们不用从网上找资料。因为源代码包里的INSTALL等文档就是最好的说明。就连setup.py脚本也有很好的可读性。</p>
<p>也许以后自己应当学会从源码包里面读英文文档了。在网上找资料实在是太麻烦了。而且如果有可能，软件的使用教程也应当从附带的doc里面查找。</p>
<h2 id="matplotlib绘图的基本方法">matplotlib绘图的基本方法</h2>
<p>读过了书里的第5章的文档，觉得matplotlib的确很伟大。但是自己还是觉得不应当手动从无到有地使用pylab绘制图表，而是应当通过其它的科学计算软件调用它。这样绘制出来的图表才有意义。不然就纯粹是为了玩了。</p>
<p>我们不介绍其它的模块了。matplotlib是Python最著名的绘图库。但是pylab能在numpy或者scipy里面集成接口。</p>
<p>调试的方法</p>
<p>几乎每一本书都说Python的调试功能很强大。但是我却觉得Python的错误显示很复杂。大概是我不会使用堆栈吧。在ipython里面调试时，先运行程序。如果出现错误，程序会返回。这个时候调用debug返回到出错的时候的堆栈，使用u命令在堆栈中一直向上，直到出现本层次模块里的错误为止。</p>
<p>其实ipython的错误提示是我见过的最好最详细的提示了。中间有高亮又有各个源代码文件出错的行号。不过相比之下，python里的错误输出可能是最难读的了。可能是堆栈太多的时候必须有一定的提取文件中关键错误的方法吧。</p>
<p>ipython调试的时候显示的高亮什么的特性在Sagemath里也得到了应用。</p>
<p>matplotlib绘图的时候有一种基本的方法就是使用</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div></pre></td></tr></table></figure>
<p>这样可以直接使用pyplot模块提供的绘图函数功能。</p>
<p>把模块导入成对象，可以这么理解，导入一个对象相当于找到一个能够在运行期间为我们干活的人。这个人可以做相应的输出，我们可以调用它里面的相应方法，或者根据它的功能创建一个工作对象。</p>
<p>另一个则是使用matplotlib的pylab模块。其中包括了许多NumPy与pyplot模块里面的绘图函数，可以方便快捷地进行计算与绘图。pylab可以直接通过</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> pylab <span class="keyword">as</span> pl</div></pre></td></tr></table></figure>
<p>进行。</p>
<p>书里面实际上介绍了三种绘图的方法。有pyplot,pylab,这样直接调用模块的方法，也可以是调用pyplot里面的绘图API进行绘图。</p>
<h2 id="pyplot的面向对象的绘图方法与机制">pyplot的面向对象的绘图方法与机制</h2>
<p>我们不如这样理解pyplot的工作过程。在刚开始的时候创建了一个模块访问对象，也就是在<code>import pyplot as plt</code>里面说明的plt这个名子。通过这个名子我们访问到绘图所需的一切要素。plt里面有自己的成员与数据，它的直接成员与数据通常都是用于调整绘图环境里面的配置的。真正绘图的时候，总是通过具体的绘图对象完成的。</p>
<p>我们不如称做是一个绘图对象关联了一个模块访问对象。我们可以通过plt创建，显示绘图对象，切换当前绘图对象这些操作。</p>
<p>绘图对象里面最基本的就是图表，其次是子图。当我们调用plt的绘图函数plot()的时候，总是在figure与axes对象上面绘制的。</p>
<p>一个模块访问对象plt里可以管理多个绘图对象。一个绘图对象里面也可以有多个子图。在pyplot里面，通过plt.figure(N)的方法访问指定序号的图表。当序号不存在的时候该图表会被自动创建。</p>
<p>如果我们在ipython里面测试，我们就会发现调用plt.figure(1)的时候会出现一个绘图窗口。接下来的绘图就是在这个窗口里面进行，而如果再调用plt.figure(2)就会创建另一个绘图窗口，里面有另一个图表。这时再调用plt.figure(1)并不会出现新的窗口。相当于模块会自动判断当前绘图区存在与否。</p>
<p>一个图表对象的类型是Figure。默认情况下，模块访问对象plt会创建一个图表，并将它作为当前的图表。plt的figure()函数也可以接受其它种类的参数。总而言之，plt的figure()函数完成的工作是创建图表，管理，导出当前绘图模块所属的某个图表对象。以及选择当前的模块访问对象绘图时所在的图表。</p>
<p>使用plt的gcf()函数获得模块的当前图表对象。类型是matplotlib.figure.Figure。无论以前面的哪种方式，返回值都是一个图表对象，我们就是在这个图表对象里绘制图表的。</p>
<p>这样一来，我们就不需要在figure里面绘图，然后再进行显示了。plt里面封装了访问当前figure的方法。调用名称与figure对象里的类似。</p>
<p>一个图表可能会有多个子图。子图用Axes对象来表示。pyplot并不是在一个Figure对象上直接绘图的，而是在一个Axes里面绘制函数的图象。plt模块封装的plot()，xlabel()等方法几乎都是针对于模块访问对象的当前子图而起作用的。</p>
<p>使用plt.gca()得到当前的子图。而使用plt.subplot()函数可以创建子图(实际上是在当前的Figure对象里面创建子图)。subplot的函数调用是subplot(Rows, Cols, Index)。该调用的含义是假设当前Figure对象被分成Rows*Cols的网格。使用编号为Index的区域绘制子图。Index的编号是从左到右，从上到下，编号从1开始。</p>
<p>如果Figure对象判断不同的subplot的区域有重叠，前面的被重叠的子图将会被清除掉以绘制新的子图。否则就继续添加新的图表。</p>
<p>函数subplot()返回它创建的Axes对象。调用gca(Object)可以使这个Axes()对象成为当前的对象。如果子图已经存在，subplot并不会将先前的子图覆盖，而是返回符合那个标号的子图。比如下面的代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">plt.subplot(<span class="number">111</span>)</div><div class="line">plt.subplot(<span class="number">111</span>)</div></pre></td></tr></table></figure>
<p>第二个语句并不会清除掉第一条语句里的subplot,而是返回第一条子图创建的对象。</p>
<p>当Figure与Axes对象都决定好之后，真正的绘图就开始了。</p>
<h3 id="绘图的时候坐标系的选择">绘图的时候坐标系的选择</h3>
<p>matplotlib设置了四组坐标系。各个坐标系的大略描述如下:</p>
<p>窗口坐标系: 左下为(0,0)，右上为(W,H)。坐标以像素为单位。</p>
<p>图表坐标系: 左下为(0,0)，右上为(1,1)。坐标以英寸为单位。</p>
<p>子图坐标系: 左下为(0,0)，右上为(1,1)。本身是没有单位的。</p>
<p>数据坐标系: 根据不同的坐标系有不同的表达形式，在笛卡尔坐标系下面通常是<span class="math inline">\((XMIN, XMAX)\)</span>到<span class="math inline">\((YMIN, YMAX)\)</span>。本身没有单位。但是我们可以根据物理量来设置。</p>
<p>在屏幕输出的时候才用到窗口坐标系。我们不妨将图表坐标系看成是与平台无关的。决定了对象的实际的大小。</p>
<p>在实际绘图时，一旦终端被确定了，绘图程序的窗口坐标系也就相当于是确定的。于是根据这种关系，一个图表被显示到桌面上，或者是输出到一个文件当中。而单以纯数据表示而论，在运行的时候，所有的图形的位置在图表坐标系里面的安排都是固定的了。</p>
<p>不同坐标之间的变换都同样地依赖于本对象的二维仿射变换矩阵的定义。</p>
<p>假设ax是一个Axes对象。那么它有一个transData用于决定从数据坐标系到窗口坐标系的变换。函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ax.transData.transform((<span class="number">3</span>, <span class="number">5</span>))</div></pre></td></tr></table></figure>
<p>将返回点(3,5)在变成窗口坐标系后所在的位置。 注: 返回类型是一个ndarray对象。而且这个函数也可以一次调用返回多个点在窗口坐标系里面的位置。</p>
<p>下面我们以Figure下在的tranFigure变换为例了解Python的实现。</p>
<p>在交互式命令行下直接输入f.transFigure()将可以看到它里面的一些对象。其中第一项里面的Bbox描述了这个Figure的物理大小信息。比如<span class="math inline">\([0,0]--[8,4\)</span>，单位是英寸。而在Affine2D里面的就是那个变换矩阵了。经过分析不难发现，对角线上的第一个元素就是所谓的X方向分辨率，第二个元素就是Y方向分辨率。我们也可以通过直接查看 <code>f.transFigure._boxout._transform</code> 得到真正的变换矩阵。</p>
<p>上面的代码实际上还只是一个Affine2D对象。调用它的 <code>get_matrix()</code> 方法才能得到以numpy.ndarray形式表示的矩阵。</p>
<p>而Axes对象在Figure里面的位置可以通过 <code>Axes.get_position()</code> 方法得到。其结果是在图表坐标系里面的位置(注意Figure坐标系从左下角的(0,0)到右上角的(1,1))。如果子图是以2*3行分隔的，那么最后一个子图的坐标通常就是(0.66,0)-(1.0,0.5)。不过实际上子图与图表边缘之间还是有一定间隔的。</p>
<p>根据这一信息我们自己就可以计算出来Axes对象如何转换成窗口坐标系了。就是拿前面的坐标系，乘以Figure的变换函数。这步工作Python是不会每计算一个点就运算一次的。因为Axes提供了 <code>ax.transAxes._boxout</code> 对象，它里面存储了变计算后的结果。</p>
<p>一般来说，一个子图对象里面只有一个数据坐标系。于是我们可以通过Axes对象访问数据坐标系的transData对象。该对象指出了数据坐标系里的点如何进行变换。</p>
<p>transData由transLimits与transScale构成。transLimit描述了该数据坐标系的坐标范围，比如(-5,-5)-(2-3)。而transScale表示transData将数据坐标系转成Axes对象坐标系里面的缩放大小，通常都是1.于是数据坐标系里面的某个点转成一个窗口像素。</p>
<p>使用这些概念主要用于处理不现的坐标系表示方法，以及不同的刻度标准。</p>
<h3 id="关于绘图操作">关于绘图操作</h3>
<p>如何调用label,line,axis等对象这里就不说了，因为它们是一些很繁锁的东西。</p>
<p><strong>matplotlib绘图的背后原理</strong></p>
<p>matplotlib的绘图的三个层次(这种三层次模型也可以用在其它的语言里面)是:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">backend_bases.FigureCanvas</div><div class="line">backend_bases.Renderer</div><div class="line">artist.Artist</div></pre></td></tr></table></figure>
<p>Renderer与Canvas知道如何处理底层的绘制操作，比如在QT界面上绘图或者使用PostScript在PDF文件里面作图。Artist对象处理所有的高层的结构，如图表，文字与曲线等绘图元素的绘制与布局。通常我们只是与Artist对象打交道，而不需要关心底层是如何实现绘图的细节的。</p>
<p>Artist对象有简单类型与容器类型两种。有点像是GUI里面的Component.简单类型的Artist对象是标准绘图元件，如Line2D, Rectangle, Text, AxesImage等。但是容器类型则包括了其它的简单对象，如Axis, Axes, Figure等。我们不如把Artist看成是一个桌面绘图管理器。那么以前所学过的Metapost语言便就是用于产生这些复杂对象的绘图原语言。它们能够在更底层的意义上提供编程方法，因而更容易绘制出来其它的对象。</p>
<p>Asymptote与Artist相比，多的只是一种灵活的方式。Artist虽然也是用编程语言实现，但是封装的内容与对象比较繁杂，底层不够清晰。而Asy使用清晰的底层数据结构，让我们可以自由地决定插值等操作。</p>
<p>我们也可以直接使用Artist对象绘图。利用Artist的特性的关键在于我们使用Artist提供的许许多多绘图对象，通过调用它们的方法设置它们的属性，进而描述出图形里面各个元素的关系。</p>
<p>一个Axes对象里面包含了其它的简单的对象，因为Axes是容器类型。使用Axes的lines可以得到在该子图里面的所有曲线列表。我们可以通过该函数返回对于这个曲线的引用以便我们能够单独地调整该line的属性。</p>
<p>Figure对象与Axes对象都有一个patch属性作为它的背景。这向我们说明Figure对象对于绘图的理解是描述性的，只有在调用实际的绘图引擎的时候，才会将背景显示出来。该背景是一个Rectangle对象。通过它我们可以设置背景的背景颜色，透明度等等属性。</p>
<p>Artist的对象有一些通用的属性，比如透明度alpha, label, visible等。所有的属性都可以通过 <code>get_</code> 方法或 <code>set_</code> 方法读写。而可以通过任何一个Artist对象的set()函数与get()函数设置一个对象的多个属性。</p>
<p>模块访问对象提供了getp()函数用于返回一个Artist对象的各种属性。比如通过 plt.getp(plt.gcf())我们就可以得到当前图表对象的所有属性名与值。在交互式ipython里面我们可以参考这些输出通过前面说过的set方法加以改变。</p>
<p>在matplotlib里面，Axes是绘图的核心。它包含了许许多多的Artist可显示对象。</p>
<h2 id="matplotlib的配置文件">matplotlib的配置文件</h2>
<p>matplot工作是类似一个应用程序。检查配置文件的顺序是，当前配置文件，用户家目录下的配置文件，应用程序里面的配置文件。配置文件实际上是一系列的变量与值。在依次读取这些配置文件的过程中，如果前面的配置文件已经设定了这个值了，那么后面配置文件里面的值就不再生效。于是配置文件的优先级是当前目录最高的。</p>
<p>配置文件的读取也有一些规律。Bash从/etc里面读取配置，最终也是用户目录里面的配置脚本生效的。不如引入配置文件优先级这个概念。一个应用程序在工作的时候，假设从一列可选的列表里读取每一个配置文件。高优先级的配置文件是说，如果配置项目出现在某一个配置文件里面，而其它配置文件里面有相同的配置项目的时候，前者会对程序起到真正的作用。于是Bash里的配置文件中，系统目录是第一读取的，并具有最低的优先级。matplotlib里面，系统目录是最后读取的，具有最低的优先级。世界真是奇妙。</p>
<p>matplot配置文件可以通过 <code>matplot.get_config_dir</code> 得到当前生效的路径，使用 <code>matplotlib.matplotlib_fname()</code> 得到最优先的那个配置文件。 而 <code>matplotlib.rc_params()</code> 用于读取配置文件里的每一项(默认是返回当前使用的配置文件里面的项目)， matplotlib使用rcParams变量保存当前的配置。如果要修改，可以直接令</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">matplotlib.rcParams[$hash_key] = $value</div></pre></td></tr></table></figure>
<p>以让参数成为当前绘图参数。</p>
<p>matplotlib.rc()函数接受一些参数设置并将它写入rcParams变量。如果要恢复默认的配置文件里面的内容，可能需要rcdefaults()选项。</p>
<p>显然matplotlib是不支持直接从matplotlib里面直接修改配置文件里的内容的。因为这些配置文件可能权限比较高，或者干脆就是系统目录下的配置文件，不允许用户修改。</p>
<h3 id="在实际的应用中使用一个库">在实际的应用中使用一个库</h3>
<p>在python里面导入模块使用import命令。而使用reload(modulename)可以重新加载这个模块(让里面的数据复原)。</p>
<h3 id="中文字体的显示">中文字体的显示</h3>
<p>在matplotlib里面一个是使用Fontmanager选择字体。这对于有些绘图方法特别有用。比如plot()的xlabel()这些函数，都可以接受一个font=可选参数。这个时候选择一个字体属性就可以了。</p>
<p>但是这种方法明显的缺陷是缺乏统一性。如果我们需要绘制多种图，或者需要学习多种图的绘制参数，每一个都要学习就变得代价太高了。所以我们还是用统一的方法吧。</p>
<p>统一的方法是matplotlib的rcParams参数。这些参数让我们选择字体的字族等参数。具体可以通过rcParam.keys()找到。字体大小也可以找得到。如果我们要显示中文。那么我们应当检查以下的做法是否被完成了。</p>
<p>1.虽然Python对于unicode的支持很好。可以直接通过u“”使用unicode字符串。但是这样还是不能够保证直接解析出来多字节编码。尤其是采用unix的magic来运行脚本的时候，编码必须被另外指定。这种方法就是所谓的W3C编码指定方法。</p>
<p>这种方法比较自由，也就是在前面的几行里面出现<code>#-*- coding: utf-8 -*-</code>这样的字符就可以了。下面的编码就会自动被认为是unicode文本并采用了utf-8编码。</p>
<p>2.需要支持中文的字体才能显示出来中文字符。如果没有这样的字体，通常并不是显示乱码，而是是空格或者方框代替。但是一个字体里面总是只包含特定的几个语言里的编码，很少有字体可以包括所有的文本。于是换字体似乎是必然的。不幸的是，Python没有LaTeX那样的复杂的字体种类。同一时间加载的只有一个字体文件。所以我们如果要使用不同字符区域位置的字体，最好还是自己换用字体。</p>
<p>3.系统下使用fontconfig管理字体。大概其它的应用程序也使用了这样的接口，所以可以使用某种字体名，而不需要通过字体文件访问指定的字型。如果我们要改变matplotlib的文件，除了通过fontconfig查询系统字体之外，大概也能够使用fc-list管理字体文件。</p>
<p>4.当将字体嵌入到图表的时候，注意字体的大小。这个是很关键的。对于显示效果有重要的影响。一般而言，如果我们要在图表里面使用字体，一定要确定我们希望图表的输出大小。这个问题在下面的笔记中会讲到。</p>
<p>讲求实际大小在计算机可以自由放缩文本的时候似乎显得有点过时。但是人的眼睛视野大小总是一定的。我们虽然可以放大与缩小图象。但是同一时间内我们的焦点只是集中于图象的某一区域。这个时候采取放大镜的做法也许对我们更好一点。虽然我们可以这么做。但是随意地放大与缩小字体还是缺少一种科学上的价值。我们应该时该记着我们想输出的字体是有多大的。</p>
<p>实际上这些问题大概还是视觉范围的问题。比如我们在看书的时候，因为离得近，虽然很小，但是也能看清楚。可是如果是在屏幕上，那么小的字体就不行了。我们不妨做一个计算。假设我们眼睛离书是30厘米。而字体的大小是11pt。换算成厘米表示，字体的大小就是0.38cm.也就是说，我们平常见到的印刷体也就是0.4cm左右的大小。但是如果是在屏幕上显示，我们的距离变成了80cm.这时的11pt相当于在30cm处看到一个0.15cm大小的块。于是我们可以说，我们的眼睛实际上可以看到小的物体。但是如果我们一直使用较小的字体，对于我们的眼睛也会造成一些压力。大概这就是为什么使用电脑伤害更大吧。</p>
<p>原来自己对于这些东西一直没有什么概念。但是现在才发现问题的所在。那么以后在使用显示屏的时候，就要注意到自己是在多远的距离下看多大的物体。其实距离这么远的话，将屏幕的字体调大一些也是很合理的。</p>
<p>原来的时候自己一直以为在纸上是多大，在显示屏上就应该是多大。这样自己的感觉会好一些。但是今天终于发现，原来显示屏上的内容是不可以相信阅读效果的。但是由于显示屏上照样以11pt的大小显示，那么我也就没有什么办法了。可惜的是，计算机在这么大的时候分辨率不够。</p>
<p>注：业界总是认为高分辨率屏幕没有什么作用。但是它们的确有很大的作用。因为我们通常在显示屏上看到的并不是与看书时文本的大小，所以如果分辨率更高一些，就能够以更华丽的字体显示。而且，图片的大小也可以进行调整。</p>
<p>注：如果我们不使用桌面显示器。那么最终的效果应当是我们每天都在看书。</p>
<h2 id="关于绘制饼状图">关于绘制饼状图</h2>
<p>也许饼状图在科学计算里面遇到的并不多。但是在人际交流里面用的还是很多的。这些活动包括政治活动，商业活动。反正是在向不是一行的人解释东西的时候很有用。</p>
<p>饼状图调用的是pie()函数，它与plot()函数的作用是类似的。但是pie()函数只给出了一个返回值，而且输出的结果不可进行广泛调整的。比如它就不支持传入font=参数，以致于我们必须得事先设置rcParams.</p>
<p>饼状图在显示比例上是很好的。它的主要参数是一列正则化的数据。是数值类型的。至少可以计算出来一个百分比。一般来说，还需要一列标签文本，以辅助显示。至于阴影线与突出显示，就没有那么重要了。</p>
<p>文档与绘图，是一系列基础的技能。它相当于古代能够写字的人与不会写字的人之间的区别。只有自己能够创造出来这些东西，才相当于有了这样的表达工具，不然就只是一个平平常常，只能从事体力劳动与重复劳动的人。其工作也就不能显示出任何的创造性。</p>
<h2 id="enthought公司的几个科学计算软件">ENTHOUGHT公司的几个科学计算软件</h2>
<p>这个公司的软件还是比较难得到的。我们要首先知道git.但是git对于断点续传的支持是很差的，所以我们就要在国内这么差的网络上进行数据的处理了。于是我们就很难得到。但是我们得到以后还得看说明去安装它。为此应当先去构建它。在构建过程中有几个库我们的机器上可能是很难得到的。</p>
<p>现在知道，ETS需要至少需要freeglut,vtk,swig,hg这些软件。但是通常情况下不可能是完备的，于是我们通过逐步测试build的方式解决这一系列的问题。</p>
<p>Cython以及相应的distutils库也是Python所需要的。这些库应当受到足够的重视。</p>
<p>国内的现状大致如此。为了更好地研究一个问题，有时候必须采取一些极端的手段才行。可是这些手段有时候让人追寻了好久好久。最后找到的还是一个不全面的解答。我想自己需要静下来多想一想为什么。</p>
<h2 id="matplotlib的设置">Matplotlib的设置</h2>
<p>默认方法仍然是使用.matplotlibrc文件。这样输出的文件比较不错，而且也可以避免在运行脚本的时候花很长时间处理图表参数。</p>
<h3 id="matplotlib示例">Matplotlib示例</h3>
<p>好久没有使用过Matplotlib绘图了，里面的有些东西都忘记了，实在不应该啊。现在是得好好学习的时候了，因为现在及以后会使用很多这样的方法的。</p>
<p>首先是matplotlib的配置问题。这是一个.matplotlibrc文件决定的。配置的方法可以参考matplotlib的官方网站<a href="http://matplotlib.org/users/customizing.html" class="uri" target="_blank" rel="external">http://matplotlib.org/users/customizing.html</a>。在实际中我们用到的更多的是对于图形的大小的控制。因为我们要输出文件放入到文章当中。其中的选项figure.figsize, figure.dpi, savefig.dpi, savefig.format是在matplotlibrc里面应该指定的。不然每次输出的时候都可能要设置一下，太麻烦了。</p>
<h4 id="折线图">折线图</h4>
<p>Matplotlib最简单的方法应该是用折线顺次连接起来 <span class="math inline">\(y\)</span> 轴上的数据了。这个时候 <span class="math inline">\(x\)</span> 轴对应的坐标就是元素在列表中出现的次序。代码与效果分别如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="comment"># Plot a list of numbers with pyplot</span></div><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</div><div class="line">plt.ylabel(<span class="string">'some numbers'</span>)</div><div class="line">plt.savefig(<span class="string">'../img/'</span>+re.sub(<span class="string">'.py$'</span>,<span class="string">'.pdf'</span>,sys.argv[<span class="number">0</span>]))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="/img/python-plots/729_01.png" alt="image">
<p class="caption">image</p>
</div>
<h4 id="散点图">散点图</h4>
<p>散点图只不过使用了两个数组。另外，还可以接受点的形状作为第三个可选的参数。使用axis选项可以设置坐标轴的显示范围。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">#!/usr/bin/env python</span></div><div class="line"><span class="keyword">import</span> sys; <span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line">plt.plot([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>],[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>],<span class="string">'ro'</span>)</div><div class="line">plt.axis([<span class="number">0</span>,<span class="number">6</span>,<span class="number">0</span>,<span class="number">20</span>])</div><div class="line">plt.savefig(<span class="string">'../img/'</span>+re.sub(<span class="string">'.py$'</span>,<span class="string">'.pdf'</span>,sys.argv[<span class="number">0</span>]))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="/img/python-plots/729_02.png" alt="image">
<p class="caption">image</p>
</div>
<p>代码中的<code>ro</code>代表使用红色圆点来表示。与MATLAB有几分相似。其它的选项还有，<code>r--</code> 代表红色虚线，<code>bs</code> 代表蓝色方块，而<code>g^</code>代表绿色三角形。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> sys</div><div class="line"><span class="keyword">import</span> re</div><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="comment"># every sampled time at 200 ms intervals</span></div><div class="line">t = np.arange(<span class="number">0.</span>, <span class="number">5.</span>, <span class="number">0.2</span>)</div><div class="line"><span class="comment"># red dashes, blue squares and green triangles</span></div><div class="line">plt.plot(t,t,<span class="string">'r--'</span>, t,t**<span class="number">2</span>,<span class="string">'bs'</span>, t,t**<span class="number">3</span>,<span class="string">'g^'</span>)</div><div class="line">plt.savefig(<span class="string">'../img/'</span>+re.sub(<span class="string">'.py$'</span>,<span class="string">'.pdf'</span>,sys.argv[<span class="number">0</span>]))</div></pre></td></tr></table></figure>
<div class="figure">
<img src="/img/python-plots/729_03.png" alt="image">
<p class="caption">image</p>
</div>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/05/01/platform-jdk/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/05/01/platform-jdk/" itemprop="url">
                  JDK与OpenJDK的安装与使用
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-05-01T00:00:00+08:00">
                2013-05-01
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T19:23:23+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2013/05/01/platform-jdk/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2013/05/01/platform-jdk/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="openjdk的官网上面的安装手册">OpenJDK的官网上面的安装手册</h2>
<p>在openjdk官网上面的资料<a href="http://openjdk.java.net/install/index.html" class="uri">http://openjdk.java.net/install/index.html</a></p>
<p>How to download and install prebuilt OpenJDK packages</p>
<h3 id="jdk-7">JDK 7</h3>
<p>Debian, Ubuntu, etc.</p>
<p>On the command line, type:</p>
<figure class="highlight plain"><figcaption><span>.bash&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install openjdk-7-jre</div></pre></td></tr></table></figure>
<p>The openjdk-7-jre package contains just the Java Runtime Environment. If you want to develop Java programs then install the openjdk-7-jdk package.</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2013/05/01/platform-jdk/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/04/29/Linux-DHCP/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/04/29/Linux-DHCP/" itemprop="url">
                  Linux下DHCP服务器的配置
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-04-29T00:00:00+08:00">
                2013-04-29
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:50:22+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2013/04/29/Linux-DHCP/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2013/04/29/Linux-DHCP/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <!-- 这些网络服务的复杂参数搞得自己头疼死了，这些人一是在说的时候只说自己的情况，
第二个就是在写的时候文章是大量内容的积累，而不是清楚而明确的一系列参数。-->
<p>DHCP的主配文件便是/etc/dhcpd.conf.</p>
<p>DHCP服务器搭建流程分为几步，第一是编辑主配文件，指定分配的范围等。第二就是建立租约数据文件，第三就是启动或重启DHCP服务，使配置生效。</p>
<p>DHCP的工作过程是客户端以广播的方式向服务器申请IP地址(通过接口连接)。DHCP服务器通常本身接口已经配置好IP并在这个接口上启动了DHCP服务。于是服务器根据DHCP的相关配置给客户端提供IP,GATEWAY,DNS等信息。并且DHCP服务器将本次分配信息存入租约数据库里面。</p>
<p>DHCP的配置文件一般从安装源目录的一个dhcp.conf.sample文件得来。该文件包含了适用于服务器的配置，本行的<code>#</code>后面的内容被DHCP服务器视为注释并自动忽略。</p>
<p>DHCP主配文件里面分成参数，选项，声明三种类型。</p>
<p>参数一节表明DHCP服务器如何执行任务，是否执行任务，以及要发送给客户的选项。声明一节用于描述网络的布局，提供给用户的IP地址等。选项一节用来配置DHCP可选参数，都以option关键字作为开始。</p>
<p>先说参数一节里面的重要关键字。</p>
<table>
<tbody>
<tr class="odd">
<td>default-lease-time</td>
<td align="left">缺省租赁时间的长度，以秒为单位</td>
</tr>
<tr class="even">
<td>max-lease-time</td>
<td align="left">最大租赁时间的长度，以秒为单位</td>
</tr>
<tr class="odd">
<td>hardware</td>
<td align="left">指定网卡接口类型与MAC地址(假设客户端的信息)</td>
</tr>
<tr class="even">
<td>server-name</td>
<td align="left">通知给DHCP客户端的服务器名称</td>
</tr>
<tr class="odd">
<td>fixed-address ip</td>
<td align="left">分配给客户端的IP地址</td>
</tr>
</tbody>
</table>
<p>注意: 在客户端发出分配IP请求的时候，服务器也会根据客户端的信息决定IP的分配。所以在参数一节里面，所提供的hardware相当于筛选出来具有特定特征的客户端，并分配一个指定的IP地址。配置文件是分节的，也有局部选项与全体选项之分。</p>
<p>下面是一些重要的声明:</p>
<p>subnet [network_id] netmask [subnet_mask_id]</p>
<pre><code>: 该区块用于指明一个网络地址资源名称。表示这些将用于DHCP的相关选项</code></pre>
<p>range [start_ip_addr] [end_ip_addr]</p>
<pre><code>: 表明地址池里的动态IP地址范围</code></pre>
<p>host [hostname]</p>
<pre><code>: 对主机名下面的DHCP配置，里面通常有hardware,fixed-address等参数</code></pre>
<p>filename [boot_file_path]</p>
<pre><code>: 从网络启动时的文件的名称</code></pre>
<p>最后是一些选项:</p>
<table>
<tbody>
<tr class="odd">
<td align="left">subnet-mask</td>
<td align="left">为客户端设定子网掩码</td>
</tr>
<tr class="even">
<td align="left">domain-name</td>
<td align="left">为客户端指定域名</td>
</tr>
<tr class="odd">
<td align="left">domain-name-servers</td>
<td align="left">为客户端指明DNS的IP地址</td>
</tr>
<tr class="even">
<td align="left">host-name</td>
<td align="left">指定客户端的主机名</td>
</tr>
<tr class="odd">
<td align="left">routers</td>
<td align="left">指定客户端的默认网关</td>
</tr>
<tr class="even">
<td align="left">broadcast-address</td>
<td align="left">指定客户端的广播地址</td>
</tr>
<tr class="odd">
<td align="left">ntp-server</td>
<td align="left">客户端的时间服务器地址</td>
</tr>
<tr class="even">
<td align="left">time-offset</td>
<td align="left">客户端与格林威治时间的偏移(时区)，以秒为单位</td>
</tr>
</tbody>
</table>
<p><code>/var/lib/dhcpd/dhcpd.leases</code>里面保存一系列的租约声明(包括有客户端的主机名等等信息)。</p>
<p>启动的时候按照一般的daemon进行就可以了。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/03/30/套接字编程/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/03/30/套接字编程/" itemprop="url">
                  套接字的基本概念与编程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-03-30T00:00:00+08:00">
                2013-03-30
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:50:05+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/" itemprop="url" rel="index">
                    <span itemprop="name">计算机网络</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机网络/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2013/03/30/套接字编程/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2013/03/30/套接字编程/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>笔记说明： 本笔记属于linux程序设计第四版。第15章关于套接字的内容。貌似之前对于TCP的工作方式有些误解。现在了解了套接字之后才开始明白自己错在哪里了。</p>
<p>套接字是一种通信机制。在这种机制下面C/S系统的开发工作即可以在本地单位工作，也可以跨网络进行。</p>
<p>这个定义并不确切的原因是我从Windows下面开始接触。把UNIX套接字与网络套接字放在一起的做法还是觉得难以接受。毕竟在用途上相差太多了。但是我想事物自有它存在的道理吧。虽然我们都想给用的十分普遍的事物起一个恰当的名称，但是很多时候是不能如愿的。套接字服务就是这样。我们不知道它们可以用到哪些方面，只是觉得它是一种通信方法，至于为什么要这么设计，就不清楚了。</p>
<h3 id="套接字的创建过程">套接字的创建过程</h3>
<p>首先服务器使用系统调用socket来创建一个套接字。它是一个系统分配给该服务器进程的一个类似于文件描述符的资源，它不能与其他进程共享。</p>
<p>在实现当中由于都是文件，所以套接字实际上相当于创建一个特殊文件并打开它，这与虚拟设备文件从创建到使用是一个道理。</p>
<p>其中，本地套接字是linux文件系统当中的文件名。一般放在/tmp目录下面。对于网络套接字，则是与客户连接的特定网络有关的服务标识符（端口号或者访问点）。这个标识符允许我们进入针对特殊端口号的连接转到正确的服务器进程。</p>
<p>系统调用bind用于给套接字命名。然后服务器进程就开始等待客户连接这个命名的套接字。系统调用listen的作用是创建一个队列并将其用于存放来自客户的进入连接。服务器通过accept系统调用来接受客户连接。</p>
<p>当服务器调用accept的时候，它就会创建一个与原来的命名套接字不同的新的套接字。这个新的套接字只用于同这个客户进行通信。而命名套接字则留下来继续处理来自其它客户的连接。一旦连接建立，我们就可以像底层的文件描述符一样利用套接字实现双向通信。</p>
<p>第二次创建新的套接字是自己以前没有想到的。现在想来，大概在网络环境下创建套接字的时候，由套接字函数库对于连接进行了封装，以致于在服务器调用accept的时候，只能得到连接到它的套接字，这也就是说，在内核当中已经处理好来自不同IP+PORT的请求。从而自己实现了数据的分流，最后才把数据交到socket函数库。</p>
<p>创建一个套接字的函数原型是：</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int socket(int domain, int type, int protocol);</div></pre></td></tr></table></figure>
<p>其中domain是套接字的类型，它可以是AF_UNIX,AF_INET,AF_INTE6,AF_IPX,AF_PACKET等等。type则是套接字的封包格式，比如SOCK_STREAM,SOCK_DGRAM,SOCK_RAW等。我们使用的IP中TCP封包格式为AF_INET加SOCK_STREAM.而UNIX套接字则选择AF_UNIX加SOCK_STREAM.最后一个protocol通常取0.而返回的整型值是套接字描述符。</p>
<p>绑定一个套接字的函数原型是：</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</div></pre></td></tr></table></figure>
<p>函数的作用是将一个名称与套接字相绑定。之所以要进行绑定，是因为刚开始创建套接字的时候只是指定了在套接字命名空间中注册了这个事物。但是还没有被注册到一个确定的地址。所以我们通过bind函数向该套接字命名。名称由结构体addr指定，后面的addrlen是结构体的长度。在sockaddr当中，包含有关于套接字的一系列说明。</p>
<p>连接一个套接字的函数原型是：</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);</div></pre></td></tr></table></figure>
<p>其中的各项参数应当与前面所创建的套接字相匹配。返回动作的状态。</p>
<p>接受一个套接字的函数原型是：</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/socket.h&gt;</div><div class="line">int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);</div></pre></td></tr></table></figure>
<p>它返回一个新的针对于该客户端的套接字。</p>
<p>之后对套接字的读写使用read,write或者close调用就可以了。（因为套接字描述符属于文件描述符。）</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/03/18/library-lapack/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/03/18/library-lapack/" itemprop="url">
                  Lapack矩阵运算库
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-03-18T00:00:00+08:00">
                2013-03-18
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T19:24:45+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/科学计算/" itemprop="url" rel="index">
                    <span itemprop="name">科学计算</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2013/03/18/library-lapack/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2013/03/18/library-lapack/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>所打印的《the lapacke interface to lapack》原来来自于大二时候学习使用LAPACK软件包，但是FORTRAN语言本身又比较复杂，因而寻找一个外在的接口函数库而找到的。不过事实上它没有发挥过什么作用，仅仅被看过一遍就被遗忘在角落里面了。现在为了把无用的东西都扔掉，整理一本笔记。</p>
<p>lapack原来是用FORTRAN语言写成的，后来C语言得到了广泛的应用，所以创建了面向C语言的接口，尽管可能完全重写更有可能得到更高的效率。于是到现在我们就得为了使用lapack而学习如何使用接口。</p>
<p>面向C语言的接口还分成两个层次。对于开发者来说，两个层次的最重要的区别是内存管理是否需要手工进行，对于调用者来说，则转化成命名的前缀与后缀的问题。其实较低级的程序员一直都很难避免陷于各种移植，各种前缀当中。</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2013/03/18/library-lapack/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/03/03/service-cups/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/03/03/service-cups/" itemprop="url">
                  cups打印服务介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-03-03T00:00:00+08:00">
                2013-03-03
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T19:18:02+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2013/03/03/service-cups/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2013/03/03/service-cups/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <p>摘自鸟哥的linux私房菜基础篇，来源自第二十一章，除此之外也参考了cups的官方手册。</p>
<p>发行版一般自带了相关的配置工具，不过随着unix上服务的标准化，现在unix的打印服务都只需要cups来管理了。现在新版的发行版，都是由cups负责打印。</p>
<p>unix上的打印一个是本地打印，另一个是网络打印。unix的支持都是很好的，并且都能通过cups简单地完成。</p>
<h2 id="unix打印支持">unix打印支持</h2>
<p>要使用打印机，不仅要BIOS的支持，而且还需要unix系统的支持。其中的原因是，老式的打印机使用的是25针串口，此接口必须的BIOS中设为开启状态。至于系统，则是打印机制造商得提供相应的打印机驱动，unix才能使用该型号的打印机。</p>
<p>HP打印机对unix的支持程度很好，所以多选择HP品牌的打印机。</p>
<p>系统对于打印机的支持情况可以参考&lt;www.linuxfoundation.org/en/OpenPrinting&gt;里面的一个支持列表。</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2013/03/03/service-cups/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/02/17/Linux-Log/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/02/17/Linux-Log/" itemprop="url">
                  Linux下的日志记录及其策略
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-02-17T00:00:00+08:00">
                2013-02-17
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:49:02+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/系统管理/" itemprop="url" rel="index">
                    <span itemprop="name">系统管理</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2013/02/17/Linux-Log/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2013/02/17/Linux-Log/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本章标题是《系统日志与系统文件》。因为日志在系统当中的确占有非常重的地位。原来自己没有接触过关于syslog与logrotate等工具，所以在查看日志的时候用的只是非常基本的功能。但是按照自己的需求。以后自己也要学习更多的日志分析技巧，如果要学习网络的话。</p>
<p>日志通常如一条一条的概要，由某个应用程序产生并提交到特定的日志系统去处理。有的日志系统比较简单，或是由应用程序服务自动管理。但是更多的时候，需要在系统范围内才能分析出日志包含的重要信息。</p>
<p>日志文件因为它所反映的信息类型的不同而不同。因此需要各自对待。</p>
<p>虽然在操作系统编程与应用程序编程，或者网络编程中也常用到日志，但是日志的最核心的功能还是在于为系统或者应用管理员提供足够的信息，以便支持某种决策。这样一来，在编程中使用的日志只是提供一种基础设施。只在站在系统管理的水平上，我们才能利用好日志记录。</p>
<h3 id="几种对待日志的策略">几种对待日志的策略</h3>
<p>一般情况下应用程序已经配置好所产生的日志级别。一旦日志产生就进入到日志管理这一主题之下。通常情况下，日志可以分成保存的日志与立即的日志。后者又有立即扔掉与在内存区域中缓存，或者在终端上显示。前者则可以选择转发到另一地点或者在本地保存。</p>
<p>计算机管理系统环境下，一般产生意义的动作只是立刻扔掉，或者定期复位，或者采取轮换，或者将日志压缩或保存到永久介质上。它们的不同完全可以由日志信息存在与时间的函数关系决定：前者总是取零，定期复位使得可追溯的日志像周期函数一样变化；轮换则是一个单调递增，而后保持不变的函数；后者则是一个不断增加的函数。</p>
<p>在unix下无论何种方案，都必须采用cron自动维护日志文件。</p>
<h3 id="关于扔掉日志">关于扔掉日志</h3>
<p>一般来说不应当扔掉所有的日志信息。因为日志文件首先为站点提供了非法入侵的重要证据。其次还有助于分析有关硬件或者软件方面的问题。《手册》中给出的意见是所有日志到少保存一个月的时间。特别是站点环境下，可能需要很长时间才能发现入侵。此时需要退回很长时间才可以找到入侵时间。并且还需要以压缩形式保存更长时间的日志。</p>
<p>不过有些时候保存日志的策略有一定的政治，法律或者商业上的原因。这就得具体问题具体分析了。不过留下日志总能够提供某种分析手段，至少能够使得对事物的认识更加具体。</p>
<h3 id="轮换日志文件">轮换日志文件</h3>
<p>这种做法通常是把每周或者每月的日志信息保留在一个单独文件里，就像维护一个长度有限的队列一样。</p>
<p>对于一个日志文件来说，其属主通常很重要，决定着日志管理时的权限使用。日志文件的命名可以使用序号区分，也可以使用日期。在unix上可以通过date命令的+%Y.%m.%d 格式就是通常的做法。</p>
<p>在轮换日志的时候可能会遇到日志正在使用的情况。这种情况下正在使用的日志文件会因为文件位置的改变而自动改变。通常的解决办法是在移动日志后重新启动守护进程，以让守护进程使用新的，空白的日志文件。</p>
<p>比如向syslogd发送HUP信号就会导至syslogd守护进程挂起然后重新读取日志。</p>
<h3 id="存档日志文件">存档日志文件</h3>
<p>“除非就是要避免留下书面记录，否则就应该在常规备份中包含日志文件”。并且在转储频度允许的情况下以最高频度备份日志文件。此外。我们可以为日志文件专门设计一个备份脚本以直接对日志备份进行控制。</p>
<h3 id="linux日志文件">linux日志文件</h3>
<p>linux系统的软件包一般将其日志记录到/var/log下的文件里。</p>
<p>/var目录是相当重要的。在正常运行的系统里应该都存在。因为里面还会随时写入很多信息，因此应当以读写方式挂载文件系统。</p>
<p>linux下大多数程序将其日志发送到syslog中央系统。由syslog负责将日志写入文件或者进行转发。总之，应用程序只需要把产生的日志信息提交到syslog就可以了。</p>
<p>日志权限需要管理员仔细衡量。这些权限中查看权限或许最为关键。一般而言黑客会特别照顾日志文件。大多数文件因此应当设置成权限600.</p>
<p>/var目录应当是所有用户都有权限访问的。但是用户不能在/var下删除log/目录。用户查看log/里面的内容也是允许的。但是用户不一定能查看具体某个应用程序的日志。</p>
<p>专门为日志文件建立一个组，以使得组里的其它成员有查看它的权限也是不错的。注意这里只是说日志属于某个组，而不是日志属于某个特殊用户。一个用户可以属于多个组，通常从组中得到的权限是各个组之和。</p>
<p>从一个具体的应用程序到日志文件的过程大致是，应用程序首先得使用syslog程序，这样以来就可以把日志提交到syslog系统。这一过程中得保证运行应用程序的当前用户或者进程有向syslog提交日志的权利。然后就是由syslog负责整理日志了。由于syslog是以root的身份执行，因此它总能创建出日志文件，后续的行为只需要chgrp命令修改日志所属组就可以了。特别是修改日志文件所属组的行为可以通过syslog完成。</p>
<h2 id="系统日志的层次安排">系统日志的层次安排</h2>
<p>/var/log下的常见日志</p>
<p>一般来说secure,auth.log与sudo.log文件都不应当由一般用户查看。除了读限制，应当禁止除了属主外的任何人对日志文件的写权限。</p>
<p>一般来说：</p>
<table>
<tbody>
<tr class="odd">
<td align="left">auth.log</td>
<td align="left">由su等程序产生，负责授权</td>
</tr>
<tr class="even">
<td align="left">boot.log</td>
<td align="left">系统启动脚本的输出</td>
</tr>
<tr class="odd">
<td align="left">boot.msg</td>
<td align="left">内核消息缓冲的存储</td>
</tr>
<tr class="even">
<td align="left">cron</td>
<td align="left">cron的执行情况与出错信息</td>
</tr>
<tr class="odd">
<td align="left">cups</td>
<td align="left">与打印有关的信息</td>
</tr>
<tr class="even">
<td align="left">daemon.log</td>
<td align="left">所有与守护进程相关的信息</td>
</tr>
<tr class="odd">
<td align="left">debug</td>
<td align="left">调试输出</td>
</tr>
<tr class="even">
<td align="left">dmesg</td>
<td align="left">内核输出消息的缓冲</td>
</tr>
<tr class="odd">
<td align="left">dpkg.log</td>
<td align="left">软件包管理日志</td>
</tr>
<tr class="even">
<td align="left">faillog</td>
<td align="left">不成功的登录企图</td>
</tr>
<tr class="odd">
<td align="left">messages</td>
<td align="left">经常是系统日志文件</td>
</tr>
<tr class="even">
<td align="left">secure</td>
<td align="left">sshd,sudo等，保密的授权信息</td>
</tr>
<tr class="odd">
<td align="left">syslog</td>
<td align="left">主要的系统日志文件</td>
</tr>
<tr class="even">
<td align="left">warn</td>
<td align="left">所有的警告级与出错级消息</td>
</tr>
<tr class="odd">
<td align="left">wtmp</td>
<td align="left">二进制记录的所有登录记录</td>
</tr>
<tr class="even">
<td align="left">yum.log</td>
<td align="left">软件包管理日志</td>
</tr>
</tbody>
</table>
<p>具体文件因系统不同而有差异，并且因使用的系统日志守护进程的不同而有异。</p>
<h3 id="内核和启动日志">内核和启动日志</h3>
<p>内核的日志机制是通过让内核把它的日志项保存在一个大小有限的内部缓冲区来做到的。缓冲区具有适当的大小，既足以容纳内核引导是产生的所有消息，又要节省内存用量。一旦系统启动完成，用户进程应当能够访问内核的日志缓冲，最终处理其内容。各个发行版本一般使用dmesg命令并将其输出重定向到/var/log/dmesg.（因发行版而异）。</p>
<p>内核当前运行的日志是通过klogd内核线程处理的。在正常运行方式下，klogd将内核产生的日志发送到一个文件或者syslog守护进程。一般情况下syslog依照kern中的规则处理这些日志，并将其发送到/var/log/messages文件。</p>
<p>dmesg与klogd都有一个选项可以设置内核控制台的日志级别。这实际上是同内核进行对话。如dmesg就使用了-n选项。内核的日志级别分为7级（第7级称为调试级，输出最多）。</p>
<p>启动脚本的日志可以没有内核日志机制做得好。</p>
<h2 id="日志管理与分析工具">日志管理与分析工具</h2>
<h3 id="logrotate">logrotate</h3>
<p>logrotate用于管理日志文件，它的基本功能也就是作为一个过护进程，定期检测日志文件并对日志文件进行转储的操作。一般情况下在/etc/cron.daily下都可以发现logrotate这一个文件。也就是logrotate的计划任务。</p>
<p>原则上说logrotate应该在syslog之后讲述。不过我们可以把logrotate仅看成是一个定期分隔文件的程序而不去管它分隔的是怎样的文件类型，这才是它的功能的完整的应用领域。</p>
<p>前面我们说了logrotate在cron.daily下面定期运行。实际上在crontab中运行它的命令以及参数是</p>
<figure class="highlight plain"><figcaption><span>.shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">/usr/bin/logrotate /etc/logrotate.conf 2&gt;&amp;1 | tee $TMPF</div></pre></td></tr></table></figure>
<p>所以我们知道它的功能是读取logrotate.conf文件并执行。</p>
<p>在该crontab文件下还执行的功能是，如果logrotate异常退出，就向syslog发送一个logrotate运行失败的cron.warning消息。</p>
<p>所以接下来就要学习logrotate.conf的配置了。</p>
<p>logrotate的主配置文件是logrotate.conf,但是在该文件中有一条命令是</p>
<figure class="highlight plain"><figcaption><span>.shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">include /etc/logrotate.d</div></pre></td></tr></table></figure>
<p>所以在目录下才是针对每个程序的配置。主配置文件一般参考logrotate(8)。</p>
<p>针对某些文件的配置格式为：</p>
<figure class="highlight plain"><figcaption><span>.shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$&#123;path_match&#125; &#123;</div><div class="line">    $&#123;rotate_command_list&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>表示对某一个配置文件执行哪些操作。</p>
<p>实在不想再学习logrotate的配置文件了。又得学习一种配置语言。想写的时候参考实时手册页就可以了。</p>
<h2 id="syslog日志分发程序">syslog日志分发程序</h2>
<h3 id="系统事件日志程序">系统事件日志程序</h3>
<p>syslog最初是由Eric Allman编写的一个综合日志记录系统。syslog具有两个重要的特性。首先它能让消息按照其来源和严重级别排序；其次是能够把消息送到各种目的地，包括日志文件，用户终端，甚至是其它计算机。这给予syslog以极大的灵活性。</p>
<p>尽管如此syslog也有一些缺点。所以已经开发出几种替代方案。比如syslog-ng.以及圣地亚哥超级计算中心的sdscsyslog.除此之外，SUSE上使用的是rsyslog.</p>
<h3 id="syslog的体系结构">syslog的体系结构</h3>
<p>syslog由三个部分组成。其一是syslog守护进程，其二是库调用，其三是logger提交日志的命令。</p>
<p>syslog在系统启动后连续运行。懂得syslog的应用程序把日志发送到/dev/log文件，然后由syslog守护进程读取消自息并根据配置文件分发信息到目的地。syslog接受挂起信号并解释为重新打开配置文件；同时接受TERM信号并使守护进程退出。</p>
<p>syslog守护进程还会把它的进程PID写入到/var/run/syslogd.pid文件里。这使得向它发送信号变得比较容易，如： kill -HUP $(/bin/cat /var/run/syslogd.pid)</p>
<p>因为logrotate就经常要求syslog重新读取相关的日志文件。</p>
<p>守护进程使用/etc/syslog.conf配置文件。</p>
<p>其它的syslog程序通常也支持类似于syslog.conf配置文件里的语法。</p>
<p>配置文件的基本格式是：</p>
<figure class="highlight plain"><figcaption><span>.shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$selector   $action</div></pre></td></tr></table></figure>
<p>其中<code>$selector</code>的基本格式为<code>$facility.$level</code>.表示的含义是属于这一类别的某个等级的日志将会采取<code>$action</code>所指定的行为处理。<code>$facility</code>与<code>$level</code>都是由syslog规定好了的取值范围。一般情况下，比如cron代表来自cron的日志，daemon代表来自系统守护进程，而kern代表来自内核，local0-7代表来自本地的8种类型，user代表来自用户进程，syslog代表syslog内部消息。级别从低到高依次是debug, info, notice, warning, err, crit, alert, emerg.这些级别的具体含义由用户安排。</p>
<p>facility支持使用星号通配。</p>
<p><code>$action</code>可以是一个本地文件名，或者<code>@hostname</code>,或者<code>@ip</code>,或者用户列表，或者<code>fifoname</code>,或者<code>*(代表所有用户)</code>。在<code>$action</code>前面加一个短划线代表写入文件后不执行sync命令。syslog对待一条日志的行为类似于一个匹配器。前面说到<code>$selector</code>的格式。实际上syslogd还支持语法糖的形式，允许一条匹配应用多个规则。分号表示取并区间。</p>
<p>具体来说<code>$f.$l</code>表示<code>$l</code>及以上，<code>$f.=$l</code>表示只匹配该级别， <code>s1;s2</code>表示选择器取并，在s1及s2之间。</p>
<p>syslog守护进程在启动时默认是不接收其它机器的消息的，除非是以-r选项启动的。并且syslog如果从网络接收到一条日志，无论符合哪一<code>$selector</code>都不会转发，除非使用了-h选项。开机时候的syslog选项可以从/etc/init.d/syslog里配置。</p>
<h3 id="站点设计方案">站点设计方案</h3>
<p>在一个小型站点中重要的系统错误和警告保存在每台计算机的文件当中就可以了。但是在在个大型的网络中必须有中央日志记录。有了中央日志记录的话，大量的日志信息就会处于可管理的状态，而且运气好的话还能使破坏计算机安全的人无法访问到审计数据。（这要求站点级的防火墙禁止从外部向syslog提交信息。）</p>
<p>一般来说选择一台稳定的机器作为日志记录服务器，并且最好有很好的安全措施而且登录用户不多的一台机器。其他的计算机可以使用保存在中央主机上的通用配置文件。这样一来只需要维护两份不同的syslog.conf文件。</p>
<p>syslog服务器应当具有足够的安全性。其安全性可通过防火墙对于连接的控制，以及系统管理员访问的途径体现。</p>
<h3 id="syslog应用">syslog应用</h3>
<p>有许多程序或守护进程使用了syslog系统。并且通过logger命令，一般脚本也可以向syslog发送某些信息。如果要了解可详细的信息，可能需要查找POSIX相关规范。</p>
<p>logger的通常用法是</p>
<figure class="highlight plain"><figcaption><span>.shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">logger -p $selector &quot;$&#123;messages&#125;&quot;</div></pre></td></tr></table></figure>
<p>该命令可以用于调试syslog.方法是先在配置文件中添加一个指令选择器的地址，然后使用logger向该选择器写入指定的信息。</p>
<p>在应用的时候都忽略了权限的问题。但是我们应该知道让任何人都有发送日志的权利也是不应该的。</p>
<h2 id="日志分析工具">日志分析工具</h2>
<p>比如swatch, logcheck, logwatch.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/02/17/周期性进程与crontab/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/02/17/周期性进程与crontab/" itemprop="url">
                  周期性进程与crontab
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-02-17T00:00:00+08:00">
                2013-02-17
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:49:15+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2013/02/17/周期性进程与crontab/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2013/02/17/周期性进程与crontab/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>周期性进程这一部分的内容需要很多的实践才能看出来。所以这里也就仅仅是学习周期性进程的管理方式，做一个理论上的理解。实际以后当然还是需要很多的锻练的。</p>
<p>系统管理员应当让更多的任务能够自动完成以减轻系统管理的压力。为此应当选择适当的辅助工具。首先是能提高管理效率的系统命令。比如使用adduser来代替手动向系统中添加用户。其次是使用各种各样的自动脚本完成管理任务。这种情况下就要建立所谓的系统管理工具集或脚本集之类的工具了。然后我们也应该使用自动运行或者计划任务，以让我们有一个充分的休息机会，让那些经常重复的工作变成计算机自动会完成的工作。</p>
<h3 id="关于cron工具">关于cron工具</h3>
<!--unix系统里的工具有时根本不能平等看待。像cron这样的工具有时更像是系统的核心功能，因而与ls之类的命令区分很大。-->
<p>unix下周期执行的任务一般由cron这个守护进程来处理。在系统工作的时候它通常都会保持运行。cron在工作的时修读取一个或多个配置文件，并启动sh来完成其中的任务。因此差不多所有能够手工从shell完成的任务都能通过cron完成。</p>
<p>cron最初出现在20世纪70年代的UNIX家族中。linux发行版本所带的cron称为ISC cron或者Vixie-cron.它是由Paul Vixie重写的，并提供了许多新的功能，减少了使用cron遇到的麻烦。</p>
<p>cron的配置文件称为crontab.cron在三个地方查找crontab文件。/var/spool/cron,在SUSE上是/var/spool/cron/tabs./etc/cron.d和/etc/crontab.每个用户的crontab文件都保存在/var/spool/cron目录下，以用户的名称命名。一般每个用户只能有一个crontab文件。cron会使用文件名作为运行命令时所使用的UID.</p>
<p>计划任务需要权限的限制，以使得普通用户多数时候只在其登录期间有对于计算机的使用权限。更多时候，计划任务作为系统管理的手段。</p>
<p>在/etc/cron.d以及/etc/crontab里的文件格式与用户的crontab文件略有不同，因为前者允许以任何身份执行命令。/etc/crontab供系统管理员手工维护，而/etc/cron.d里常存放软件包所需要的crontab项目。</p>
<p>cron启动时检查它的所有配置文件（但cron一般随系统的启动而启动），并把它们保存到内存当中。每一分钟cron就会醒来一次，检查crontab的修改时间，并重新载入有修改的文件。然后在返回睡眠状态前执行这一分钟安排要执行的所有任务。</p>
<p>cron通过syslog为它的活动做日志。</p>
<h2 id="crontab文件的格式">crontab文件的格式</h2>
<p>crontab文件中以<code>#</code>开头的行代表注释。每个非注释行包括6或7个字段，它代表的含义为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">minute hour day month weekday [username] command</div></pre></td></tr></table></figure>
<p>前六个字段都会用空白分开，但是到了command后，所有空格都算在command里面。用户自己的crontab文件中没有username项。</p>
<p>日期与时间格式会在很多地方用到，所以得有一个全局的思维才行。一般来说，首等应清楚表示的区间在一天以内还是一个比较长的日期。其次要确定所表示的地区。另外就是从大到小还是从小到大。我们可以这样进行分类：</p>
<ol style="list-style-type: decimal">
<li>时间内有时分秒，表达一天内的时间。次要的标准有时辰，早中晚等；</li>
<li>日期内有年月日。次要的还有星期，公元；</li>
<li>时区则是要遵守国际相关的规范了；</li>
<li>按表示顺序，有从大到小，也有从小到大，crontab里就是从小到大。</li>
</ol>
<p>crontab每的时间字段中可以采用数值表示，可以使用通配符，可以用逗号，也可以用范围，表示的是“或”的关系。因为cron的含义即是这一分钟要不要运行该程序。crontab中的命令可以使用百分号作为换行。不过为了简便，用一个shell命令还是很好的。</p>
<p>更多细节见手册页crontab(5).</p>
<h3 id="crontab的管理">crontab的管理</h3>
<p>crontab filename用于把文件安装为crontab文件。它将替换用户原来的版本。更多的用法参考crontab命令帮助。</p>
<p>特别提醒的是，直接使用crontab命令将会要求用户输入crontab.如果这时使用C-D会覆盖掉原来的配置。因此一般要使用C-C来终止crontab程序，以免用户覆盖。</p>
<p>/etc/cron.allow与/etc/cron.deny这两个配置文件用于限制用户提交crontab文件的权限。有allow的时候先通过allow里的用户，未通过则禁止用户登录。无allow文件时查deny里的用户。如果都没有，就会采用cron默认的设置。在大多数系统下，默认只允许root提交crontab.因此既不在allow又不在deny里的用户会被禁止提交crontab文件。</p>
<p>cron的这种设置与acl还不同。在acl中，中间过程只有肯定权，没有否定权。</p>
<p>分析crontab程序的权限也比较有意思。可以知道它是一个setuid的程序。实际运行的时候用户是root.</p>
<p>为了方便管理，通常还在/etc下建立了cron.daily,cron.weekly等脚本。里面的文件会自动每天或者每周运行一次（只需写好相应命令即可）。</p>
<h3 id="cron的通常用法">cron的通常用法</h3>
<p>使用cron非常要求对系统有某种程度的理解。在unix下文件的删除工作往往得自己完成。此外，在网络环境中分发配置文件也常通过cron完成。然后，有些日志文件得自己完成分割。</p>
<h3 id="其它日程安排程序">其它日程安排程序</h3>
<p>其实日程安排要比日程安排程序更好理解一些。一个好的日程安排程序关键是能不能表达日程安排的某种逻辑。相关的替代软件有anacron和fcron等。</p>
<h3 id="日程安排思考">日程安排思考</h3>
<p>计划任务在Windows下是和开机启动混合在一起的。但是unix经常很长时间不关机的，于是就采用了开机脚本和计划任务相分隔的做法。不过因为cron守护进程一直在运行，用户当然也能够很容易地编写一个脚本运行相关的任务。比如使用一个咨询文件就可以办到只在开机的时候运行一次。我们很显然能发现。一旦计划任务程序开始运行，只要相关的脚本能根据系统状态作出某种反应，把日程安排改造成开机启动也不是一件困难的事。</p>
<h2 id="习题与思考">习题与思考</h2>
<p>在此次学习中，我们并没有接触到cron的配置。因此关于性能的很多问题都没有涉及到。实际上如果同一网络多台主机同时运行cron时可能会造成一些问题。所以建议cron通过调用脚本间接调用程序。而脚本里有诸如sleep 5这样的代码。</p>
<h3 id="关于管理crontab的权限">关于管理crontab的权限</h3>
<p>一般来说一个用户因为使用不合理的crontab文件。系统管理员应当删除其crontab文件并禁止它的crontab权限。</p>
<p>盲目地复制一个文件夹下以.开头的文件安全么</p>
<p>这个当然是不安全的。一个目录的inode里包含自己和它的父目录。如果我们这样复制文件，就会使得所复制的文件追溯到它的同级目录里。</p>
<p>系统分析的一个应用</p>
<p>cron经常会和邮件系统结合在一起。除了在完成计划任务时把输出发到用户的邮箱，它还可以让用户自己通过shell发送自己感兴趣的内容。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/01/05/Linux-Daemon/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/01/05/Linux-Daemon/" itemprop="url">
                  linux下的守护进程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-01-05T00:00:00+08:00">
                2013-01-05
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T19:25:19+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2013/01/05/Linux-Daemon/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2013/01/05/Linux-Daemon/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h2 id="守护进程的一般概念">守护进程的一般概念</h2>
<p><strong>系统提供某某服务，而提供服务的进程称为是守护进程</strong>（用英文说一个是service, 一个是daemon.）</p>
<p>也就是说从操作系统的观点来看，是守护进程，从IP网络的概念来看是服务。从应用的角度来看是服务。</p>
<p>也许可以把守护进程看成是一种持续监听某个端口的应用程序。这样以来它就总能够提供某种服务，也就不必是系统进程。也不必非是以root身份运行的程序。</p>
<p>unix下的守护进程分为独立守护进程与超级守护进程。在英文中一个是standalone daemon,一个是super daemon.如果一个守护进程的作用是管理其它的守护进程，那么它就超级守护进程。这种分类方法更倾向于在功能上对守护进程进行分类，是一个静态的概念。而根据运行方式的不同分成独立运行方式，与被管运行方式。</p>
<p>被超级进程所管理的守护进程称为被管守护进程。其执行的原理是，超级守护进程常驻内存，当有某个端口的连接操作的时候根据配置启动某个守护进程处理连接请求。超级守护进程特点是统一管理连接，而运行起来的速度比较慢，因为一次连接之后往往要求被管守护进程退出运行。</p>
          <!--noindex-->
          <div class="post-more-link text-center">
            <a class="btn" href="/2013/01/05/Linux-Daemon/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2013/01/02/正则表达式/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2013/01/02/正则表达式/" itemprop="url">
                  正则表达式实践
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2013-01-02T00:00:00+08:00">
                2013-01-02
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:48:29+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机科学/" itemprop="url" rel="index">
                    <span itemprop="name">计算机科学</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/计算机科学/编程/" itemprop="url" rel="index">
                    <span itemprop="name">编程</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2013/01/02/正则表达式/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2013/01/02/正则表达式/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本部分内容摘抄自原来的linux笔记第三册，而原来的笔记实质是一本书的内容。书名忘了记了，反正是很详细的一本介绍正则表达式的书。在此对于作者的工作表示敬意以及歉意。</p>
<h2 id="正则表达式的科班史">正则表达式的科班史</h2>
<p>正则表达式发源于与计算机密切的两个领域，计算理论和形式语言。20世纪40年代两位神经生理学家Warren McCulloch和Walter Pitts研究出一种数学方式来描述神经网络的方法，它们把神经系统中的神经元描述成小而简单的自动控制单元。1956年数学家Stephen Cole Klenne在他们的研究的基础上发表了一篇名为《神经网络表示法》的论文，在其中，他们采取了一些称之为“正则集合”的数学符号来描述神经网络模型。</p>
<p>这个书上说的就自相矛盾了，无论怎样，神经元的研究也不能说是一开始就和计算机领域是密切相关的</p>
<p>之后UNIX的主要发明人Ken Thompson将这个符号系统引入了文本编辑器QED.正则表达式由此进入计算机的世界。之后Ken Thompson又将正则表达式引入了unix下的文本编辑器ed.ed最终演化为大家熟悉的grep.因为grep得名自ed中的正则表达式搜索命令<code>g/re/p</code>.</p>
<p>这个又说明了一个问题。不知道Ken Thompson对于神经网络是怎样了解的，还是说这个时候已经产生了编译原理的相关的理论了。但是可以确定的是，Ken Thompson肯定知识面非常地广。看编译原理或许也不会知道正则表达式是何时进入高级语言的。</p>
<h3 id="正则表达式的一些感概">正则表达式的一些感概</h3>
<p>这篇是在原笔记中出现的，所以在注释当中又加了一些笔记，使得一些知识能够反映当前的认识的水平。</p>
<p>正则表达式应用中分为几个版本。各个版本对正则表达式的实现都不能说是尽善尽美。尤其是对于中文的支持并不是十分完善。而且关键是各个正则表达式中常含有不同的转义表示符，这使得在形式上它们并不相同，虽然对应于同一个正则表达式的理论。</p>
<p>所以在一个正则表达式工具当中：</p>
<p>正则表达式语法＝正则表达式理论＋工具实现的部分功能＋工具的转义符系统</p>
<p>原来通配符也是正则表达式的一种，只不过以前在windows下从来没有人说它与正则表达式的关联，所以当首次听说Perl的时候，觉得正则表达式是一个很神秘的东西。</p>
<p>实际上在linux的bash的学习当中，也没有人说通配符就代表了正则表达式。</p>
<p>从现在来看通配符作为所谓的正则表达式的一个子集。以前还一直以为通配符来自于工业的背景，所以通配符和正则表达式的关系是后来发展中才被发现的。这导致我有时以为所谓的通配符是微软的发现。这就叫“无知者无畏”。</p>
<p>正则表达式用于称作“模式匹配”的领域。正则表达式被应用的时候，可以提供三个方面的功能：判断，选择，替换。三个功能当然是逐层递进的。“判断”是指在一段文本当中能不能找到正则表达式匹配的模式，“选择”是说，如果有这样一个模式，将从符合模式的几个子串当中选择哪一个，“替换”是说，对于选定的文本以何种方式替代它。</p>
<p>凡解析一个正则表达式都应当遵守这样的规则。其中的一部分，比如最长匹配原则，就是应用于“选择”时的一个规则。</p>
<p>在正则表达式的模型当中，一个具体的原则指的是一系列共同的前提，和相同体系的抽象。之所以可以进行选择，前提是已经给出了一系列的候选元素可供使用。而进行判断的目的就是得到这些候选元素。</p>
<p>一个正则表达式的特性可完全由这三个方面来描述。判断是基础，替换则是正则表达式语义分析能力的极限。实际应用当中，三个用途成金字塔的形状。不只是因为更高级的应用是建立在低级的应用的基础上，也因为低级的层次确实有不小的用武之地，否则也只能形式正方体结构。</p>
<p>后者的一个典型例子就是计算机网络分层模型。</p>
<p>正则表达式的三个流派，主要不同之处在于元字符的使用规定，本质还是一样的。对PCRE,BRE与ERE流派同时掌握并不是什么困难的事情。大致来说，三者所加的内容有一页左右，还不及对于正则表达式工具的特殊说明。</p>
<h2 id="字符组">字符组</h2>
<p>正则表达式的特点是用变量描述字符串。</p>
<p>也就是说正则表达式可以用变量代表一个字符串。个人理解。</p>
<p>正则表达式使用的时候注意的是，对于大多数字符（普通字符），使用正则表达式匹配的结果和一般的模式匹配应当是相同的（比如经典的KMP匹配算法）。其次是普通字符具有两个含义，一个是它所代表的字符，一个是它所表示的元字符。在编译原理当中可以看到正则表达式中，单个字符匹配，写成的结果以黑体的形式表达出来，表示它相当于一个终结符。</p>
<p>计算机字符在显示给我们看的时候，如果有换行符，就被显示成平面结构，但是对于计算机而言并没有这个概念。我们可以想象计算机看来，字符串本身是ASCII或unicode的一串字符序列。正则表达式匹配的实际上是一个字符序列的某种子序列，不管这些字符是不是控制字符，是不是可见字符，这个完全对于正则表达式的功能没有影响。</p>
<p>因为正则表达式不会接受所匹配的字符串作为正则表达式匹配指令的一部分</p>
<p>字符组是一列字符的集合，正则表达式程序匹配这一列字符当中唯一的一个。正则表达式将其匹配结果表示成一个确定的字符。原则上一个字符组括在一个中括号当中，形如<code>[abcde]</code>的字符组匹配<code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>, <code>e</code>当中的一个。当只有一个的时候退化成一个单一的形式a,它表示的就是匹配字符a.</p>
<p>字符组可以以范围的形式表示，如<code>[\xAA-\xZZ]</code>表示编码为AA的字符到编码为ZZ的字符。</p>
<p>因为正则表达式在一个编码集当中工作，而不是一个字符集。在工作之前，正则表达式工具要能准确识别出一个编码单位。这对于utf-8这类采用变长编码技术的编码方式来说具有十分重要的意义。</p>
<p>-表示连接符号，如果要匹配-这个字符，只能使用转义了。一般来说，对于-的规定是，出现在字符组当中，并且从左到右可被解释为两个字符的连接时有特殊意义，否则按正常字符处理。其实这个符合一个原则，就是正则表达式引擎尝试将其解释为有特殊含义的字符，如果失败就解释为普通字符。因此正则表达式<code>[0-9a-z]</code>是有意义的，因为两个减号都可以被解释成连接。</p>
<p>在编译原理当中出现的正则表达式比在技术当中严格多了，并且是不支持量词的。学习这个正则表达式，就要放下另一个正则表达式体系，虽然可以保留两者的关联。</p>
<p>字符组的第一个字母是<code>^</code>号时代表不匹配里面所列字符当中的任何一个。</p>
<p>尝试用集合的概念理解正则表达式时，字符组首先代表<span class="math inline">\(A=\{a,b,c,d,\cdots \}\)</span>.使用连接符号的时候，相当于添加了很多个字符到A当中：<code>[abc0-2]={a,b,c}+{0,1,2}</code>. 而使用<code>^</code>号的时候代表<code>[\^abc0-2]=P -({a,b,c}+{0,1,2})</code>。</p>
<p>为了更清楚地表达语义，定义<code>\d,\w,\s</code>分别表示数字0-9,单词与数字0-9a-zA-Z,以及空白字符<code>[\t\n\r\v\f]</code>（代表制表，回车，换行，垂直制表，换页）</p>
<h3 id="ascii码值">ASCII码值</h3>
<table>
<thead>
<tr class="header">
<th align="left">二进制</th>
<th align="left">十进制</th>
<th align="left">十六进制</th>
<th align="left">缩写</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">0000 0000</td>
<td align="left">0</td>
<td align="left">0x00</td>
<td align="left">NUL</td>
<td align="left">空字符</td>
</tr>
<tr class="even">
<td align="left">0000 0001</td>
<td align="left">1</td>
<td align="left">0x01</td>
<td align="left">SOH</td>
<td align="left">标题开始</td>
</tr>
<tr class="odd">
<td align="left">0000 0010</td>
<td align="left">2</td>
<td align="left">0x02</td>
<td align="left">STX</td>
<td align="left">本文开始</td>
</tr>
<tr class="even">
<td align="left">0000 0011</td>
<td align="left">3</td>
<td align="left">0x03</td>
<td align="left">ETX</td>
<td align="left">本文结束</td>
</tr>
<tr class="odd">
<td align="left">0000 0100</td>
<td align="left">4</td>
<td align="left">0x04</td>
<td align="left">EOT</td>
<td align="left"></td>
</tr>
<tr class="even">
<td align="left">0000 0101</td>
<td align="left">5</td>
<td align="left">0x05</td>
<td align="left">ENQ</td>
<td align="left">请求发出响应字符，以确认存在</td>
</tr>
<tr class="odd">
<td align="left">0000 0110</td>
<td align="left">6</td>
<td align="left">0x06</td>
<td align="left">ACK</td>
<td align="left">确认回应</td>
</tr>
<tr class="even">
<td align="left">0000 0111</td>
<td align="left">7</td>
<td align="left">0x07</td>
<td align="left">BEL</td>
<td align="left">响铃，要求终端对用户予以提示</td>
</tr>
<tr class="odd">
<td align="left">0000 1000</td>
<td align="left">8</td>
<td align="left">0x08</td>
<td align="left">BS</td>
<td align="left">退格，删除或叠打上一字符</td>
</tr>
<tr class="even">
<td align="left">0000 1001</td>
<td align="left">9</td>
<td align="left">0x09</td>
<td align="left">HT</td>
<td align="left">水平制表符（horizatonal tab）</td>
</tr>
<tr class="odd">
<td align="left">0000 1010</td>
<td align="left">10</td>
<td align="left">0x0A</td>
<td align="left">LF</td>
<td align="left">换行键，实际上是line feed,满行的意思</td>
</tr>
<tr class="even">
<td align="left">0000 1011</td>
<td align="left">11</td>
<td align="left">0x0B</td>
<td align="left">VT</td>
<td align="left">垂直定位符号</td>
</tr>
<tr class="odd">
<td align="left">0000 1100</td>
<td align="left">12</td>
<td align="left">0x0C</td>
<td align="left">FF</td>
<td align="left">换页，form feed,满页</td>
</tr>
<tr class="even">
<td align="left">0000 1101</td>
<td align="left">13</td>
<td align="left">0x0D</td>
<td align="left">CR</td>
<td align="left">回车，用于结束文本行</td>
</tr>
<tr class="odd">
<td align="left">0000 1110</td>
<td align="left">14</td>
<td align="left">0x0E</td>
<td align="left">SO</td>
<td align="left">取消变换，Shift Out</td>
</tr>
<tr class="even">
<td align="left">0000 1111</td>
<td align="left">15</td>
<td align="left">0x0F</td>
<td align="left">SI</td>
<td align="left">启用变换，Shift In</td>
</tr>
<tr class="odd">
<td align="left">0001 0000</td>
<td align="left">16</td>
<td align="left">0x10</td>
<td align="left">DLE</td>
<td align="left">跳出数据通讯</td>
</tr>
<tr class="even">
<td align="left">0001 0001</td>
<td align="left">17</td>
<td align="left">0x11</td>
<td align="left">DC1</td>
<td align="left">设备控制一</td>
</tr>
<tr class="odd">
<td align="left">0001 0010</td>
<td align="left">18</td>
<td align="left">0x12</td>
<td align="left">DC2</td>
<td align="left">设备控制二</td>
</tr>
<tr class="even">
<td align="left">0001 0011</td>
<td align="left">19</td>
<td align="left">0x13</td>
<td align="left">DC3</td>
<td align="left">设备控制三</td>
</tr>
<tr class="odd">
<td align="left">0001 0100</td>
<td align="left">20</td>
<td align="left">0x14</td>
<td align="left">DC4</td>
<td align="left">设备控制四</td>
</tr>
<tr class="even">
<td align="left">0001 0101</td>
<td align="left">21</td>
<td align="left">0x15</td>
<td align="left">NAK</td>
<td align="left">确认失败回应</td>
</tr>
<tr class="odd">
<td align="left">0001 0110</td>
<td align="left">22</td>
<td align="left">0x16</td>
<td align="left">SYN</td>
<td align="left">同步，同步信号</td>
</tr>
<tr class="even">
<td align="left">0001 0111</td>
<td align="left">23</td>
<td align="left">0x17</td>
<td align="left">ETB</td>
<td align="left">区块传输结束</td>
</tr>
<tr class="odd">
<td align="left">0001 1000</td>
<td align="left">24</td>
<td align="left">0x18</td>
<td align="left">CAN</td>
<td align="left">取消</td>
</tr>
<tr class="even">
<td align="left">0001 1001</td>
<td align="left">25</td>
<td align="left">0x19</td>
<td align="left">EM</td>
<td align="left">连接介质中断</td>
</tr>
<tr class="odd">
<td align="left">0001 1010</td>
<td align="left">26</td>
<td align="left">0x1A</td>
<td align="left">SUB</td>
<td align="left">替换</td>
</tr>
<tr class="even">
<td align="left">0001 1011</td>
<td align="left">27</td>
<td align="left">0x1B</td>
<td align="left">ESC</td>
<td align="left">退出键，转义</td>
</tr>
<tr class="odd">
<td align="left">0001 1100</td>
<td align="left">28</td>
<td align="left">0x1C</td>
<td align="left">FS</td>
<td align="left">文件分区符</td>
</tr>
<tr class="even">
<td align="left">0001 1101</td>
<td align="left">29</td>
<td align="left">0x1D</td>
<td align="left">GS</td>
<td align="left">组群分隔符</td>
</tr>
<tr class="odd">
<td align="left">0001 1110</td>
<td align="left">30</td>
<td align="left">0x1E</td>
<td align="left">RS</td>
<td align="left">记录分隔符</td>
</tr>
<tr class="even">
<td align="left">0001 1111</td>
<td align="left">31</td>
<td align="left">0x1F</td>
<td align="left">US</td>
<td align="left">单元分隔符</td>
</tr>
<tr class="odd">
<td align="left">0111 1111</td>
<td align="left">127</td>
<td align="left">0x7F</td>
<td align="left">DEL</td>
<td align="left">删除</td>
</tr>
</tbody>
</table>
<p>在dos系统当中控制符可能被显示为一些有意思的符号，比如SOH被显示为一个笑脸。</p>
<h4 id="如何在键盘上映射控制字符">如何在键盘上映射控制字符</h4>
<p>CTRL键的原意就是把键盘上的字符转成ASCII小64的控制字符。对于小写字母的情况，是比它的ASCII小32的控的字符，所以CTRL+I水平制表，CTRL+J换行。CTRL+M回车。键盘向计算机发出的也是ASCII码值。如果没有相对应的符号，实际是使用的新定义或者是新的控制序列。哑终端常使用控制序列。哑终端是相对于其它聪明的计算机来说，功能较为有限的计算机终端。其含义根据不同的场合而变化。</p>
<p>终端的概念很重要。可以从终端那里知道制表符的意思是移动到某个制表位的地方，然后进行显示。也就是说，显示器等若一个方格。所以在移动的时候就知道TAB键的工作原理了。它在移动的时候，可能的位置是0,4,8,12,…按下tab键的作用就是跳到最近的控制点上。</p>
<p>随着不使用纸张打印，这些字符的含义也有了变化，比如换页在屏幕终端就变成了清屏。由于单个的转义码开始不够用了，所以就有了转义序列。</p>
<p>分隔符和操作系统当中的记录式文件结构有不小的关系吧。介质结速EM的意思是磁带已满。ESC的最初的作用是避免其后的控制字符被控制设备解释。</p>
<p>替换的作用是下个可打印字符以二进制的形式被打印出来</p>
<p>CAN用于取消一个包的传输，NAK要求重传一个数据包。ACK表示包被正确接收。</p>
<p>在半双工通信的环境当中，ENQ从主站发出，表示要求从站发送下条报文，从站发送EOT表示自己完成了传输。</p>
<p>传输设备控制码的意义，可以使得设备之间不需要用到更多的控制线，可通过一条线路上传输ASCII实现传输控制。</p>
<p>DLE表示会话结束，释放线路资源。</p>
<p>编码为0的字符是一个特例，指的是纸带上那些没有穿孔的地方。而DEL的ASCII很特殊是因为它的ASCII全是1,这样一来，没有穿孔的地方就全部变成穿孔的地方了。因为在纸带上遇1表示穿孔，0表示不穿孔。</p>
<p>看来ASCII的解释可以从穿孔纸带，打印机，控制终端，现代终端多个角度。</p>
<p>有一个特别的字符组<code>.</code>号，表示匹配除了换行符<code>\n</code>之外的所有字符一次。</p>
<p>字符组在原则上允许交，并差操作并构成了正则表达式理论上用的比较多的运算。一般来说，并置就是直接连接。这一个功能是都支持的。</p>
<p>字符组总结：在一列集合中选择一个匹配，对字符组允许作否定，连接的操作，一些字符组可以提供范围功能。所以在正则表达式当中关于字符组的基本特性可以总结为以下的几个方面： 1. 如何选择唯一的匹配字符 2. 使用否定的方式选择唯一字符 3. 使用范围的方式选择字符 4. 有没有什么选择特定语义的字符的简记法 5. 建立在字符组上的交并差运算是否支持</p>
<p>运算之后还是一个正则表达式。所以对正则表达式的与或非也应当有所支持。不过这是正则表达式的理论的问题，本笔记并不能涉及到。</p>
<h2 id="量词">量词</h2>
<p>量词用于细化对于字符或者字符组的规定，约束出现的次数。</p>
<p>对于正则表达式而言，每一个子表达式都称为一个模式。量词准确地说是用来表示所匹配的模式所出现的次数。表示的是这样的模式所匹配的文字匹配多少次。</p>
<p>也许用扩展比较合适。正则表达式返回的匹配结果是包含了次数的，也就是返回的是完整的字符串。</p>
<p>量词跟在它所限定的模式的后面，仅作用于前一个最小匹配模式。通用量词用<code>{m,n}</code>来描述。比如<code>(pattern){m,n}</code>表示模式pattern出现<span class="math inline">\(m\)</span>次到<span class="math inline">\(n\)</span>次之间的被匹配。</p>
<p>其实量讯号的使用有两个关键的地方，一个是如何标识它所修饰的单元，另一个是如何传入匹配的量词标识的次数。用符号表示一个是pattern,一个是range.</p>
<p>量词的范围是非负的数值，根据具体语言的不同，0可以省略。</p>
<p>一般来说正则表达式的书写是非常严谨的，不像C语言那样，参数之间可以后跟若干个空格。所以在量词之间也不要加入空格。</p>
<p>有几个常用的量词使用了特殊的元字符表示，<em>表示限定的模式出现0到无穷多次，+表示所限定的模式至少要出现1次，?表示限定的模式至多可以出现1次。需要注意的是模式.</em>在实现上效率还是比较低的，所以应当尽量避免使用。</p>
<p>在通配符体系当中，常有一些表示任意匹配的元字符，比如*,.,?其含义和正则表达式中的含义略微有些区别。</p>
<p>量词如果是一个范围，就可能有多个可以匹配的字符串。</p>
<p>正则表达式进行匹配的结果相当于在一个线性序列当中选择一个范围，这个范围就是所匹配的结果，有了一个这样的匹配，才会知道如何操作指定的子串。</p>
<p>正则表达式匹配的过程可以看成是逐个对应的问题。一个正则表达式提供了特定的信息，其信息的截止长度是到字符串的末尾。所以在匹配正则表达式re的时候，如果匹配从a开始，就从下面的字符串中逐个应用某个模式，如果在某一阶段不能匹配，就进行回溯，至到在不能回溯，而又没有将正则表达式匹配到最后的时候才返回匹配失败。</p>
<p>正则表达式的匹配也可以看成是一个树的匹配。每一个量词就决定了下面有多少个结点可以使用，比如<code>a{3,5}</code>建立的子树就有aaa,aaaa,aaaaa三颗。</p>
<p>量词的优先级问题。量词的优先级的标准是在有多个匹配的时候先匹配尽可能多的字符还是先匹配尽可能少的字符的问题。这个与正则表达式引擎的实现有问题，对于能否匹配不产生影响。忽略优先量词的意思是先匹配少的，匹配优先量词的意思是先匹配尽可能长的字符串。</p>
<p>说到这里正则表达式工作的过程完全就等价于一颗树了。能够到达树的终点说明可以匹配。但是到达树的终点可能有不同的路径，每条路径对应于一个可能的匹配。</p>
<p>实际应用中量词的优先顺序影响的不只是效率，更影响了最长匹配还是最短匹配的问题。如<code>a{3,5}</code>匹配<code>aaaa</code>,如果是匹配优先量词，就是<code>aaaa</code>,但是<code>{m,n}</code>形式的量词是忽略优先量词，所以匹配的结果是aaa(前面的三个a）。</p>
<h2 id="多选分组与捕获">多选，分组与捕获</h2>
<p>多选的意思是在多个可以匹配的模式当中选择其中的一个，其用法是<span class="math inline">\((p1\vert p2)\)</span>. 如果中间没有分隔符，和普通匹配的效果一样。不过多选其实还有一个比较重要的副作用，就是创建模式所匹配字符串的一个拷贝。这可以通过编号引用用在后续的替换当中。分组也是用这的方法，意思是模式作为一个整体。后面所跟的量词都是作用于这样的一个整体。</p>
<p>捕获的目的是提取出符合模式的字符串。PCRE正则表达式当中用括号来表示开始一个捕获。之后可以通过对编号的引用使用它。编号的原则是，按左括号从左到右出现的次序决定相应模式编号的顺序。编号从1开始。如果使用了分组（括号）而不想分组被捕获，则使用语法(?:)来加以说明。</p>
<p>python支持<code>\g&lt;num&gt;</code>与<code>\g&lt;num&gt;</code>形式的引用。</p>
<p>考虑到一般脚本，也支持用<code>$num</code>的形式引用。</p>
<h2 id="断言">断言</h2>
<p>断言的作用是要求所匹配模式前后必须匹配某些特征，但是其匹配不作为匹配返回结果的一部分。断言有很多类型，常见的断言有单词边界，行起始，行结束以及环视。</p>
<p>断言的最一般形式就是环视。另外在正则表达式当中，断言都是跟着所匹配的模式的。比如如果ptwo在正则表达式中作为pone的断言，那么一般来说，其含义是ptwo后的模式正好是pone,中间没有任何其它的成份，或者ptwo前的模式正好是pone,中间没有其它任何成份，换言之，断言是紧跟它所断言的模式的。不会说，在文本某个位置符合了某个断言，但是隔了很长的文本之后，所断言的模式才开始出现。在通常情况下这种分隔的情况也不常用。但是或许在自然语言处理当中很有价值呢。</p>
<p>单词边界顾名思义就是一个模式的两端是单词分隔符，如空格等等。可以作为单词边界的字符构成一个集合，这个集合用字符组<code>\b</code>来表示。</p>
<p>这样一来<code>\b</code>就不一定表示断言，其所匹配的字符也会作为结果的一部分。</p>
<p>单词边界在PCRE当中常见的是<code>\b,\B,\w,\W</code>分别表示其左边是单词(非单词)，右边是单词(非单词)。</p>
<p>这个说明PCRE的规定不太一致，因为<code>\d</code>表示的是一个匹配字符组，而<code>\b</code>却要表示一个断言。</p>
<p>当匹配的内容被视为一个字符串的时候，^被视为文本开始的位置，$被视为文本结束的位置。当匹配的内容被视为段落文本的时候，^被视为每行的开始位置，$被视为每行结束的位置。</p>
<p>不同的语言可能使用不同的符号表达这个语义。</p>
<p>环视的作用是加强对匹配文本模式所在位往置的限制。以所匹配文本的位置看，环视分为顺序环视和逆序环视，也就是匹配模式左端应当符合的模式，以及右端应当符合的模式。</p>
<p>原则上也可以通过捕获分组来实现环视的功能呀，不知道和以这种方式实现环视的功能有效率上的不同没有，还是说，环视在编译原理上和捕获分组一样？</p>
<p>PCRE的环视以下面四种形式实现（两种顺序乘是否）：肯定顺序环视(?=pattern),否定顺序环视(?!pattern)，肯定逆序环视(?&lt;=pattern)，否定逆序环视(?&lt;!pattern).</p>
<h2 id="正则表达式的全局选项">正则表达式的全局选项</h2>
<p>这个是经验的问题，因为为了书写的方便而设立一定的匹配模式，比如忽略大小写的功能。</p>
<p>全局选项实际上也可以作为局部选项而出现，因为它们都是加在一个模式之上的。一般来说。模式主要有：</p>
<table>
<tbody>
<tr class="odd">
<td align="left">忽略大小写模式</td>
<td>在此模式下一个字符可以与它的大写或者小写形式替换，也就是说不再只是代表这个字符，而是相当于包括大写和小写形式的一个分组。</td>
</tr>
<tr class="even">
<td align="left">单行模式</td>
<td>在此模式下，字符串被认为是一体的，点号可以匹配<code>\n</code>.</td>
</tr>
<tr class="odd">
<td align="left">多行模式</td>
<td>在此模式下，<code>^</code>和<code>$</code>分别匹配每一行的开始与结束</td>
</tr>
<tr class="even">
<td align="left">注释模式</td>
<td>在此模式下的正则表达式部分表示一个注释，里面的内容可以自由书写，在表达式较长或者有多行的时候可以提高正则表达式的可读性。</td>
</tr>
</tbody>
</table>
<p>坦白来说，正则表达式本身确实没有什么可读性。</p>
<p>PCRE中在正则表达式内部设置某个模式的时候使用<code>(?modifier)</code>，要取消某个模式的时候使用<code>(?-modifier)</code>。其中<code>i</code>表示忽略大小写，<code>s</code>表示单行模式，<code>m</code>表示多行模式，<code>x</code>表示注释模式。可以多个模式进行嵌套。</p>
<p>注释模式下用<code>#</code>开始一个注释，注释直到行尾。</p>
<p>对于我们来说比较有意义的时一个字符组所表示的真正的含义，所以在忽略大小写模式下，并没有对于匹配字符串的整体造成太大的影响。所以单行模式和多行模式要特别注意。注意的是什么呢，注意的是<code>^</code>与<code>$</code>的含义。</p>
<h2 id="正则表达式工具">正则表达式工具</h2>
<h3 id="sed">sed</h3>
<p>sed命令替换的基本格式是<code>&lt;address&gt;s/&lt;pattern&gt;/&lt;replacement&gt;/&lt;flags&gt;</code></p>
<p>比如<code>s/suff/(&amp;ix)/g</code>用于将suff替换成suffix</p>
<h3 id="sed正则表达式的中文问题">sed正则表达式的中文问题</h3>
<p>linux下unicode正则表达式的匹配情况取决于当前系统的语言环境特别是编码。在一般情况下，元字符这部分直接可以在命令中替换。标准用法是使用<code>\xx</code>转义。</p>
<p><strong>vim中正则表达式</strong></p>
<p>匹配一个中文字符可以使用<code>[^\x00-\xffff]</code>.</p>
<p><strong>sed匹配空行和空格组成的行</strong></p>
<p>删除空行的模式是 <code>/^$/d</code>，</p>
<p>删除由空白字符组成的行的模式是<code>/\s*$/d</code>。</p>
<h3 id="vim当中的正则表达式">VIM当中的正则表达式</h3>
<p><strong>在VIM中使用替换命令的一些情况</strong></p>
<p>没有经验真可拍，稍微有点特殊的情况就得自己猜。</p>
<p>换行符属于一行的行尾，而匹配模式也可以仅仅只有一个位置符号，没有特定字符。总之，正则表达式的结果不过是一个位置范围而已，有时起始位置和结束位置相同也没有什么关系。</p>
<p>比如：</p>
<ol style="list-style-type: decimal">
<li>将行尾的换行符替换成制表符：<code>s/\n/\t/</code>,</li>
</ol>
<p>这说明在正则表达式中支持转义字符</p>
<ol start="2" style="list-style-type: decimal">
<li>在每行之前增加一个制表符： <code>s/^/\t/</code>.</li>
</ol>
<p><strong>正则表达式中对于控制字符的转义</strong></p>
<p>比如<code>%s/\n\([^\t[:alpha:]]\)/\1/g</code>。</p>
<h3 id="grep">grep</h3>
<p>在我的linux笔记中已经提到vi,sed,grep属于BRE流派。并且关于正则表达式的基本概念我们也都已经讲清楚了。在这里主要是如何用具体的工具实现正则表达式强大功能的问题。所以先介绍grep工具。</p>
<p>grep命令的功能就是在一个或者多个文件里搜索一个模式串并输出。和sed等工具相比，不必使用特殊命令（比如sed的s替换命令），因为grep的功能定位就是从文件中搜索模式(grep的名字由来就是g/re/p命令)因为更专业，所以用的时候更简单。而且unix工具的一个特点就是一个工具的功能得到准确的描述，所不同的只是实现的方法问题。</p>
<p>我们好好体会这一点的方式是，我们能够从定义推演出工具的设计思想来。从定义可以知道grep的功能有两个关键词，模式和文件。分别以pattern和file来代表。而向应用程序传递参数的时候又要有相应的选项，所以grep的命令语法是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep options pattern filename(s)</div></pre></td></tr></table></figure>
<p>加上<code>s</code>表示<code>grep</code>可以接受多个文件。</p>
<ol style="list-style-type: decimal">
<li><p>grep可以从标准输入流中搜过一个模式串。 (管道设计unix系统的特殊机制，现在我们知道管道可以看成具有特殊文件描述符的一个对象就行了。只要在程序设计中使用了这个特殊的文件描述符，就能通过管道方式传送数据)</p></li>
<li><p>pattern是一个BRE正则表达式串。但是我们在启动grep程序之前，参数字符串还要经过shell变换处理一下。因而如果字符串比较特殊，还要经过一次shell的转义。一般要用引号括住。</p></li>
</ol>
<p>示例用法：</p>
<p><code class="shell">grep &quot;sales&quot; emp.lst &quot;</code> 在emp.lst文件中搜索具有模式sales的行。输出到标准输出。</p>
<p><code class="shell">grep president emp.lst</code> 同上，搜索的是模式president。</p>
<ol start="3" style="list-style-type: decimal">
<li><p>在grep后面的文件参数中有多个的时候，grep在输出结果每行开头会显示文件名和行号。</p></li>
<li><p>grep参数解析的过程我们可以看成首先试图从argv字符串中读出一个作为pattern，或者通过一个选项给出pattern，如果不能满足，就将参数解释为一个文件名。</p></li>
</ol>
<p><strong>grep的参数解析</strong></p>
<ol start="5" style="list-style-type: decimal">
<li>grep的参数(理解正则表达式失配，grep程序匹配这句话的含义)</li>
</ol>
<table>
<tbody>
<tr class="odd">
<td align="left">-i</td>
<td align="left">不区分字母大小写(ignore case)</td>
</tr>
<tr class="even">
<td align="left">-v</td>
<td align="left">显示不含指定模式的行(invert match,改变匹配模式)</td>
</tr>
<tr class="odd">
<td align="left">-n</td>
<td align="left">显示行号和行内容（默认只显示行内容）（line number）</td>
</tr>
<tr class="even">
<td align="left">-c</td>
<td align="left">显示所匹配模式的行数（count）</td>
</tr>
<tr class="odd">
<td align="left">-l</td>
<td align="left">只显示匹配的文件（files with matchesO）（-L的意思与之相反）</td>
</tr>
<tr class="even">
<td align="left">-x</td>
<td align="left">匹配整行的内容（即整行恰好被匹配）（line regexp）</td>
</tr>
<tr class="odd">
<td align="left">-f file</td>
<td align="left">从文件中读取模式，每行作为一个模式，行之间是与的关系</td>
</tr>
<tr class="even">
<td align="left">-E</td>
<td align="left">使用ERE模式匹配（-G是使用BRE模式，BRE是默认设置）</td>
</tr>
<tr class="odd">
<td align="left">-P</td>
<td align="left">使用PERL模式匹配（并非是POSIX规范）</td>
</tr>
<tr class="even">
<td align="left">-e pattern</td>
<td align="left">将-e参数后的一个参数解释为正则表达式。（如果正则表达式以减号开头，能够避免该参数被解释成一个选项）。</td>
</tr>
<tr class="odd">
<td align="left">-r</td>
<td align="left">读取文件时在目录下递归查找。</td>
</tr>
</tbody>
</table>
<p>在VIM当中可以使用转义符进行输入。而转义的规定很多都来自于C语言一系。关于转义，其中由引导符和定义符构成。一个完整的转义应当是有定义的那些转义。然而如果转义后的序列不被识别，有可能被当成正常的字符处理，也可能报错。</p>
<h2 id="一些技巧">一些技巧</h2>
<h3 id="sed中如何替换空行2013年-03月-17">sed中如何替换空行[2013年 03月 17]</h3>
<p>在sed当中正确使用相应的表达式就可以了。因为sed的匹配是以行为基础的。使用符号<code>sed '/^$/d'</code>可以将文件中的不含任何字符的行删除。</p>
<p>注意在sed当中正则表达式前面没有像vim那样的s字符。sed即使是替换文本，也不使用s开头。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2012/12/30/线程与调度器/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/12/30/线程与调度器/" itemprop="url">
                  进程原理三：线程原理与编程、调度器
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2012-12-30T00:00:00+08:00">
                2012-12-30
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:47:54+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/计算机/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2012/12/30/线程与调度器/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2012/12/30/线程与调度器/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="线程的相关原理">线程的相关原理</h2>
<h3 id="线程的基本概念">线程的基本概念</h3>
<p>这里所讲的线程都是用户所使用的线程，不说系统内核中存在的诸多线程。</p>
<p>一般来说，linux的进程已经是轻量的了，创建多个进程有时候比多个线程更容易进行协调。而使用线程库是在用户空间进行的，存在效率和复杂度的问题。</p>
<p>在linux下线程的实现是按照POSIX线程的规范，POSIX线程可以在内核的支持下实现，也可以在用记线程库下实现，对于linux来说，2.6版本以上的POSIX线程的相关接口最终被放到内核中实现。</p>
<p>在讲到进程是有提到clone函数，现在来看，这个函数相当于一个底层的接口，和POSIX提供的相关接口不在同样的层次上。因此我们只讲POSIX的线程接口。</p>
<h3 id="为了防止主题分化下面讲一般的线程的原理">为了防止主题分化。下面讲一般的线程的原理</h3>
<p>线程分为用户级线程ULT和内核级线程KLT.用户级线程在操作系统看来是一个进程当中的一部分代码，和同一进程中的其它线程不可分辨。</p>
<p>实际中发现线程的调用很成问题啊，首先得到的两个线程PID一样的，然后貌似sleep的时间也不对。</p>
<p>这种混淆主要是线程比较晚出现，导致原来调度器使用的进程概念被换成线程会使系统对外的接口发生很大的变化，因而带来不便。</p>
<p>线程的核心我们定义为方便地共享数据，一切优点和缺点都是围绕着共享数据来进行的。</p>
<p>实现的一个线程只需要最基本的调度标识符，进程控制块，其它的资源都由主进程所提供。它们共享其中的资源。既然如此，也就能够通过对共享数据的读写实现线程同步，这要比进程的同步容易一些。</p>
<p>相应地，实现上难了，但对于开发者来说却在某种程度上容易了，所以线程还是对于程序员来说不着不小的意义。</p>
<p>线程的切换在操作系统看来也要比进程切换容易，因为不需要把所有的上下文都保存。</p>
<p>线程的一个积极意义吧，就是在多内核环境下的并行要容易一些。进程在多核环境下实现并行，最关键的如文件的共享，得改变文件缓存的机制。但是线程共享的数据结构相对来说比较高级，比如共享文件描述符，显然比共享一磁盘块本身要简单。</p>
<p>这里的难的容易的问题是从要设计一个操作系统的解度来说的，这个时候还没有一个现成的操作系统可以使用，但是对于学习者来讲，容易和困难缺乏意义，因为一个实现已经存在了。已经做到的事情，谁会说它很困难呢，至多可称得上复杂。</p>
<p>线程在一个复杂环境中特别有意义，因为程序中有的代码负责输入，有的负责输出，有的则是自行处理数据。如果让进程实现就不得不阻塞很久，所以这种场合恐怕是最适合多线程程序的。一个重要的方面就是网络应用。</p>
<p>个人觉得操作系统原理应该说到网络环境下线程有重要的应用。</p>
<p>要创建线程与创建进程表面上的不同是，创建进程可以在没有相关数据的情况下进行，但是创建线程却要在一个已有的环境下创建。这导致一个错误的认识，就是线程看起来是如此轻量，以致于很难想象还需要什么额外的工作。实际编程实现的时候，线程可以作为一个函数来执行。也就是说，一个线程负责运行特定的函数。在多线程程序中设计流程是非常困难的。Alan Cox 曾评论线程为“如何立刻让自己自讨苦吃。”</p>
<h2 id="linux下线程的实现">linux下线程的实现</h2>
<p>在linux下线程库的接口是一样的，在不同版本被实现为用户级线程或者内核级线程。其中的主要道理是，对于应用程序来说，区分用户级线程或者内核级线程没有多大的意义。在linux下查询线程是如何实现的，可使用命令<code>getconf GNU_LIBRPTHREAD_VERSION</code>查看使用的线程库的版本，如果是NPTL表示使用的是内核级的线程库。在linux当中原来的线程库被称为LinuxThread,它是用户级的线程库。</p>
<p>在linux之下，共享的资源有各种类型，比如环境变量的共享也是单独的一个部分，新创建的进程也可以共享其FS,但是按照线程的定义，代码段，数据区都应该是共享的。操作系统在实现的时候，要将PCB中的相应指针指向内存中的同一个页面。</p>
<p>讲进程的时候提到clone()函数，就当它不存在吧。也别管它是什么内核级线程的创建函数，实际中已经有一个高级库了，用不着再从底层做起。</p>
<p>很重要的一点，使用NPTL线程库创建的线程，PID和主线程的一样，但是TID和主进程的不同。因此它们仍然共享一个<code>task_struct</code>结构，所以多线程程序和单线程程序的不同之处，仅在于多线程程序当中的<code>task_struct</code>结构里的线程队列链里有多个成员。创建新的线程的时候，只是相当于在<code>task_struct</code> 当中注册了新的线程栈。</p>
<p>由此引起的问题是，调度时的单位是不是一个PID,因为使用NPTL内核级的线程库的时候，仍然是同一PID.所以在2.6之前的调度实体都是进程。</p>
<p>NPTL的设计是仍然被视为同一进程，且仍然使用clone()系统调用。不过其中也运用了内核当中的特殊支持。NPTL是<span class="math inline">\(1*1\)</span>的线程库，使用一个<code>pthread_create()</code>就在内核当中创建了一个调度实体。一般来说，存在着<span class="math inline">\(m*n\)</span>的调度，这种情况下用户线程数大于内核调度实体的数目。</p>
<p>这里涉及一大堆的概念。其一，我们称linux的进程为轻量进程，是因为不同的PID共享了相同的空间。而这部分仍是传统的FORK调用。进程与线程的详细情况，见下面的调度器笔记。</p>
<p>linux下的线程使用的就是符合POSIX的线程库，要在程序当中使用线程，使用头文件pthead.h.</p>
<p>使用线程的基本要求是不要使用进程的退出函数，这样会导致整个物理内存上的相关数据结构都被删除。因而带来不安全。</p>
<p>线程库在linux下也可以看成是一个封装，其中含有相应的，类似fork这样分配PID的代码。</p>
<p>一个系统中线程的数量参考：linuxThread线程库中线程数是在编译时就指定的，而NPTL支持动态的线程数，在一个IA-32系统上可达两百万个。关于线程的速度，则是如果使用NPTL,启动100000个进程只需2秒，而不使用NPTL需要15min.</p>
<h3 id="posix线程库中创建线程的方法以c语言为例">POSIX线程库中创建线程的方法，以C语言为例</h3>
<p>创建一个线程的函数原型是：</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">int pthread_create(pthread_t *thread, pthread_attr_t *attr,</div><div class="line">void *(*start_routine)(void *), void *arg);</div></pre></td></tr></table></figure>
<p>终止当前线程的函数原型是：</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int pthread_exit(void *retval);</div></pre></td></tr></table></figure>
<p>看起来 <code>pthread_create</code> 函数使用了一大堆的指针，其实却很简单，返回值是否为零代表成功或者失败。第一个参数相当于线程控制块，第二个是线程的属性，第三个是线程的入口函数，第四个是需要传递给该函数的参数。</p>
<p>UNIX函数的惯例是调用失败时返回-1,比如对于前面到的fork函数。0代表对函数来说有特殊含义的一个量，-1才代表一个调用错误，函数内部的代码无法完成所称的工作。</p>
<p>函数要写成 <code>void *function(void *arg)</code> 的形式，以便正确地进行转换。下面是一个例子。可以和fork()相对比。</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;pthread.h&gt;</div><div class="line">#include &lt;errno.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line">int main()&#123;</div><div class="line">int ret;</div><div class="line">pthread_t mythread;</div><div class="line">ret = pthread_create(&amp;mythread, NULL, myThread, NULL);</div><div class="line">if (ret != 0)&#123;</div><div class="line">    printf(&quot;Cannot create thread (%s)\n&quot;, strerror(errno));</div><div class="line">    exit(-1);</div><div class="line">&#125;</div><div class="line">return 0;</div><div class="line">&#125;</div><div class="line">void *myThread(void *arg)&#123;</div><div class="line">printf(&quot;Thread is running.\n&quot;);</div><div class="line">pthread_exit(arg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上代码的重要之处如下：</p>
<ol style="list-style-type: decimal">
<li>返回值0代表线程正常创建了；</li>
<li>当调用系统提供的函数出现错误的时候，建议使用strerror,这样一来错误会发到stderr设备。而且还会提供人人都能理解的错误信息。</li>
<li>线程函数中退出不能使用exit()，而是用 <code>pthread_exit()</code> 并且参数中的数返回的是函数的退出代码。关键是这个退出号不能是一个局部变量，因为退出函数时候变量会被销毁导致错误号无法正常传出去。使用arg作为返回时的位置，是一个避免在主线程中重新定义一个变量的技巧。</li>
<li>编译时，首先需要定义宏 <code>_REENTRANT</code> ,在有的系统上（不常见）还要定义 <code>_POSIX_C_SOURCE</code> 宏。如果系统默入不是用NPTL实现的，编译选项为：</li>
</ol>
<figure class="highlight plain"><figcaption><span>.shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cc -D _REENTRANT -I/usr/include/nptl thread1.c -o thread1 </div><div class="line">-L/usr/lib/nptl -lpthread</div></pre></td></tr></table></figure>
<p>如果默认已经是用NPTL实现的，就使用</p>
<figure class="highlight plain"><figcaption><span>.shell&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cc -D_REENTRANT thread1.c -o thread1 -lpthread</div></pre></td></tr></table></figure>
<ol start="5" style="list-style-type: decimal">
<li>因此我们在编程上也知道了，函数使用exit()退出，return退出，还是代码执行完毕后自动退出，是有区别的。</li>
</ol>
<h3 id="posix线程的基本函数">POSIX线程的基本函数</h3>
<p>父线程使用下面的函数等待子线程的终止，原型如下：</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">int pthread_join(pthread_t thread, void ** status);</div></pre></td></tr></table></figure>
<p>第一个参数标明要等待的子线程.线程的资源在父线程调用 <code>pthread_join</code>之后释放,相当于在进程当中子进程的资源在父进程调用wait()之后释放.</p>
<p><code>pthread_self()</code> 函数返回当前线程的标识.</p>
<p><strong>内核线程</strong></p>
<p>在内核引导和启动的时候，诸多的内核功能模块也会被使用，它们的地址空间是整个实地址空间，因而互相能够访问到，syslogd就是其中的一个。在ps命令下我们看到它是一个不同PID的进程结构。所以内核线程大致是以轻量进程的方式实现的。（猜测而已）</p>
<h2 id="linux的调度器">linux的调度器</h2>
<h3 id="分类的必要性">分类的必要性</h3>
<p>在操作系统当中，将调度器的时候都是在讲完进程之后，讲线程之前，但是带线程的调度器的进程调度器的不同之处太多了。</p>
<p>进程调度的时候遵循调度的一般原理，一般来说，关键在于掌握调度算法，知道怎样给一个一个的调度实体分配CPU.但是调度器的工作实际上不只这些，它还要区分哪些是调度实体，把调度实体的相关代码和数据加载到适合于执行的位置。</p>
<p>原理中那样讲的不好之处是，如果是用户级线程，就认为内核没有变化，如果是内核级线程，就把进程的区域交给其它线程共享。</p>
<p>所以认为传统进程是一个单线程的“进程”，这种认识是肤浅的。下面将会指出实际情况。</p>
<h3 id="带线程的进程模型">带线程的进程模型</h3>
<p>当一个程序不带有额外的线程的时候，生成的进程的结构和传统进程一样，包括文本段，数据段。但是一个程序如果带有线程的话，就变得不同了。这种情况下，会多出一个线程栈。这样以来就会使得对外的表现仍然是，在加载程序的时候，整个代码都会被加载以形成一个调度的实体。这样的进程和传统进程是一样的。而这时的调度器，仍然以整个进程作为调度单位。如果进程中有多余的线程，是通过KLT实现的（这里我们不能称线程为内核线程，因为这个词已经有过了定义）。那么KLT的库负责的任务就是在程序有创建线程的需求的时候利用<code>task_struct</code>结构当中对线程的支持，分配一个线程栈，并告诉调度器这个线程栈是一个独立的实体。可以直接在其中执行代码的。</p>
<p>在这一过程当中，编译器并不会感知到线程栈的存在，它仍然正常地生成有关函数的代码。当编译和连接按照流程走一遍之后，就生成了可执行文件。当程序加载执行的时候，运行到创建线程的时候，如果是KLT,就会实际上把传给它的函数的入口地址一直到结尾的部分分配到线程栈当中。告诉给调度器的也就是函数的入口地址和相关参数。因此我们认为，在KLT之下，一个线程就是一个单独运行的函数，这个函数的参数也是由线程库给出的，做完这些，函数代码就可以独立执行了，因此对于调度器来说，KLT线程是非常短小精悍的一段代码。</p>
<p>我们这里的程序的含义是由源代码生成的一个文件。</p>
<p>接下来讲ULT.虽然ULT不与调度器没有什么关系，不过对于程序执行还是有着影响，那就意味着会产生一个问题，如何让一个进程，一会儿执行这个线程上的代码，一会儿执行那个线程上的代码。</p>
<p>对于LinuxThread这样的库来说，实现多线程的方式估计很多人都要泪流满面了。实际对于LinuxThread最基本的是clone()出来的多个进程。</p>
<p>clone()函数有多个功能，其中一个最核心的功能，最准确的描述是产生一个新的进程，这个进程的地址空间始终和父进程相同。</p>
<p>LinuxThread库的功能主要集中在使用信号量在不同进程之间进行同步，并借此达到实现线程的目的。</p>
<p>以下就是澄清了的事实：</p>
<p>clone()函数有多个功能，借助它可以实现用户级的线程库（LinuxThread），也可以实现内核级的线程库（NPTL）。如果是使用NPTL,就要做参数上的调整。这就是为什么在NPTL的介绍当中，单独把“使用clone()”作为一句话的原因，其言外之意，原来的clone()是用来实现用户级线程库的。</p>
<p>有句话叫“在系统看来，用户级线程相当于一个进程，内核级线程相当于多个进程”。这句话是很有误导性的。准确的意思是，1.在调度程序看来，用户级线程之间共享一个时间片。分配时间的时候是一起的。但是在调度程序看来，无论是用户级线程，还是内核级线程，它们都被调度程序作为排队的不同成员。2.在操作系统加上线程库看来，用户级线程才相当于一个单位。</p>
<p>解释其一，在Linux程序设计当中有这样的一句话，第417页上说，“…许多项目都在研究如何才能改善Linux对线程的支持，…,其中大部分工作都集中在如何将用户级的线程映射到内核级的线程。”。后面的词“映射”非比寻常。因此原来的线程库当中，是通过线程库把一个线程映射到不同的进程当中，线程库所做的工作就是如何调整不同进程之间的同步关系，使得在一个传统的操作系统下实现线程。因此在操作系统看来，这样的每一个线程都是一个进程，所以它们可以分别被调度。至于时间片的分配，只要在创建进程的时候，使得两个<code>task_struct</code>共享一个时间值，这样以来就可以在不共享PID的同时实现时间片的共享，因此是倒回到模拟实现去了。这样外在表现就好像是一个进程一样。</p>
<p>解释其二，我们不难理解用户级线程慢的原因了，这倒不是说自己分配数据区很慢，而是说，实际上需要创建多个“病态的”进程结构。还可以知道，用户级线程容纳的线程数是非常有限的，因为系统容纳的进程数往往不是很多。在这样的系统当中实现多线程，潜能就不是很大，因为一个用户级线程被映射到一个操作系统进程。而内核级线程库的优势就在于在不改变可容纳进程数的前提下，仅通过调整可调度单位数，就能够创建出大量的线程来，并且不占用操作系统的PID资源。</p>
<p>线程库和操作系统的关系需要一番思考。如果不对操作系统进行修改，操作系统的调度单位仍是一个一个的进程，线程库能做的，也只能是把程序分成多个进程，这样才能实现并行。当然，在支持KLT的系统中也可以设计出更复杂的用户级线程库。m:n的线程模型就是一个例子。</p>
<p>因此说，不用修改操作系统，单靠线程库就可以实现用户线程也是不恰当的，如果非要那么做，线程的效率要低于普通的进程，所以运行效率上：</p>
<p>内核线程<span class="math inline">\(&lt;\)</span>单个进程<span class="math inline">\(&lt;\)</span>内核线程之和<span class="math inline">\(&lt;\)</span>轻量进程上实现的用户线程<span class="math inline">\(&lt;\)</span>多个进程<span class="math inline">\(&lt;\)</span>单个进程加上同步形成的线程。但是从实现复杂度上，进程比轻量进程易，轻量进程比线程易，KLT比ULT易。</p>
<p>摘自《Linux操作系统实验教程》：linux内核支持的用户线程都有一个用来维护它的<code>task_struct</code> 结构，该用户线程实质上是一个蛤备单独 <code>task_struct</code>结构的子进程。</p>
<h3 id="调度的本质">调度的本质</h3>
<p>以前总不能避免把一个 <code>task_struct</code> 看成一个调度单位，所以就认为一个结构就代表一个进程，所以ULT就是在一个进程当中，一个KLT就是占好几个 <code>task_struct</code> .恰恰和事实相反。</p>
<p>轻量进程和内核线程应该算是实现线程的不同思路。前者的地位，相当于在一个传统的操作系统当中，不适合共享数据，内核从而进行机制上的改造，使之提高创建进程的速度，如果操作系统不这么做，用户级线程也不可能在linux上出现的那么早。</p>
<p>因此我对内核线程的态度大为改善，以前以为它是通过创建大量的进程实现的。而这个认识被证明是完全错误的。对不起，内核线程，KLT,亲爱的NPLT.</p>
<p>调度的本质应当是一段代码及其数据在处理器和内存之间的移动，因此调度的对象完全不必是一个进程。这点原理书上说的是正确的。但是一个操作系统必须有确定的调度对象，这个也是无法改变的。如果我们以调度的最本质的特点来看操作系统，就知道调度的思想来自于甚至还未有操作系统的时代。只是在操作系统发展的初期，只能以进程为完整单位进行调度，所以在操作系统这时的调度反而是最不灵活的。</p>
<p>我们重新定义调度的对象，不再以进程作为根据。所以我们在线程调度的设计当中，更进一步了解了调度的实质。细化了调度的粒度。</p>
<p>所以在linux中通过调整nice值改变进程优先级的意义对于内核级线程作用就很小了，而且也不是人们所期望的改变。所以可能有必要设计一个工具函数，能够细化到对进程内部的线程调整优先级。</p>
<h2 id="linux的进程与作业管理">Linux的进程与作业管理</h2>
<p>操作系统原理的时候从来没有讲过作业是怎么一回事，只讲到了进程及其相关的调度，现在我们就把要学的内容完整起来。</p>
<p>Linux是一个多任务的操作系统。在计算机看来，系统上同时运行着多个进程。正在执行的一个或者多个相关的进程称为一个作业。使用作业控制，用户便可以同时运行多个作业，并在需要时于不同作业之间切换。</p>
<p>Linux是一个多用户多任务的操作系统。多用户指多个用户可以同一时间使用计算机系统，多任务指的是可以同时执行几个任务。由操作系统负责管理多个用户的请求与多个任务。</p>
<p>最关键的地方还是这些用户请求与任务直接由操作系统所识别。</p>
<p>任务这个词比进程还要更基本一些，不只是传统的进程，也包括了用户作业，操作系统任务，邮件与打印作业等。它们出现的形式可以有多种多样的。这每一个单位称为一个任务。不过在Linux下面，所有运行的东西都可以被称为一个进程(调度的单位现在是线程了)。用户任务以及守护进程都可以称为进程。</p>
<p>对进程比较正式的定义是，在自身的虚拟地址空间运行的一个单独的程序。Linux下面进程有三种类型，交互进程，批处理进程以及守护进程。三种进程各有各的作用，使用的场合也有所不同。</p>
<p>一个正在执行的进程称为一个作业，然而一个作业可以包括一个或者多个命令，特别是在我们使用管道与重定向命令的时候。比如在Shell输入一串带有管道命令的命令，就执行了一个作业，然而有多个进程。</p>
<p>作业控制指的是控制作业中正在运行的进程的行为，如控制作业的挂起或者暂停。许多Shell都有作业控制的特性，使用户可以在多个独立作业之间切换。</p>
<p>一般而言，只有与作业控制相关联的进程才能被称为作业，不受作业控制的进程通常不划入作业的范围。大多数情况下，用户一个Shell只运行一个作业。</p>
<p>进程一般有手动启动与调度启动两种方法。手动启动又有前台启动与后台启动之分。如果使用了管道，管道里面的各个进程是同时启动的。控制进程的启动，可以使用at,batch或者cron工具，而管理当前Shell里面的作业，可以使用信号，bg与fg.</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2012/12/28/进程原理二/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/12/28/进程原理二/" itemprop="url">
                  进程原理二：进程控制块与进程详细介绍
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2012-12-28T00:00:00+08:00">
                2012-12-28
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:47:39+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/计算机/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2012/12/28/进程原理二/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2012/12/28/进程原理二/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="进程控制块">进程控制块</h2>
<p>进程控制块有几种组织方式以使操作系统能够访问到。进程控制块之间的联系常有索引方式存储和链接方式存储。</p>
<p>linux继承了unix的传统，使用 <code>task_struct</code> 结构作为进程控制块。操作系统的内核空间有一个task数组，其中每个元素指向一个任务结构，又称为task向量。<code>NR_TASKS</code> 是task数组长度，因此决定着系经能够容纳的进程数。</p>
<p>linux操作系统对进程区分普通进程与实时进程，调度程序对此作出区分。</p>
<p>在linux内核栈中保存有 <code>task_struct</code> 结构的关键内容。</p>
<p>linux时间片的安排：进程创建子进程之后时间片的分配原则是：1.不会因创建子进程而受到奖励，也就是创建的子进程和父进程平分剩下的时间片。2.不会因创建短期子进程而受到惩罚，也就是子进程未被重新分配过时间片而结束，则剩下的时间片会归还给父进程。也就是系统认为子进程第一次分配的时间片来自于父进程。</p>
<p>休眠次数多的进程可能是交互式进程，但也可能是IO密集型进程。如果操作系统不能区分这一点，将会导致真正的终端交互程序响应缓慢。因此系统不是简单根椐频繁进入休眠状态来动态调整优先级，还有判断是否交互式应用的算法，<code>task_struct</code> 结构提供了相应的记录，以供调度程序选择其中的一些作为调度参考。</p>
<h3 id="进程相关的函数">进程相关的函数</h3>
<p>进程的基本属性是其PID.它的作用主要是可以给进程一个标识，可以快速地访问到相应的进程当中的信息。进程运行时可通过getpid()函数访问自己的PID</p>
<p>而进程是由其它进程创建的（.）。所以通过getppid()函数访问父进程的PID</p>
<p>根据POSIX的相关规范，进程之间是以组的方式联结起来。这是为了方便地通过信号管理一组用户的进程等目的。进程的组ID从父进程继承，组ID可通过setpgrp()修改，通过getpgrp()或者getpgid()获取。</p>
<p>进程有相关的权限，其权限来自于进程相关的用户。进程所有者是其最基本的权限来源，可以通过getuid()获取。除此之外，进程还有相关的有效用户ID和有效组ID.分别通过geteuid()与getegid()函数获取。操作系统尝试依次从相关的ID获取权限，有一个成功就返回具有权限，最后一个失败才会返回失败。</p>
<p>当然还有组ID,通过getgid()获取。</p>
<p>次序是uid,gid,euid,egid.先用户后组，先自身后额外。</p>
<p>对于线程来说，TGID标识了线程所在进程组的ID.单线程进程等于其PID,多线程时等于基本线程（父进程）的PID.</p>
<h2 id="系统启动时的进程变化">系统启动时的进程变化</h2>
<p>启动过程当中，进程形成树状的结构。内核态下执行0号进程。它创建内核态1号进程。后者负责内核的部分初始化与系统配置，并创建若干个内核线程负责设备，缓存等等。之后内核态的1号进程通过execve()运行可执行程序init,形成用户态的1号进程。它按照/etc/inittab当中的配置完成系统的启动工作。在这一过程中通常创建了若干的getty进程，每个具有不同的GRP-ID,这样就使GRP-ID有了会话期进程的含义。当检测到来自相应终端的信号的时候，getty自动执行login程序登录。由login认证之后就进入到相关的shell.</p>
<p>注意getty在执行shell时通过execve()实现的，所以是getty进程被shell进程取代。当shell退出时，init会检查相应的终端，然后决定是否重启getty.</p>
<p>后面会知道execve()相当于替换掉当前进程的代码段，所以进程号没有改变。</p>
<p><strong>进程的基本管理</strong></p>
<p>从当前进程创建一个子进程，有三个选项创建新进程：</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pid_t fork(void);</div><div class="line">pid_t vfork(void);</div><div class="line">int clone(int (*fn)(void *arg), void *stack, int flags, void *arg);</div></pre></td></tr></table></figure>
<p>三个函数最终都调用同一个内核函数 <code>do_fork()</code> ：</p>
<p><code>do_fork(unsigned long clone_flag, unsigned long usp, struct pt_regs);</code></p>
<p>其中 <code>clone_flag</code> 可以是 <code>CLONE_VM,CLONE_FS,CLONE_FILES</code> , <code>CLONE_SIGHAND,CLONE_PID</code> 以及 <code>CLONE_VFORK</code> 等。分别表示子进程与父进程共享（是共享而不是复制）相应的资源：进程空间，文件系统，打开的文件，子进程终结时向父进程发送SIGCHLD,信号处理函数，进程标识符，父进程在子进程空间被释放时唤醒。</p>
<p>如果有 <code>CLONE_VFORK</code> ,父进程一直被挂起，直到子进程空间被释放。</p>
<p>在linux下创建进程成功默认是让子进程先运行。</p>
<p>fork()函数将父进程所有资源通过数据结构复制给子进程。两个进程的地址空间完全不再干涉。需要通过进程间通信机制通信。fork()之后相当于子进程从当前位置开始执行，开始判断。父子进程不再关联。该调用向父进程返回子进程PID,向子进程返回0错误时向父进程返回-1.</p>
<p>其中的错误可能为:EAGAIN,ENOMEM.第一个是进程数达到上限，第二个是内存不足。vfork()的特点是子进程共享父进程的地址空间。运行之后父进程会被阻塞，直到子进程执行exec()或exit().使用vfork时进程堆栈区是不同的。vfork方法当然产生的是新的进程，只不过在创建的时候使用的是父进程的地址空间。但是在执行exec之后，程序就使用了新的地址。其实不妨这样看：vfork程序相当于新创建了一个存在于内核当中的引用，指向父进程的数据，此时子进程对于数据的任何修改都会被父进程看到。但是使用了exec之后，子进程的数据区就指向新的位置，父进程数据区的相应引用计数值就减去1.并且解除掉父进程的阻塞状态。</p>
<p>理解的关键在于数据区像共享文件那样存在共享计数。</p>
<p>vfork的作用有两点，第一是在vfork之后，exec之前，父进程被锁住，子进程对父进程可以安全地修改。其次，如果创建子进程的目的就是exec一个新程序并运行，复制页表完全是多余的，因此vfork后比fork后调用exec更合适。</p>
<p>无论单独的fork还是vfork,执行之后父进程都被阻塞，在子进程exec之后，或者子进程退出后才能使父进程恢复运行的能力。</p>
<p>clone()用于创建线程，先不讲。</p>
<p>创建子进程的重要目的是执行其它的程序，在linux当中通过exec()调用实现。进程调用exec()之后原有的代码段被替换成参数指定的代码段，原有的数据段和堆栈段也被废除了。只有进程号还是相同的。exec()类有若干个函数，功能大致相同。在unistd.h当中有execl,execlp,execle,execv,execve,execvp.后缀带p表示使用PATH变量查找可执行文件，，v是表示通过char*数组传参。（最后一个是NULL）。e是表示使用指定的环境变量。</p>
<p>不知道是不是所有的数据都被替换了呢？那么除了进程控制块之外所有的数据都要分配，因此开销也是不小的。</p>
<p>几个exec函数最终都变成调用 <code>do_exec()</code> 。其功能是加载新程序并跳转执行。</p>
<p>在前面讲了如何使父进程与子进程同时运行。但是有时候父进程还想知道子进程的状态，这时的解决办法是使用wait()或者waitpid()函数。</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;sys/types.h&gt;</div><div class="line">#include &lt;sys/wait.h&gt;</div><div class="line">pid_t wait(int *status);</div><div class="line">pid_t waitpid(pid_t pid, int *status, int options);</div></pre></td></tr></table></figure>
<p>编程方法：当不需要得知子进程退出的原因的时候，wait(NULL)即可，否则自己分配一个整型变量的空间。这个整型变量的不同比特位代表不同的含义，使用系统提供的对应的宏可以检查退出状态。</p>
<p>也许会有这样的疑问，子进程退出不是在系统中就不存在了么，为什么还会存有退出原因呢。这是因为虽然操作系统原理上是这么说，但是子进程PCB的释放是在wait函数中进行的，wait的原理是，等待子进程的结束。一旦子进程处于僵死状态，函数将其彻底销毁后向父进程返回。此时才真正从系统中释放子进程的PID.</p>
<p>wait()的功能是阻塞父进程直到有一个子进程退出，函数返回其PID.进程退出的原因放在status变量当中。没有子进程时返回-1.</p>
<p>waitpid的功能更强大，可以等待指定PID的子进程退出。只不过，取正的时候代表等待指定pid的子进程，-1代表等待任何一个子进程退出，0代表等待同一进程组中的任何子进程，小于-1代表等待进程组为abs(pid)中任何一个子进程。后两个主要是为了方便会话期程序管理其子进程。options可以取WNOHANG,WUNTRACED.其中第一个表示不要阻塞父进程，第二个与作业控制有关。选项有NOHANG,且返回PID为0代表没有发现可供收集的子进程。调用中出错返回-1.</p>
<p>可以理解为，是进程PID的原因返回-1,是wait中未能回收子进程返回0,其余情况返回内容函数回收的那个子进程的PID.</p>
<p>waitpid仍然只能等待其子进程pid.</p>
<p>相对wait,waitpid的优点是可以等待特定子进程退出，可以非阻塞运行，可以支持作业控制。</p>
<p>进程退出的方法。使进程自动退出的函数是exit()， <code>_exit()</code> 。</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">void exit(int status);</div><div class="line">#include &lt;unistd.h&gt;</div><div class="line">void _exit(int status);</div></pre></td></tr></table></figure>
<p>两个函数的关系相当于一个是C库函数，一个是系统函数。由于C语言和unix系列的密切关系，不能不讲C库函数的同时讲C库函数所使用的更底层函数。</p>
<p>两个函数的status用于指示退出状态。最终两个函数都是调用系统的 <code>do_exit()</code> 函数。在退出的进程中， <code>do_exit()</code> 还会使用各种退出函数，与文件系统有关的，与信号量有关的，与文件描述符有关的，与切换进程有关的，等等。</p>
<p>在linux的标准函数库当中，有一套高级IO使用了主存当中的缓冲区，C语言当中的printf(),fopen(),fread(),fwrite()都是其中的函数。此时使用 <code>_exit()</code> 会导致缓冲区当中的数据丢失，因此需要用exit()函数，它能够对缓冲区里的内容同步。</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">printf(&quot;output begin\n&quot;);</div><div class="line">printf(&quot;content in buffer&quot;);</div><div class="line">_exit(0);</div></pre></td></tr></table></figure>
<p>上面的代码运行时，第二行的printf语句结果并没有显示出来。</p>
<p><strong>进程的有关编程</strong></p>
<p>在linux下自己管理创建的进程，一般使用的函数是fork,vfork,exec,wait,waitpid, <code>_exit()</code> 这一类函数。但是在C语言的环境当中，还可以使用更加高级的函数，正如在文件读写当中使用带buffer的读写函数一样。这一类函数比如说有system(),exit().其中前者的功能是将命令传给shell执行，由shell返回</p>
<p><strong>畅想计算机学习</strong></p>
<p>在进程当中，有关操作系统原理的那部分知识显然是给系统管理员用的。系统管理直接用这些知识来调整进程的优先级，调试程序等等，但是对于应用程序开发者来说，却是没有什么意义，其中的机制才是它们最关心的，比如创建进程用什么函数。所以实际上学习操作系统就分成了两个方面，第一个是关于操作系统的各种算法的，这对于要了解操作系统原理从而要管理整个系统的人来说非常有价值。</p>
<p>但是对编程来讲却没有价值。在进程当中，程序员只需要分清楚以下的问题： 1.进程中的这些区块有没有被复制|； 2.有没有哪个进程被阻塞； 3.数据区是怎样被替换，又是怎样被销毁的； 4.进程从哪个地方开始执行。</p>
<p>所以对于程序员来说，vfork仅是相当于一个性能优化的函数，和它们头脑中布署的逻辑层次并没有关系。</p>
<p>最高的层次就是把代码和逻辑完全结合起来，暂且称之为是“运算原理”这样的一个部分吧。它的作用是从计算系统的观点来思考问题，编译原理只是其中的一个入门课。</p>
<h2 id="进程的管理">进程的管理</h2>
<h3 id="进程的基本管理">进程的基本管理</h3>
<p>使用<code>ps</code>命令查看相应的进程是在使用操作系统命令的层次上</p>
<p>nice值对于进程的响应速度有重要的影响，前面已经知道了nice值的作用，控制着进程的优先级。值越大，优先程度越低。</p>
<p>nice和renice命令分别用于调整进程的优先级。</p>
<p>相应地也有nice的系统调用用于调整进程优先级，实际上unix系统下的函数调用和命令调用对应关系是很紧密的。</p>
<p>linux的调度算法中进程的时间片从5ms到800ms不等。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
  <link itemprop="mainEntityOfPage" href="http://yoursite.com/2012/12/18/进程原理一/">

  <span style="display:none" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <meta itemprop="name" content="Istyasna">
    <meta itemprop="description" content="">
    <meta itemprop="image" content="/images/avatar.gif">
  </span>

  <span style="display:none" itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="80x24">
    <span style="display:none" itemprop="logo" itemscope itemtype="http://schema.org/ImageObject">
      <img style="display:none;" itemprop="url image" alt="80x24" src="">
    </span>
  </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                
                <a class="post-title-link" href="/2012/12/18/进程原理一/" itemprop="url">
                  进程原理一：进程管理与Linux下面的进程
                </a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2012-12-18T00:00:00+08:00">
                2012-12-18
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              <span class="post-meta-item-text">更新于</span>
              <time title="更新于" itemprop="dateModified" datetime="2016-12-14T16:47:31+08:00">
                2016-12-14
              </time>
            
          </span>

          
            <span class="post-category" >
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/" itemprop="url" rel="index">
                    <span itemprop="name">操作系统</span>
                  </a>
                </span>

                
                
                  ， 
                
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/操作系统/计算机/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <a href="/2012/12/18/进程原理一/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2012/12/18/进程原理一/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          

          
          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>把进程管理放在操作系统中较后的位置，不是没有原因的。想一想，如果没有那么多的设备又何必设计存储管理，如果没有存储设备中内容的复杂性，又何来文件系统管理。如果没有文件系统提供那么多的资源，又何必设备多个程序，让它们按照可被调度的对象运行? 由此可见。在底层，在操作系统设计的时候，按照一个一个的模块来设计的。有了前面的准备，进程的运行才有一个良好的环境，才方便我们设计调度。</p>
<p>进程管理中的进程被提供了一个抽象的体例。在进程中，也许应该首先使用虚拟地址空间，区分内核态与用户态，再联系处理器的权限管理的机制。这样对于为何进程有必要存在给了一个比较好的解释。</p>
<p>在存储管理的层次上，可以按照所谓单一连续分配，固定分配，动态分配，分页或者分段的方法。但是这只是一个方面。这是进程的静态的结构，这时进程被看成是存储区域。但是还可以更高级地，把进程看成是运行着的文件。</p>
<p>多用户情况下，进程的权限可以看成是由文件的权限演变而来，而且它访问的设备，都是这样的一种抽象。所以如果把进程管理放在最后的话，我们会更能看出进程技术的复杂性。在学习路线上，先设备后进程的方法也许是很适合的。</p>
<p>在进程与编译技术上，刚开始的编译，只是按照实际地址空间的编译，自从有了进程与抽象之后，便可以使用可重定位的代码了。这样编译的技术也就可以更进一步。有了这些，我们才可能进一步讲解在操作系统之下的虚拟机，调试，安全优化这些内容。</p>
<h2 id="进程与子进程的同步">进程与子进程的同步</h2>
<ol style="list-style-type: decimal">
<li>使用<code>_exit()</code>系统调用或者exit()库函数终止进程，或者等待进程代码执行完毕的时候退出，或者使用return()语句。通常并不直接使用系统调用。因为与<code>_exit()</code> 相比，exit()还执行了更多的清除工作。</li>
</ol>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void _exit(int status);</div><div class="line">void exit(int status);</div></pre></td></tr></table></figure>
<ol start="2" style="list-style-type: decimal">
<li><p>当一个进程创建一个子进程的时候，大多数情况下，紧跟其后的是调用exec语句。exec的用法这里不讲。</p></li>
<li><p>等待进程死亡的系统调用是wait()。它的效果是在父进程执行它的地方被阻塞，直到有一个子进程死亡，wait得到它的状态返回，父进程因此继续执行。wait的不好之处是在这之前父进程可能创建了多个子进程，wait返回时，父进程并不知道是哪个子进程结束了。</p></li>
</ol>
<p>子进程先死亡的时候，子进程的进程表不会立即被释放。除非是init进程，有定时清理defunct进程的功能。</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wait(int *exitstatus);</div></pre></td></tr></table></figure>
<p>为了改进这一状态，可以选择使用waipid()函数代替。</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pid_t waitpid(pid_t pid, int *stat_loc, int options);</div></pre></td></tr></table></figure>
<p>第二个参数保存退出状态。options参数取WNOHANG,WUNTRACED,WCONTINUED之一或者其中的组合。有NOHANG的时候立即返回，不会阻塞。pid是所等待的进程。但是有些有特殊的意义。比如-1代表进程一直阻塞；0代表等待进程组中任何一个进程的死亡；<span class="math inline">\(pid&gt;0\)</span>时表示所等待的进程；<span class="math inline">\(pid&lt;0\)</span>时绝对值表示等待PGID等于pid绝对值的进程（组领导进程）死亡。</p>
<p>进程组是Berkeley小组提出的一个概念，利用它可以控制一组具有共同特性的进程。组中每个进程有进程组标识号PGID,其值等于进程组领导者的PID</p>
<p>不同shell中的特性也不一样，比如在Bourne Shell里，其中运行的命令与shell的PGID相同。C Shell, Korn Shell, Bash Shell中，处于同一管道的命令组成一个独立的进程组。具体来说。支持作业控制的Shell才会像后者一样。</p>
<p>一个用户可以有多个进程组，只有一个进程组在前台，它连接到会话的控制终端。在按下CTRL-C的时候，我们实际上是向前台进程组里的所有进程发送SIGINT信号。因此在一堆管道命令当中，我们也可以使用一个CTRL-C.</p>
<p>当后台进程组试图从终端读取数据的时候，终端驱动程序会发现这种行为，发送一个信号，挂起这个进程组。</p>
<h2 id="使用环境变量">使用环境变量</h2>
<p>环境变量是进程地址空间的一部分。在创建子进程时父进程的环境变量会传递给子进程。保存在一个外部变量里。使用如下的语句声明它：</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">extern char **environ;</div></pre></td></tr></table></figure>
<p>这个指针数组的每一分量是name=value的形式。</p>
<p>POSIX规范定义了如下的两个函数分别用于求取和设置环境变量的值：</p>
<figure class="highlight plain"><figcaption><span>.c&#125;</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">char *getenv(const char *name);</div><div class="line">int setenv(const char*envname, const char * envval, int overwrite);</div></pre></td></tr></table></figure>
<p>其中overwrite的含义是：非零值代表如果已有环境变量，其值被覆盖。</p>
<p>和C语言非零值代表true的约定是一样的。</p>
<h2 id="程序设计中的进程控制">程序设计中的进程控制</h2>
<p>进程控制块是进程存在的根据，在进程控制块中有许多的内容可以使用。内容在上个笔记中已经有介绍了。</p>
<ol start="0" style="list-style-type: decimal">
<li>创建进程使用fork()函数，返回 <code>pid_t</code> 类型。向父进程返回子进程PID,向子进程返回0.父进程从从那时创建fork()调用的下一行开始。</li>
</ol>
<p>使用 <code>pid_t</code> 类型的一个好处是，我们不知道 <code>pid_t</code> 的真正类型是什么，因而也就无需考虑这个类型的加法减法有什么意义了，反而落得清静。</p>
<ol style="list-style-type: decimal">
<li><p>进程号相关的方法getpid()与getppid()分别获取当前进程ID和其父进程ID.</p></li>
<li><p>进程用户属性getuid(),getgid(),geteuid()与getegid()。</p></li>
</ol>
<p>设计父进程和子进程的机制可以稍微从POSIX的规定中看到一些，比如说，因为多用户的环境下所有的进程如果彼此独立的话，对于系统程序设计是一个挑战。</p>
<p>进程控制的确是一个技术思路的问题，而非一个科学上的问题，不仅如此，很多在操作系统原理上学的也是几个技术实现，并不能称上是计算机科学。</p>
<h2 id="进程创建的机制">进程创建的机制</h2>
<p>一个进程的创建明显有三个阶段，需要调用三个重要的系统调用或系统函数。它们分别是fork,exec,wait.当我们在shell里执行一个命令<code>${CMD}</code>的时候，shell会另外创建一个shell进程，新创建的进程映象载入<code>${CMD}</code>映象，<code>${CMD}</code>进程开始运行。SHELL父进程等待<code>${CMD}</code>的执行结束，并获取<code>${CMD}</code>的退出状态值。</p>
<p>对于进程之间的关系来说，以下的属性比较重要：</p>
<ol style="list-style-type: upper-alpha">
<li>进程的真实UID和GID</li>
<li>进程的有效UID和GID</li>
<li>进程启动时所在的目录</li>
<li>所有由父进程打开的文件描述符</li>
<li>环境变量</li>
</ol>
<p>其中有效UID与有效GID和SUID和SGID有关。对于有些设置了SUID或SGID属性的程序有用，用于一个程序以它的UID和GID启动，而不是当前用户。</p>
<p>操作系统原理讲的很简略的，没有讲过进程之间父子关系这些东西。但是我们可以自己把它理解成人为加上去的属性，不影响进程的调度。</p>
<p>当一个进程死亡的时候，会立即转入僵尸状态，直到它的父进程从进程表中获取它的状态值。然后内核从进程表中删除这个记录。处于僵尸状态的进程是一个无害的子进程，但是我们不能终止它。</p>
<p>倘若在子进程之前，父进程已经死亡，此时这个子进程成为一个孤儿，内核将指派init成为所有孤儿进程的父进程。而特殊之处是中有所有子进程都死亡之后，init才会死亡。</p>
<p>由此我们补充进程的几个阶段当中，一旦执行完毕，并不会直接就从PCB中消失，而是还要经过一系列的处理过程。</p>
<p>僵尸进程和孤儿进程的不同定义。</p>
<p>关于进程有很多的主题，在操作系统当中学习的是进程管理，并发控制，进程调度，在这里学习的是进程控制，虽然也是进程管理的一部分但是没有包含在操作系统原理当中。</p>
<h2 id="对于进程的理解">对于进程的理解</h2>
<p>学习的进程实际上并不是最深层的原理。进程本身的机制还是我们不能了解的。所以就当操作系统为我们提供了进程这样的一个机制。在其中我们进行进程的创建和管理等等工作。</p>
<p>计算机程序运行状态分为内核态和用户态。我们把进程想象成什么比较好呢？在原来的环境下，正如天地始于混沌一样，代码是不分彼此的。后来为了独立出来问题才有了这样的分别。计算机之所以成为计算机而不是计算器，本质在于其理论上的通用性。在原来的操作系统理论当中，引入多道程序设计的目的是提高运行的效率。这个方面的因素不能说没有吧。但相对来说，计算机的功能整合其实发生了很重要的作用。</p>
<p>我们这样反思在计算机初期的发展原理。当时具有中央机与外围机，中央机的作用只是进行所谓的运算。这样一来就有了“单道”的程序环境。随着输入速度的提高，在实践中开始暴露出许许多多的问题。计算机当时没有什么理论性，或者说其理论还是作为业余人员的兴趣在被谈论，并未指导用于计算机的工业制造。工业上真正的变化是因为计算机速度的提高，使输入和输出跟不上计算性能，所以当时的首要问题和现在相反，是计算能力不能满足科学的需求，但这是因为人们不能在输入和输出上跟上计算机。</p>
<p>在这种情况下首要的任务自然是对外围机进行整合，由更加高速的设备和控制逻辑代替某些人工操作。其中蕴含着可以实现通用计算的机会。因此计算机才开始进入整合的时期，才进行输入，运算，存储和输出的整合。在这种情况下当然一个紧密相关的系统的产生就是不可避免的了。既然如此，就不可能不让众多的功能聚在一起。在这种融合下，首先发生的变化就是和运算器，数理逻辑结合在一起。两个发现方向，其一，实用科学的计算需求，其二，人们对于可计算性的思考，之间的结合，是促使计算机原理化的第一动力。</p>
<p>其次才是多道程序设计的产生。这个现象并不是遇然的，前面的理论已经为它的产生做好了准备。多道程序发生的第一因素是中央机和外围机对应不同功能需要使用不同的程序逻辑实现。在实际发展当中，我们还看到60年代的机器，越来越显得中央机太快，因此在我们的输入进行提高的同时，针对计算机空闲的现象，还试图在同一中央机当中添加多道程序，以提高运算器的使用效率。所以多道程序设计的原理在这个时候已经需要成熟。</p>
<p>所以多道程序设计的必要性至少在计算机实体与计算性理论相结合的时候，多道程序就已经实现了。甚至在90年代，我们从WINDOWS作为DOS上的一层外壳，也能看出多道程序设计在萌发阶段的表现。典型的就是操作系统还只是一个软件中间件，程序员和使用者能够清楚地看到硬件结构。</p>
<p>因此我们把进程想象成一群有交往关系的个体。这些个体要生活在同样的一个环境当中，我们需要合理安排，否则因为它们非常笨，会导致什么事情都做不了。它们做不了事情，我们的生命也就失去了意义了。</p>
<p>所以原始的方法是我们在一个较弱的界面上实现一个较强的功能，但是我们拥有了相当程度的知识之后，就要想办法使整个系统有很高的整合度，特别是需要很简单。</p>
<p>以我们的观点来看，计算机是我们认识世界的窗口，其中的有些道理和人类世界是相通的。</p>
<h3 id="进程最基本的一面">进程最基本的一面</h3>
<p>我们先讲的是进程机制。所以整个事情有显得没有什么必然的联系。实际上却是还有一些思想在其中的。</p>
<p>首先要看到进程的结构为什么是这样的。底部的细节已经是是为我们屏蔽了的，比如分页机制与分段机制，还有虚拟内存。所以现在我们以编程人员探寻进程的实质为理由学习操作系统。然后我们就可以进行抽象了。</p>
<p>那么程序执行的实质过程是什么呢？编译器封装了很多的细节。所幸可以根据汇编语言来进行推测。其结果就是所谓的数据段，文本段，BSS段。</p>
<p>学习汇编语言的恰当时机个的认为是在学习了一门不太高级的高级语言如C之后，因为C语言的实用性最高，和汇编语言比较容易联系起来，技术性比较强，反观JAVA等就比较复杂，还得学习编译原理之后才会有一个比较明确的理解。所以学习一个面向过程，甚至直接学习汇编，皆是面向机器编程所需，这样以来，可以很好了解操作系统提供特性，执行的过程。更因为学习嵌入式实际上也算其中有操作系统，而其中的代码就和机器比较紧密，所以我们知道操作系统原理应该在裸机上学，在一个屏蔽了机器细节的机器上学习。这个和编译器生成的中间代码是处在同一个层次。</p>
<p>所以整个计算机课程学习的过程就是中间代码可以算是一个分水岭。在其上生长了丰富的思想，在其下生长着各种性能的器件。</p>
<p>数据结构在一门编程语言和操作系统之间。</p>
<p>所以操作系统的进程一开始涉及的是进程段的分配。而内存我们很容易就可以想象成一个线性的地址序列，所以也没有什么困难的地方，即使我们将内存想象成一个一个的空格组成的空间也可以。</p>
<p>接下来就涉及进程空间的分配。内存只有一条，但是我们在编程的时候由于都要转化成操作符和操作数的络式，所以地址就成了一个重要的问题。操作系统的解决手段相当于说，自己当成一个中介，代表每个进程进行分配。这就像一群人有东西要分，但是没有人出来做协调，于是就有一个比较聪明的人站出来给大家出谋划策，当然不是无条件的，它本身也要占据一些资源，不过结果在家都能满意。这说明这人确实有才能，不过目的却并不怎么光明磊落，就像微软在DOS上加了一系列WINDOWS的库让大家用一样。</p>
<p>操作系统利用的是硬件提供的机制，形成的是进程空间这样的一个抽象。背后利用的当然是分段或者分页。我们就当操作系统在执行程序代码的时候自动对程序的地址进行变换，就可以了。或者干脆说，被体系拦住了。</p>
<p>在硬件上我们知道有MMU等机制。</p>
<p>进程因此被操作系统所管理。操作系统使用的数据结构称为进程控制块PCB.</p>
<h3 id="操作系统完成对进程的抽象">操作系统完成对进程的抽象</h3>
<p>但是进程不需要知道它的存在，完成自己的事情就可以了，所以如果把计算机系统看成一个人的生命周期，开关机和保存状态都和生命的存在有关，但是一个进程的灭亡，只是相当于一个细胞的死亡。重要的器官还都存在着。</p>
<p>对于一个人而言，就知道，会玩游戏只是会一个程序，它终究是会死亡的，我们使用计算机的意义不在于那个程序，而在于我们使用那些功能，留下了那些重要的数据。或者说，我们的思想有什么收获。</p>
<p>所以现在我们开始讨论一个有限生命，这就不得不拿出生理学的淡定态度来。</p>
<p>在操作系统看来进程有四个部分，进程控制块，进程程序块，进程内核栈，进程数据块。</p>
<p>一个一个解释这些内容显得好琐碎，这样说吧，一个是进程控制块为操作系统所用，相当于进程的身份信息。其余的内容都相当于进程告诉操作系统哪些在执行时用到，哪些是先注册好的资源。这样系统知道在执行切换的时候如何安排，因为就相当于一次旅游，操作系统要把人送到目的地，人总要说，自己有哪些行李是要带到那个地方使用的。</p>
<p>在unix看来，后三个具有RWX类的权限，各自为R-X RW-RW-。这是因为在unix看来，写不只是向硬盘中去写，内存，甚至寄存器也有这样的概念。所以unix操作系统的权限设定是从头到尾的，任何可能的位置都赋予了相应的权限。</p>
<p>缺少其中任何之一就不称为进程，如果只有前三项就称为线程，如果用户空间共享，则称为用户线程。如果没有用户空间，就称为内核线程。</p>
<p>所以线程的定义是非常不严谨的。</p>
<p>在实现的时候，由于进程程序块里的内容不会被改变，所以系统也可以透明地让其它的进程使用，只是开始的位置可能不同而已，没有必要记录下所有的内容。</p>
<p>与操作系统原理的对应是，程序段代表其中的内容会被取指令所操作。数据段则是进程地应程序加工处理的原始数据或者中间结果。进程控制块是系统统一管理调度进程的一个数据结构。</p>
<p>所以说系统与进程的地位就有些混乱了。有时候操作系统好像过分控制了进程。对此我只能说这种不公正对特进程的现象只能是操作系统自身的原因，一个好的操作系统，应当能够让用户保证对自己来说有意义的程序得到最好最恰当的调度。</p>
<p>先不考虑读写磁盘，只考虑程序执行过程中涉及运算的那个部分。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>


    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="Istyasna" />
          <p class="site-author-name" itemprop="name">Istyasna</p>
          <p class="site-description motion-element" itemprop="description">GO FORTH now and create masterpieces of the publishing art!</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">58</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">33</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">198</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/irhawks" target="_blank" title="GitHub">
                  
                    <i class="fa fa-fw fa-github"></i>
                  
                  GitHub
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://coding.aliyun.com/u/irhawks" target="_blank" title="Aliyun">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  Aliyun
                </a>
              </span>
            
          
        </div>

        
        
          <div class="cc-license motion-element" itemprop="license">
            <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
              <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
            </a>
          </div>
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="./" title="Title" target="_blank">Title</a>
                </li>
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.hainu.edu.cn" title="Hainan University" target="_blank">Hainan University</a>
                </li>
              
            </ul>
          </div>
        

        


      </section>

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Istyasna</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"irhawks"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  








  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
      search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();
    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';
      $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = $( "entry", xmlResponse ).map(function() {
            return {
              title: $( "title", this ).text(),
              content: $("content",this).text(),
              url: $( "url" , this).text()
            };
          }).get();
          var $input = document.getElementById(search_id);
          var $resultContent = document.getElementById(content_id);
          $input.addEventListener('input', function(){
            var matchcounts = 0;
            var str='<ul class=\"search-result-list\">';
            var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
            $resultContent.innerHTML = "";
            if (this.value.trim().length > 1) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var content_index = [];
                var data_title = data.title.trim().toLowerCase();
                var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                var data_url = decodeURIComponent(data.url);
                var index_title = -1;
                var index_content = -1;
                var first_occur = -1;
                // only match artiles with not empty titles and contents
                if(data_title != '') {
                  keywords.forEach(function(keyword, i) {
                    index_title = data_title.indexOf(keyword);
                    index_content = data_content.indexOf(keyword);
                    if( index_title >= 0 || index_content >= 0 ){
                      isMatch = true;
                      if (i == 0) {
                        first_occur = index_content;
                      }
                    }

                  });
                }
                // show search results
                if (isMatch) {
                  matchcounts += 1;
                  str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                  var content = data.content.trim().replace(/<[^>]+>/g,"");
                  if (first_occur >= 0) {
                    // cut out 100 characters
                    var start = first_occur - 20;
                    var end = first_occur + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if(start == 0){
                      end = 50;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    var match_content = content.substring(start, end);
                    // highlight all keywords
                    keywords.forEach(function(keyword){
                      var regS = new RegExp(keyword, "gi");
                      match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                    });

                    str += "<p class=\"search-result\">" + match_content +"...</p>"
                  }
                  str += "</li>";
                }
              })};
            str += "</ul>";
            if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
            if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
            $resultContent.innerHTML = str;
          });
          proceedsearch();
        }
      });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

  


</body>
</html>
