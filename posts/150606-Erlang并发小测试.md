---
title : Erlang编程语言中的并发小测试
date  : 2015-06-06
tags  : Erlang, 并发, 集群
---

已经接触了很多的编程语言。大概分成Lisp一系的、Haskell一系的，Erlang一系的、JVM一系的、C#一系的，以及OCaml一系的语言。但是自己感觉，分类上，可能还是按照类型的动态与静态，是否是纯函数式的，是否支持面向对象特性，是否支持自动类型推断（其实现代编程语言大概都支持了），求值的时候是否是惰性求值的，以及对于并发和并行的支持等。函数式语言的特性大概就这么看。其它的方面，说是语言的包管理系统、编译环境与版本控制。如果是在虚拟机上，那么对虚拟机上的原生语言的支持等。

看到这么多编程语言，自己感觉很多的设计模式都是内置在函数式语言中的，比如自己设想的在改变一个变量的时候，同时产生一种日志记录，已经在Clojure中完美实现。其它的语言特性也很多。

Erlang上面还建立有Eixir编程语言。语言更进一步。Erlang是运行在EVM虚拟机上的。有个时候，一些并发处理的机制与面向对象其实是不谋而合的。由于设计模式已经融入其中，自己感觉，设计模式是一种比较高级的抽象了。

Erlang是一种通用的面向并发的编程语言，它由瑞典电信设备制造商爱立信所辖的CS-Lab开发，目的是创造一种可以应对大规模并发活动的编程语言和运行环境。Erlang问世于1987年，经过十年的发展，于1998年发布开源版本。Erlang是运行于虚拟机的解释性语言，但是现在也包含有乌普萨拉大学高性能Erlang计划（HiPE）开发的本地代码编译器，自R11B-4版本开始，Erlang也开始支持脚本式解释器。在编程范型上，Erlang属于多重范型编程语言，涵盖函数式、并发式及分布式。顺序执行的Erlang是一个及早求值, 单次赋值和动态类型的函数式编程语言。

使用Erlang来编写分布式应用要简单的多，因为它的分布式机制是透明的：对于程序来说并不知道自己是在分布式运行。Erlang运行时环境是一个虚拟机，有点像Java虚拟机，这样代码一经编译，同样可以随处运行。它的运行时系统甚至允许代码在不被中断 的情况下更新。另外如果需要更高效的话，字节代码也可以编译成本地代码运行。

Erlang的设计中采纳了一些Prolog与Smalltalk中的东西。个人感觉，在处理并发问题的时候，还是不得不接触Erlang，就像在函数式语言中不能离开Haskell一样。

## Erlang的并发测试环境设计

Erlang在安装好之后应该进行分布式集群的创建的工作。每个结点上可以开启一个。安装完Erlang之后，首先应该配置Cookie，因为同一个集群当中的Erlang，应当有相同的Cookie。以juju为例，在所有的结点中执行如下的操作：

```shell
## Install Erlang packages
juju run --all "sudo apt-get install -y erlang-base"
juju run --all "echo just_for_test > .erlang.cookie"
juju run --all "chmod 400 ~/.erlang.cookie"
```

上面的代码在每台机器上安装Erlang环境的同时，把各台机器上的Erlang Cookie都设置为`just_for_test`（以便它们都位于同一个群组中。然后正确设置cookie的权限。

接下来，我们要在每台机器上运行epmd进程，它负责映射符号名到机器地址。

```shelll
juju run --all "epmd -daemon"
```

<http://gashero.yeax.com/?p=67>中讲到了Erlang在单机环境中的应用和配置。 

Elixir的连接与Erlang类似，但是还是有一些不同。

开启结点的话，可以使用

```shell
juju run --all 'erl -name $(hostname)@$(hostname).107.maas -detached'
```

运行成功之后，可以在同一个网络中登录其中的一个结点并进行测试：

```shell
erl -name test@node01.107.maas <<EOF
net_adm:ping('node06@node06.107.maas').
nodes().
EOF
```

经过ping之后，应该能够发现原来的结点。（实际上是这样的连接建立之后，整个Erlang上面的结点能够互相发现。不一会儿，结点就会加入Full Mesh的Erlang结点网络）这样一个Erlang分布式环境就搭建成功了。但是应该说，在这个平台上实现分布式的Erlang程序还是不够的。因为故障容错等都还需要额外的努力。需要一些特别的机制。

在配置过程中，注意有相同的Cookie才能加入同一个Erlang群组。通过

```erlang
rpc:call('node01@node01.107.maas',erlang,now,[]).
```
可以测试在指定的结点上执行代码。其中，Erlang的结点之间自动连接是默认的选项，当然可以在启动Erlang的时候使用相关的选项禁止自动连接。手动连接使用net_kernel，示例如下：

```erlang
net_kernel:connect_node('node01@node01.107.maas').
```


## Erlang的编译工具Rebar[06-12-2015 22:09:11]

Rebar是Erlang的编译工具，相当于sbt。见<https://github.com/rebar/rebar>。不过，rebar主要用于Erlang下面的OTP应用。中文也有一些参考的资料。

<!--今天解决的问题有三个，第一个是iot-framework-engine，第二个是iot-framework-gui，第三个是cavin-base。希望可以利用好这些工具。-->

此外，`sensor_cloud`的示例也接触了一些。接下来要继续的是学习cavin的wiki。<https://github.com/EricssonResearch/calvin-base/wiki>。以及这篇论文<http://www.sciencedirect.com/science/article/pii/S1877050915008595>。
