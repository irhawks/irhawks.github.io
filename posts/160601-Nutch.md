---
title : Apache Nutch的介绍与基本使用
author : irhawks
date : 2016-06-01
tags : nutch, solr, hbase, Elastic Search, Scala, API
---

Nutch本是一个单独的程序，通过程序可以进行全文的挖掘并定制有关的服务。挖掘出来之后还可以使用Solr进行索引。这样就产生了各个页面。但是另外一方面，Java的程序包又都可以通过包的形式调用，因此在Scala当中也可以使用。但是要在Scala当中使用的话，显然是需要读Nutch的API文档及其用法的。


关于Nutch
---------------------------------------------------

2015年1月，Apache Nutch v2.3已经发布了，建议所有使用2.X系列的用户和开发人员升级到这个版本。这个版本提供了一个基于Apache Wicket的Web管理界面，解决了143个问题，提供了Maven依赖，升级到Gora v0.5，支持的底层存储为：

#.  Apache Hadoop 1.0.1 & 2.4.0
#.  Apache Cassandra 2.0.2
#.  Apache HBase 0.94.14
#.  Apache Accumulo 1.5.1
#.  MongoDB 2.12.2
#.  Apache Solr 4.8.1
#.  Apache Avro 1.7.6 

同时请注意，Gora对SQL的支持已经过时了。

Nutch的创始人是Doug Cutting，他同时也是Lucene、Hadoop和Avro开源项目的创始人。

Nutch诞生于2002年8月，是Apache旗下的一个用Java实现的开源搜索引擎项目，自Nutch1.2版本之后，Nutch已经从搜索引擎演化为网络爬虫，接着Nutch进一步演化为两大分支版本：1.X和2.X，这两大分支最大的区别在于2.X对底层的数据存储进行了抽象以支持各种底层存储技术。

在Nutch的进化过程中，产生了Hadoop、Tika、Gora和Crawler Commons四个Java开源项目。如今这四个项目都发展迅速，极其火爆，尤其是Hadoop，其已成为大规模数据处理的事实上的标准。Tika使用多种现有的开源内容解析项目来实现从多种格式的文件中提取元数据和结构化文本，Gora支持把大数据持久化到多种存储实现，Crawler Commons是一个通用的网络爬虫组件。

大数据这个术语最早的引用可追溯到Nutch。当时，大数据用来描述为更新网络搜索索引需要同时进行批量处理或分析的大量数据集。现在，大数据的含义已经被极大地发展了，业界将大数据的特性归纳为4个“V”。Volume数据体量巨大，Variety数据类型繁多，Value价值密度低，商业价值高，Velocity处理速度快。

Hadoop是大数据的核心技术之一，而Nutch集Hadoop之大成，是Hadoop的源头。学习Hadoop，没有数据怎么办？用Nutch抓！学了Hadoop的Map Reduce以及HDFS，没有实用案例怎么办？学习Nutch！Nutch的很多代码是用Map Reduce和HDFS写的，哪里还能找到比Nutch更好的Hadoop应用案例呢？


Building A Search Engine With Nutch And Solr In 10 Minutes (编译)
-----------------------------------------------------------------


首先下载Solr并安装，然后使用java -jar的方式运行起来Solr，得到Solr的管理台界面（为<https://localhost:8983/solr/admin>）。<http://www.lucidimagination.com/Downloads/Lucidworks-for-Solr/Installer>。

然后下载Nutch并安装，设置好`JAVA_HOME`与`NUTCH_JAVA_HOME`。<http://zillionics.com/resources/articles/NutchGuideForDummies.htm>。

之后找到一个nutch-site.xml文件，配置如下：

```xml
<?xml version="1.0"?>
<configuration>
<property>
<name>http.agent.name</name>
<value>nutch-solr-integration</value>
</property>
<property>
<name>generate.max.per.host</name>
<value>100</value>
</property>
<property>
<name>plugin.includes</name>
<value>protocol-http|urlfilter-regex|parse-html|index-(basic|anchor)|query-(basic|site|url)|response-(json|xml)|summary-basic|scoring-opic|urlnormalizer-(pass|regex|basic)</value>
</property>
</configuration>
```
配置好之后运行nutch。除此之外，还要包括有URL的seed.txt文件。弄好之后启动，就开始进入到Nutch的挖掘的模式了。最后我们需要将数据推送到Solr，这需要在启动Nutch的时候进行Solr的地址的配置。

HBase的JUJU配置脚本可见<https://10.0.8.119/services/?store=~bigdata-dev/trusty/apache-hbase>。


注意在安装Nutch之前要安装无论是单机模式还是集群模式的HBase，而HBase的集群模式又需要单独配ZooKeeper等软件组件。这是比较大的工作了。之后自己可能需要调整一下，或者制作几个镜像文件。

nutch 2.3是其src镜像文件，但是事先不需要我们编译。解压之后，首先配置`conf/nutch-site.xml`文档。修改为

```xml
<property>
  <name>storage.data.store.class</name>
  <value>org.apache.gora.hbase.store.HBaseStore</value>
  <description>Default class for storing data</description>
</property>
```

然后修改`ivy/ivy.xml`文档：

```xml
<dependency org="org.apache.gora" name="gora-hbase" rev="0.3" conf="*->default" />
```

之后再修改`conf/gora.properties`文档，确保HBaseStore是默认的存储

```
gora.datastore.default=org.apache.gora.hbase.store.HBaseStore
```

之后使用ant编译即可。官方配置教程见<http://wiki.apache.org/nutch/Nutch2Tutorial>.

实际上nutch的存储后端未必是需要HBase，但是Apache Nutch2的官方教程中默认就是使用HBase而不是MongoDB的，因此我们还是不得不配置HBase。而且使用HBase作为存储后端的话，必须在Nutch运行之前先启动HBase。注意几个组件Nutch、Solr、Gora、HBase之间的关系。运行中如果出现HBase找不到，应该参考<http://stackoverflow.com/questions/16401667/java-lang-classnotfoundexception-org-apache-gora-hbase-store-hbasestore>。在`ivy/ivy.xml`中添加`gora-hbase`的依赖。

<https://gist.github.com/xrstf/b48a970098a8e76943b9>上面介绍了一种ElasticSearch + Nutch + HBase的解决方案。


<!-- 正常工作意味着下面的步骤中的inject等命令都能正常工作。在`hbase shell`中输入`scan 'webpage'`这个命令，可以找到nutch所查询到的网页。这样就OK了。之后就是配置Solr了。 -->


Nutch的基本使用（Short User Guide）
-------------------------------------------------------------

前面的`ant runtime`重新编译好之后，在`bin`目录下就可以找到nutch命令了。

接下来我们首先新建一个seed.txt文件。比如在`urls/seed.txt`中存储文件的内容。`seed.txt`中存放初始URL，比如

```
http://nutch.apache.org/
```

之后在`conf/regex-urlfilter.txt`文件中输入如下的内容：

```
+^http://([a-z0-9]*\.)*nutch.apache.org/ 
```

之后就可以使用nutch命令进行挖掘了。注意一个nutch往往代表一个爬虫而已，nutch带有它的庞大的运行时。在`conf/nutch-site.xml`文件中还可以设置此次爬虫的名子

```xml
<property>
  <name>http.agent.name</name>
  <value>My Nutch Spider</value>
</property>
```

接下来我们就考虑Solr与Nutch的集成吧。基于Solr实现站内搜索。封装及扩展性较好，提供了较为完备的解决方案，因此在门户社区中采用此方案，后期加入Compass方案。

由于搜索引擎功能在门户社区中对提高用户体验有着重在门户社区中涉及大量需要搜索引擎的功能需求，目前在实现搜索引擎的方案上有集中方案可供选择：

1. 基于Lucene自己进行封装实现站内搜索。工作量及扩展性都较大，不采用。
2. 调用Google、Baidu的API实现站内搜索。同第三方搜索引擎绑定太死，无法满足后期业务扩展需要，暂时不采用。

Solr是一个基于Lucene的Java搜索引擎服务器。Solr 提供了层面搜索、命中醒目显示并且支持多种输出格式（包括 XML/XSLT 和 JSON 格式）。它易于安装和配置，而且附带了一个基于 HTTP 的管理界面。Solr已经在众多大型的网站中使用，较为成熟和稳定。Solr 包装并扩展了 Lucene，所以Solr的基本上沿用了Lucene的相关术语。更重要的是，Solr 创建的索引与 Lucene 搜索引擎库完全兼容。通过对Solr 进行适当的配置，某些情况下可能需要进行编码，Solr 可以阅读和使用构建到其他 Lucene 应用程序中的索引。此外，很多 Lucene 工具（如Nutch、 Luke）也可以使用Solr 创建的索引。注意solr是可以以.war的形式注入到tomcat的服务器中接受后者的托管的。（不知道现在还行不行）。

ElasticSearch是与Solr可以相类比的功能，Solr 利用 Zookeeper 进行分布式管理，而 Elasticsearch 自身带有分布式协调管理功能。具体特点见<http://www.cnblogs.com/chowmin/articles/4629220.html>。基于Lucene的还有许多产品，包括直接Lucene、Katta、Hadoop contrib/index、Lucanda、HBasene。


Nutch与Solr的集成的教程可见<http://blog.csdn.net/lzjzy520/article/details/41597089>。主要在于将Nutch的`conf/schema.xml`文件拷贝到Solr的`server/solr/collection1/conf`目录下面，名子保证是`schema.xml`。然后在其中的`field`结点里面添加一行

```xml
<field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
```

```shell
./bin/crawl ~/urls/ TestCrawl http://localhost:8983/solr/ 2
```

    ～/urls 是存放了种子url的目录
    TestCrawl 是crawlId，这会在HBase中创建一张以crawlId为前缀的表，例如TestCrawl_Webpage。
    http://localhost:8983/solr/ , 这是Solr服务器
    2，numberOfRounds，迭代的次数

过了一会儿，屏幕上出现了一大堆url，可以看到爬虫正在抓取！

刚开始的时候可以不指定solr，而是`bin/nutch crawl ./urls testcrawlid 2`这样的形式。


注：The Nutch-Selenium plugin on Github was made for the Nutch 2.x branch;

注：AFAIK Solr 5.x uses managed-schema in default which will be created on the fly based on the input documents. However you can copy your schema.xml file content to the 

注：<http://blog.csdn.net/lzx1104/article/details/42029981>介绍了Solr 4.9以上的managed-solr的功能。如果使用了ManagedIndexSchemaFactory，Solr会从"managedSchemaResourceName"指定的文件名中加载schema，而不是从schema.xml;如果指定的文件（managed-schema）不存在，将会从schema.xml中加载并创建文件，并将schema.xml重命名为`schema.xml.bak`. 不要编辑managed schema – 外部的修改会被忽略，并被修改schema 的RestAPI调用所覆盖。

`mutable = true`修改schema 的RestAPI调用被允许，否则会报错。



注：nutch的crawl命令是一个完整的从索引到爬取的过程命令。比如

```shell
crawl ./urls/ testcrawl http://10.0.8.68:8983/solr/collection1/ 1
```

### Nutch 1.x 命令介绍：<http://www.cnblogs.com/xia520pi/p/3663506.html>

* nutch的readdb命令是"org.apache.nutch.crawl.CrawlDbReader"的别称，返回或者导出Crawl数据库（crawldb）中的信息。
* readlinkdb是"org.apache.nutch.crawl.LinkDbReader"的别称，导出链接库中信息或者返回其中一个URL信息。
* inject是"org.apache.nutch.crawl.Injector"的别称，注入新URL到crawldb中。
* generate是"org.apache.nutch.crawl.Generator"，从Crawldb中抓取新的Segment。
* fetch是"org.apache.nutch.fetcher.Fetcher"的代称，它负责一个segment的爬取。
* parse是"org.apache.nutch.parse.ParseSegment"的代称，它对一个segment运行ParseSegment。
* readseg是"org.apache.nutch.segment.SegmentReader"的代称，它读取并导出Segment数据。
* updatedb是"org.apache.nutch.crawl.CrawlDb"的代称，用fetch过程中获取的信息更新crawldb。
* invertlinks是"org.apache.nutch.crawl.LinkDb"的代称，它用从segment中获取到的信息更新linkdb。
* index是"org.apache.nutch.indexer.Indexer"的代称，创建一个segment的索引，利用crawldb和linkdb中的数据对索引中的页面打分。
* merge是"org.apache.nutch.indexer.IndexMerger"的代称，它合并多个segment索引。
* mergedb是"org.apache.nutch.crawl.CrawlDbMerger"的代称，合并多个CrawlDb，URLFilter可选择性地过滤指定内容。

可以合并多个DB到一个中。当你分别运行爬虫并希望最终合并DB时，它会相当有用。可选择地，可以运行当前URLFilter过滤数据库中的URL，以滤去不需要的URL。当只有一个DB时也很有用，它意味着你可以通过这个工作去滤掉那些DB中你不想要的URL。

* mergelinkdb是"org.apache.nutch.crawl.LinkDbMerger"的代称，用于合并多个linkdb，可以选择性的使用URLFilter来过滤指定内容。
* mergesegs是"org.apache.nutch.segment.SegmentMerger"的代称，用于合并多个segment，可以选择性地输出到一个或者多个固定大小的segment中。
* dedup是"org.apache.nutch.indexer.DeleteDuplicates"的别名，它segment indexes中去掉重复的页面。
* plugin是"org.apache.nutch.plugin.PluginRepository"的代称，用于从插件库中加载一个插件并执行其主方法。
* solrindex是"org.apache.nutch.indexer.solr.SolrIndexer"的代称，用于对抓取的内容进行索引建立，前提是要有solr环境。


注意我们使用的crawl命令中的testcrawl就是crawlId，该ID可以用于readdb等命令中，比如

```shell
nutch readdb -crawlId testcrawl -stats
### 如果我们后端使用的HBase，那么就可以从HBase中读到相应crawlId的数据库了。
```

解决`No IndexWriters activated - check your configuration`的问题：见<http://stackoverflow.com/questions/17649567/nutch-message-no-indexwriters-activated-while-loading-to-solr/25945844#25945844>。


nutch solrindex -crawlid doubanmovie


### Nutch 2.x的命令接口

Nutch1与Nutch2的接口发生了很大的变化，许多教程解释都已经不能再用了。参考<http://wiki.apache.org/nutch/bin/nutch%20solrindex>，来获得详细一点的针对Nutch2的命令的介绍。

```shell
### 我们从DMOZ开放式分类目录添加URL。
### 首先我们必须下载并且解压缩这个DMOZ所有网页的列表
### 这是一个200多MB的文件，所以这会消耗几分钟
wget http://rdf.dmoz.org/rdf/content.rdf.u8.gz
gunzip content.rdf.u8.gz 

### 接下来我们选择这些网页当中随机的一些子集
### 我们使用随机的子集所以所有在跟着这一个教程做的人就不会伤害到同样的网站
### DMOZ包含了大约三百万个URL。我们从每5000个URL中选择出一个，因此我们就有大约1000个URL
### 这里我们从50000个URL中选择出一个，因此总共选择大约100个，可以节省很多时间
nutch org.apache.nutch.tools.DmozParser content.rdf.u8 -subset 5000 > dmoz/seed.txt

###  最后，我们用这些选出的URL来初始化crawlId（在Nutch 2中改成了crawlId而不是db文件，
### crawlId存在相应的hbase库当中
nutch inject ./dmoz/ -crawlId dmozcrawl 

###  要获取，我们首先要从数据库里产生一个获取的列表，
### 生成的任务中，-topN表示选择的URL数
### -batchId表示我们所生成的这些初始网页的任务名，接下来在fetch等操作的时候可以指定任务名
### topN是每一级所获取的网页数，限制topN可以减少抓取的数目
nutch generate -crawlId dmozcrawl -topN 100

### 在以下面的命令在这个分段里进行获取
### 可以改成前面-batchId指定的参数，以代替fetch
nutch fetch -all -crawlId dmozcrawl -threads 2

### 获取之后parse有关条目
nutch parse -all -crawlId dmozcrawl

###  当这一切完成以后，我们就以获取回来的结果更新数据库
nutch updatedb -all -crawlId dmozcrawl

### 进行索引，在新的nutch里面，已经没有invertindex了，只有index了
nutch index -all -crawlId dmozcrawl
nutch solrindex http://10.0.8.68:8983/solr/test/ -all -crawlId dmozcrawl
nutch solrindex http://10.0.8.68:8983/solr/collection1/ sec200 -crawlId dmozcrawl

### 爬完之后，在nutch里面可以进行查询诊断，其中的faq是关键词
### 该脚本尝试过，不能正常工作
nutch org.apache.nutch.searcher.NutchBean faq

### 提交之后，我们将可以在solr控制台中看到有关文档的数目。
### 任何时候都能运行的测试命令
nutch parse http://www.precastdesign.com/
nutch indexchecker http://www.precastdesign.com/
```


Nutch加MongoDB加ElasticSearch的配置
------------------------------------------------------------------------------

见<http://www.jeepshoe.org/82645084.htm>。


一：nutch2.x与nutch1.x的主要区别：数据访问层的抽象
nutch 2.x----gora-core-0.3----gora-hbase----hbase

gora-core-0.3   apache-gora提供了对nosql访问的统一接口。（注解：在上述链接里可以看到对其他数据库的支持）
gora-hbase  针对hbase实现了gora的接口

有了这两步nutch2.x就可以运行在Hbase上了。
支持nosql的优势：
当获取了外链要进行url排重的时候，以前基于hdfs的时候是读取之前全部的url用mapreduce实现排重（好沉重的赶脚），支持了nosql只需要一步查找即可。

这里Hadoop与HBase的集成主要是将HBase安装到Hadoop当中，然后HBase的rootdir配置成hdfs的方式（即HBase的数据进一步存储在HDFS文件系统当中）。这里在设置hbase-env.sh与hbase-site.xml的时候进行配置的。另外，注意HBase也完全可以与Hadoop割离开，从而仅仅是使用Hadoop的后端而已。当然，HBase还要进一步与ZooKeeper集成。

在配置的时候特别注意Hadoop的版本与HBase的版本的一致性。



### Solr的一个错误的处理


在使用nutch的时候，提交的的时候出现：

```
Expected content type application/octet-stream but got text/html;charset=iso-8859-1
```

<http://stackoverflow.com/questions/24089769/solr-realtime-get-remotesolrexception-expected-mime-type-application-xml-but-go>上面给出来了一个回答。

在使用Tomcat部署Solr后，Collection1的地址为：<http://182.92.160.44:8080/solr/#/collection1>，但使用SolrJ进行索引的时候，应该使用<http://182.92.160.44:8080/solr/collection1>，即无中间的#号。

一个crawl命令可能封装了太多的过程。接下来我们以dmoz为例，一个命令一个命令地执行，看看是什么样的结果。

首先使用solr命令的`solr create -c test`来创建一个默认的collection。然后进入nutch的环节。依次执行如下的命令：



Scala下面使用Nutch
----------------------------------------------------------

<https://blog.knoldus.com/2012/03/14/intercepting-nutch-crawl-flow-with-a-scala-plugin/>。

Nutch 2.0的REST接口，见<https://wiki.apache.org/nutch/NutchRESTAPI>。Nutch教程，比较华丽的版本<http://www.cnblogs.com/xia520pi/p/3615554.html>.
